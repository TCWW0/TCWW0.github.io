<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>函数对象</title>
    <url>/2025/02/25/C++%E5%AD%A6%E4%B9%A0/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><p>​	函数对象其实本身并不神秘，简单来说，一个函数对象就是能够被以函数调用形式来进行调用的任意对象。可以想到，函数对象就应该包括函数名，函数指针以及重载了()运算符的类对象。</p>
<span id="more"></span>

<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>​	函数指针本身也是一个指针。需要知道的是，本质上看，函数其实跟普通的变量一样，都是一个符号，只是说这个符号的功能比较特殊。不必多说，我们先来看一下简单的函数指针的声明方式。</p>
<p>​	一般来说，函数指针是一对一绑定的，这是因为函数指针本身的类型声明比较麻烦的原因。</p>
<p>​	假设我们现在拥有这么一个函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	我们想要定义一个函数指针来指向这个函数，那么我们得先确定我们要使用的这个函数指针所要指向的函数形式来进行声明，简单来看，一个函数指针需要一下这些信息:(函数的返回类型，函数的所有参数类型)。并通过这样来进行声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*func_ptr)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// 定义一个函数指针</span></span><br></pre></td></tr></table></figure>

<p>​	通过这种定义，我们就定义了一个能够指向返回类型为int,拥有俩个int参数的函数的函数指针。</p>
<p>​	再用文字来重复一遍，一个函数指针的声明由(函数返回类型，(*函数指针符号名)(函数参数返回类型枚举))来组成。</p>
<p>​	</p>
<ul>
<li><strong>函数指针的使用</strong></li>
</ul>
<p>​	函数指针相对于其他符号来说有点不同，重点就是他可以通过()来直接调用该函数指针指向的函数。</p>
<p>​	来看一个小demo</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义函数指针并指向 add 函数</span></span><br><span class="line">    <span class="built_in">int</span> (*func_ptr)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过函数指针调用 add 函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; <span class="built_in">func_ptr</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;  <span class="comment">// 输出 7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	但其实这种使用情况是很少见的，毕竟你完全可以通过函数本身去进行调用，至于那些个类函数，那你更不应该通过函数指针来进行调用，更多的是将函数指针来作为函数参数的传递来实现更多的扩展。这个之后碰到再说。</p>
<p>​	</p>
<p>在stl中，函数符的概念已经被定义了，如下</p>
<ul>
<li>生成器是不用参数能直接调用的函数符</li>
<li>一元函数是用一个参数就可以调用的函数符</li>
<li>二元函数是用一个参数就可以调用的函数符</li>
<li>返回bool值的一元函数是谓词</li>
<li>返回bool值的二元函数是二元谓词</li>
</ul>
<p>​	来看一下最常用的stl库排序函数sort函数，这个函数前面俩个参数使用的是俩个迭代器，第三个参数时一个谓词(应该是一个二元谓词，毕竟需要将俩个数进行比较)</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>类常量</title>
    <url>/2024/12/28/C++%E5%AD%A6%E4%B9%A0/%E7%B1%BB%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>​	在这个栏目中，我们将不会对于一个知识点进行系统的学习，将只会对于各个我在过程中遇到的一些问题进行一些分析。</p>
</blockquote>
<h1 id="零散知识点"><a href="#零散知识点" class="headerlink" title="零散知识点"></a>零散知识点</h1><h2 id="const属性"><a href="#const属性" class="headerlink" title="const属性"></a>const属性</h2><p>​	首先来看到一句话</p>
<blockquote>
<p>当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。</p>
</blockquote>
<p>​	这句话其实涉及到了C++中对于const属性的一些分析，我们来看一下。</p>
<p>​	在C++中，const声明的值是一种常量，我们通常会使用这种来做为程序中不变的量，但是我们是否考虑过这种常量是怎么来的呢。其实在CSAPP中，我们学到了一点，就是基本来说这些个常量，或者说局部静态变量在编译链接后生成的二进制文件中都存在着一块各自的内存区域。</p>
<p>​	回顾一下吧，GPT真好用，我都省的去敲了。</p>
<span id="more"></span>

<hr>
<h3 id="1-bss-段"><a href="#1-bss-段" class="headerlink" title="1. .bss 段"></a>1. <strong><code>.bss</code> 段</strong></h3><ul>
<li><strong>全称</strong>：Block Started by Symbol。</li>
<li>存储内容：<ul>
<li><strong>未初始化的全局变量</strong>。</li>
<li><strong>未初始化的静态变量</strong>（包括 <code>static</code> 修饰的局部变量）。</li>
<li><strong>初始化为零的全局或静态变量</strong>。</li>
</ul>
</li>
</ul>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>节省空间</strong>：未初始化变量在 <code>.bss</code> 段中只记录变量大小和布局，实际运行时会分配内存，并自动初始化为零（通常由操作系统负责）。(这也是未初始化的全局变量默认为0的原因)</li>
<li>不直接存储在程序的可执行文件中，而是在加载时动态分配。</li>
</ul>
<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>​	我又来开始发散思维了，来分析下这里所谓的节省空间的含义。</p>
<p>​	首先，对于这些个.bss段中的数据，可执行文件中值存在着这些数据的部分属性。就比如，标识这个数据存在，这个数据的变量名，这个数据的类型等。但是，在这个文件之中，并不存在对于这个数据实际的值的表示。这也是符合出现在这个文本段中的数据的性质的。</p>
<p>​	这里面的这系列数据只会在可执行文件被操作系统加载到内存中去再进行一次初始化，而且这系列的初始化都会为0，这里就不要问为什么了，毕竟初始化不为0的就不再这个文本段中而在我们的.data段中了。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;              <span class="comment">// 全局未初始化变量 -&gt; .bss</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> y;       <span class="comment">// 静态未初始化变量 -&gt; .bss</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> z = <span class="number">0</span>;   <span class="comment">// 静态初始化为零 -&gt; .bss</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-data-段"><a href="#2-data-段" class="headerlink" title="2. .data 段"></a>2. <strong><code>.data</code> 段</strong></h3><ul>
<li><strong>全称</strong>：Data Segment。</li>
<li>存储内容：<ul>
<li><strong>已初始化的全局变量</strong>。</li>
<li><strong>已初始化的静态变量</strong>（包括局部静态变量）。</li>
</ul>
</li>
</ul>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><code>.data</code> 段中的变量在程序运行前已经完成初始化，初始化的值直接存储在可执行文件中。</li>
<li>这些变量的内容在运行时可以修改。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;             <span class="comment">// 全局已初始化变量 -&gt; .data</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b = <span class="number">20</span>;      <span class="comment">// 静态已初始化变量 -&gt; .data</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-rodata-段"><a href="#3-rodata-段" class="headerlink" title="3. .rodata 段"></a>3. <strong><code>.rodata</code> 段</strong></h3><ul>
<li><strong>全称</strong>：Read-Only Data Segment。</li>
<li>存储内容：<ul>
<li><strong>只读的常量</strong>（如字符串字面量）。</li>
<li><strong><code>const</code> 修饰的全局或静态变量</strong>。</li>
<li>某些编译器优化后的结果（如 <code>constexpr</code>）。</li>
</ul>
</li>
</ul>
<h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><code>.rodata</code> 是只读的，运行时无法修改。</li>
<li>主要用于存储不会改变的值，编译器可能利用这段内容进行内存保护。</li>
<li>常量通常会存储在 <code>.rodata</code> 中，而不是 <code>.data</code>。</li>
</ul>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">30</span>;           <span class="comment">// 全局 const 变量 -&gt; .rodata</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> d = <span class="number">40</span>;    <span class="comment">// 静态 const 变量 -&gt; .rodata</span></span><br><span class="line"><span class="type">char</span>* str = <span class="string">&quot;Hello&quot;</span>;        <span class="comment">// 字符串字面量 -&gt; .rodata</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-总结对比"><a href="#4-总结对比" class="headerlink" title="4. 总结对比"></a>4. <strong>总结对比</strong></h3><table>
<thead>
<tr>
<th><strong>段名</strong></th>
<th><strong>存储内容</strong></th>
<th><strong>是否初始化</strong></th>
<th><strong>运行时可修改</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>.bss</code></strong></td>
<td>未初始化的全局变量，静态变量，初始化为零的变量</td>
<td>否（加载时清零）</td>
<td>是</td>
</tr>
<tr>
<td><strong><code>.data</code></strong></td>
<td>已初始化的全局变量，已初始化的静态变量</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td><strong><code>.rodata</code></strong></td>
<td>只读常量、<code>const</code> 全局或静态变量，字符串字面量</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-运行时的内存布局"><a href="#5-运行时的内存布局" class="headerlink" title="5. 运行时的内存布局"></a>5. <strong>运行时的内存布局</strong></h3><p>程序在运行时的内存结构主要分为以下区域：</p>
<ul>
<li><strong>代码段（.text）</strong>：存储程序的可执行代码。</li>
<li>数据段：<ul>
<li><code>.bss</code>：未初始化的全局或静态变量。</li>
<li><code>.data</code>：已初始化的全局或静态变量。</li>
<li><code>.rodata</code>：只读常量和字面量。</li>
</ul>
</li>
<li><strong>堆（Heap）</strong>：动态分配的内存（如 <code>malloc</code> 或 <code>new</code>）。</li>
<li><strong>栈（Stack）</strong>：局部变量和函数调用栈。</li>
</ul>
<hr>
<h3 id="6-可视化示例"><a href="#6-可视化示例" class="headerlink" title="6. 可视化示例"></a>6. <strong>可视化示例</strong></h3><p>假设以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_var;             <span class="comment">// -&gt; .bss</span></span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">10</span>;   <span class="comment">// -&gt; .data</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> const_var = <span class="number">20</span>;   <span class="comment">// -&gt; .rodata</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_var;      <span class="comment">// -&gt; .bss</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_init_var = <span class="number">30</span>; <span class="comment">// -&gt; .data</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> local_var = <span class="number">40</span>;     <span class="comment">// -&gt; 栈</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_local_var = <span class="number">50</span>; <span class="comment">// -&gt; .data</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>; <span class="comment">// -&gt; .rodata</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>​	现在看完了上面几个，其实，并没有对于我们理解上面那句话有什么用处，举出上面那个例子主要是要把我接下来的对于const对象性质和.rodata段的性质做一些区分。</p>
<h3 id="const-对象的构造"><a href="#const-对象的构造" class="headerlink" title="const 对象的构造"></a><strong><code>const</code> 对象的构造</strong></h3><ul>
<li><p>当我们声明一个 <strong><code>const</code> 对象</strong> 时，编译器要求这个对象的值在构造之后不能被修改。这是对象的<strong>常量性</strong>。</p>
</li>
<li><p>然而，<code>const</code> 对象的构造过程</p>
<p>并不等同于 .rodata段的只读数据，它实际上是对象的生命周期的一部分。</p>
<p>在对象的构造过程中，<code>const</code> 对象的成员变量是可以被初始化的，即使它们之后不能被修改。</p>
<ul>
<li>在构造函数中，你仍然可以对 <code>const</code> 对象的成员进行赋值，但一旦构造函数完成，成员就会被标记为“常量”，不能再修改。</li>
</ul>
</li>
</ul>
<blockquote>
<p>当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。</p>
</blockquote>
<p>​	我们需要先来分析下我们现在需要分析的是谁。首先，我们分析的必然不是那些在.rodata段中的数据。毕竟这些数据已经被严格保护起来了，没有进行研究的价值。</p>
<p>​	我们需要重点看的其实是对于那些存在于栈帧上的const常量，这些常量的生命周期与栈帧绑定，这些就不赘述了。主要是看到，我们在栈帧中对于这些变量到底是怎么构造的。</p>
<h4 id="栈帧常量"><a href="#栈帧常量" class="headerlink" title="栈帧常量"></a>栈帧常量</h4><p>​	对于栈帧的常量，由于它是从0开始构造的，所以它必须经过一个初始化的过程，而这个就是起初困惑我的地方。毕竟你已经是一个常量了，但是你为什么还需要去进行初始化呢。但是，这是我对常量先入为主造成的一种后果。我忽略了语言设计的细节。如果不去进行初始化，我还怎么去取得一个常量呢。所以，这里就存在一个可能的异或。</p>
<p>​	所以，我们需要知道const常量构建的流程，在一个const常量构建中，这个数据一开始并不具有const这个属性，这个属性可以看做是在这块数据处理的最后阶段才进行处理的。毕竟学了CSAPP后我们应该简单的知道这些所谓的权限管理到底是一个什么个情况，实际上其实就是一些标志位的修改，就比如这里，通过将可修改的标志位置0等来进行变量的锁定。</p>
<p>​	但是，在这个锁定之前，我们这块数据还是可以修改的，这就意味着我们完全可以在这段时期对于数据进行处理。而这段时间就是我们const常量的实际初始化时间，在这个时间中，所谓的const常量其实可以视为只是一个简单的变量，所以我们可以对于这块数据进行任意的修改知道我们的权限标志位被锁。</p>
<p>​	</p>
<blockquote>
<p>​	<strong>通过对于const常量的较为深入的理解，我们理解了为什么在这种初始化过程中可以向其中去写值。</strong></p>
</blockquote>
<blockquote>
<p><strong>接下来想一些比较零碎的知识点，主要是关于类的构造函数那一块的</strong></p>
</blockquote>
<p>我们主要来看那些默认构造函数的一些性质。</p>
<h2 id="合成默认构造函数的限制"><a href="#合成默认构造函数的限制" class="headerlink" title="合成默认构造函数的限制"></a><strong>合成默认构造函数的限制</strong></h2><hr>
<h3 id="1-默认构造函数的生成规则"><a href="#1-默认构造函数的生成规则" class="headerlink" title="1. 默认构造函数的生成规则"></a>1. <strong>默认构造函数的生成规则</strong></h3><ul>
<li>编译器只有在类<strong>未显式声明任何构造函数</strong>时，才会为类生成一个<strong>合成的默认构造函数</strong>。</li>
<li>如果类中声明了任何构造函数（比如带参数的构造函数），编译器不会再生成默认构造函数。</li>
<li><strong>规则的依据</strong>：如果一个类需要通过特定构造函数控制初始化，则可能在所有情况下都需要这种控制。由用户显式定义默认构造函数可以确保这种一致性。</li>
</ul>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value) : <span class="built_in">x</span>(value) &#123;&#125; <span class="comment">// 自定义构造函数</span></span><br><span class="line">    <span class="comment">// 编译器不会合成默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">A obj; <span class="comment">// 错误，缺少默认构造函数</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-合成默认构造函数可能执行错误操作"><a href="#2-合成默认构造函数可能执行错误操作" class="headerlink" title="2. 合成默认构造函数可能执行错误操作"></a>2. <strong>合成默认构造函数可能执行错误操作</strong></h3><p>对于含有<strong>内置类型或复合类型</strong>的类，如果这些成员未显式初始化，编译器生成的合成默认构造函数不会为它们赋值，可能导致未定义行为。</p>
<h4 id="为什么可能出错？"><a href="#为什么可能出错？" class="headerlink" title="为什么可能出错？"></a>为什么可能出错？</h4><ul>
<li><p><strong>内置类型</strong>（如 <code>int</code>、<code>float</code>）和<strong>复合类型</strong>（如数组、指针）在默认初始化时，其值未定义。</p>
</li>
<li><p>如果用户没有手动初始化这些成员变量，程序可能使用未定义的值，导致潜在的逻辑错误或运行时异常。</p>
<blockquote>
<p>这里来对于这种为定义的行为存在的分析</p>
</blockquote>
<p>​	我们一直听所谓的未初始化导致随机值，但是为什么呢？这个的原因其实如果学过CSAPP应该很好理解。毕竟这些所谓的声明，其实就是一段开辟内存的代码，这段代码所开辟的内存将交给我们的操作系统进行维护。但是，这里只是开辟了一段内存，进行了一段指针的偏移，这块内存上的值呢？我们并没有对其进行初始化，由于我们所谓的销毁变量其实就是操作系统取消对其的维护，一些指针进行额外的移动等。在这其中并不存在对于内存区域的重新初始化。所以，这块内存上的东西可能是任何时候遗留下来的，但是系统并不会去检查它到底是什么，它只是去读取并且解析，所以这就导致了所谓的未定义的情况。</p>
</li>
</ul>
<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ul>
<li>提供<strong>类内初始化</strong>（C++11 引入）或<strong>自定义默认构造函数</strong>，确保所有成员变量有明确的初始值。</li>
</ul>
<h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;       <span class="comment">// 内置类型，未初始化</span></span><br><span class="line">    <span class="type">int</span> *ptr;      <span class="comment">// 指针类型，未初始化</span></span><br><span class="line">    <span class="comment">// 合成的默认构造函数不会初始化 num 和 ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B obj; <span class="comment">// 使用 num 和 ptr 时会导致未定义行为</span></span><br></pre></td></tr></table></figure>

<p>改进：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;   <span class="comment">// 类内初始化</span></span><br><span class="line">    <span class="type">int</span> *ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 合成的默认构造函数现在是安全的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() : <span class="built_in">num</span>(<span class="number">0</span>), <span class="built_in">ptr</span>(<span class="literal">nullptr</span>) &#123;&#125; <span class="comment">// 自定义默认构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-无法为某些类合成默认构造函数"><a href="#3-无法为某些类合成默认构造函数" class="headerlink" title="3. 无法为某些类合成默认构造函数"></a>3. <strong>无法为某些类合成默认构造函数</strong></h3><p>如果类包含的成员类型本身<strong>没有默认构造函数</strong>，编译器将无法为该类生成合成的默认构造函数。</p>
<h4 id="为什么无法生成？"><a href="#为什么无法生成？" class="headerlink" title="为什么无法生成？"></a>为什么无法生成？</h4><ul>
<li>成员对象的初始化必须调用其构造函数。</li>
<li>如果成员类型没有默认构造函数，编译器无法完成其初始化。</li>
</ul>
<h4 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125; <span class="comment">// 没有默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    C c; <span class="comment">// 成员 c 的类型是 C</span></span><br><span class="line">    <span class="comment">// 编译器无法合成默认构造函数，因为 C 类型没有默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">D obj; <span class="comment">// 错误：D 的默认构造函数无法生成</span></span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<ul>
<li>为成员类型提供默认构造函数，或者在包含该成员的类中显式定义默认构造函数并指定初始化方式。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> val = <span class="number">0</span>) : <span class="built_in">x</span>(val) &#123;&#125; <span class="comment">// 添加默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    C c; <span class="comment">// 成员 c 的类型现在有默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">D obj; <span class="comment">// 正常工作</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. <strong>总结</strong></h3><h4 id="为什么某些类不能依赖合成的默认构造函数？"><a href="#为什么某些类不能依赖合成的默认构造函数？" class="headerlink" title="为什么某些类不能依赖合成的默认构造函数？"></a>为什么某些类不能依赖合成的默认构造函数？</h4><ol>
<li><strong>用户显式声明构造函数后，编译器不会生成默认构造函数</strong>。</li>
<li><strong>合成默认构造函数对内置或复合类型成员不安全</strong>，可能导致未定义行为。</li>
<li><strong>当成员类型缺少默认构造函数时，编译器无法生成默认构造函数</strong>。</li>
</ol>
<h4 id="最佳实践："><a href="#最佳实践：" class="headerlink" title="最佳实践："></a>最佳实践：</h4><ul>
<li>如果类中含有<strong>非简单类型成员</strong>或<strong>需要自定义初始化逻辑</strong>，显式定义默认构造函数。</li>
<li>利用 <strong>类内初始化</strong> 提高代码安全性和可读性。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器与部分类回顾</title>
    <url>/2025/02/15/C++%E5%AD%A6%E4%B9%A0/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p>该篇是在对于std标准库的迭代器初步接触时所写，只是一些基本的常识以及对于部分类知识的回顾</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="初步了解"><a href="#初步了解" class="headerlink" title="初步了解"></a>初步了解</h2><p>​	迭代器本身其实并没有什么特殊的，我们需要先从它存在的意义开始了解，对于一个迭代器，其的存在意义就是为一系列的容器提供一个通用的接口。通过这个接口，我们能够实现一系列的操作。</p>
<span id="more"></span>

<h3 id="基础作用"><a href="#基础作用" class="headerlink" title="基础作用"></a>基础作用</h3><p>​	既然是迭代器，那我我们势必要了解这个<strong>迭代</strong>到底是针对谁的迭代。在std库中，这个迭代就是针对于数据元素的迭代。简单来说，一个迭代器的基本作用就是实现对于一些数据的访问，至于这些数据到底是什么，相对来说迭代器本身不是多么的关注。也就是说，迭代器其实可以看做是一个相对独立的数据访问机制。其于数据组织结构之间是一种弱耦合的状态的。</p>
<p>​	通过使用迭代器，我们应该能够实现对于一定数据的访问操作。</p>
<h3 id="出现契机"><a href="#出现契机" class="headerlink" title="出现契机"></a>出现契机</h3><p>​	对于迭代器的出现原因进行一定的了解可以更加方便我们熟悉这个东西。</p>
<p>​	个人感觉迭代器的出现与设计模式的出现契机有点相似。都是为了对于一系列经验的总结后自然而然出现的东西。由前文知道，我们创建一个迭代器的目的就是为了去进行一个数据的查询，修改等操作，可以预料到这些操作都是相当常见的，如果我们使用常规的设计，我们需要在一个类中去定制特定的数据处理操作。这样其实就是把底层数据组织模块与操作模块进行了一次的强耦合绑定，这种绑定可以预料到时非常难看的。而且复用性很差。</p>
<p>​	自然而然，我们就需要一种工具来独立进行这种数据操作，通过将数据组织模块和数据处理模块之间的解耦，提高代码复用性的同时减少了在设计时的复杂度，其实也可以看做是一种结构性设计模式。</p>
<blockquote>
<p>​	至此，我们知道了对于迭代器到底应该以怎么样的。同时，我们应该能够理解一些迭代器所应该具有的一些性质。</p>
</blockquote>
<h2 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h2><p>​	到现在，我们还不知道一个迭代器到底是什么。我们直接进入正题。</p>
<h3 id="裸指针"><a href="#裸指针" class="headerlink" title="裸指针"></a>裸指针</h3><p>​	由前面知道，迭代器的基础功能是完成数据的查询，修改等操作。那么根据这些属性，我们最先能够想到的基本数据类型是什么，其实就是裸指针。回想一下，通过对指针进行解引用以及各种运算符的操作，我们是不是能够操作这个指针指向的内存中存在的数据，而且通过对指针本身进行一些操作符的运算，我们能够实现通过一个指针访问到一块数据。</p>
<p>​	这些个性质其实都是一个迭代器所应该具有的性质，接下来，我们需要进行的就是对于这个裸指针进行2扩展。毕竟，你知道的，裸指针这东西往往是无法满足我们自己的需求的。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>​	相对来说，使用一个类作为迭代器来在实际应用中更加常见，先来看一个demo</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyVector</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* data;</span><br><span class="line">        <span class="type">size_t</span> size;        <span class="comment">//容器当前的大小</span></span><br><span class="line">        <span class="type">size_t</span> capacity;    <span class="comment">//容器的最大容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyVector</span>():<span class="built_in">size</span>(<span class="number">0</span>),<span class="built_in">capacity</span>(<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            data=<span class="keyword">new</span> <span class="type">size_t</span>[capacity];;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">MyVector</span>(<span class="type">size_t</span> s):<span class="built_in">size</span>(<span class="number">0</span>),<span class="built_in">capacity</span>(s)</span><br><span class="line">        &#123;</span><br><span class="line">            data=<span class="keyword">new</span> <span class="type">size_t</span>[capacity];;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">MyVector</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (size &gt;= capacity) &#123;</span><br><span class="line">                capacity *= <span class="number">2</span>;</span><br><span class="line">                T* new_data = <span class="keyword">new</span> T[capacity];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                    new_data[i] = data[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span>[] data;</span><br><span class="line">                data = new_data;</span><br><span class="line">            &#125;</span><br><span class="line">            data[size++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">get_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 迭代器内部实现</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            T* ptr;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Iterator</span>(T* ptr) : <span class="built_in">ptr</span>(ptr) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 解引用操作符，返回迭代器指向的元素</span></span><br><span class="line">            T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">                <span class="keyword">return</span> *ptr;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 前进操作符，返回迭代器指向的下一个元素</span></span><br><span class="line">            Iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 比较操作符，用于判断迭代器是否相等</span></span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ptr != other.ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 返回一个指向容器第一个元素的迭代器</span></span><br><span class="line">        <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Iterator</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 返回一个指向容器末尾之后位置的迭代器</span></span><br><span class="line">        <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Iterator</span>(data + size);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	从此间可以看到，一个迭代器其实并不神秘，就是一个类中类，在这个类中类中，又有着对应的类型指针。这个类型指针又有着一系列的方法。在一些书中，可以看到很多的迭代器类型，这些本质上其实就是一些基于类提供的不同方法所进行的分类。再简单点，就是通过重载方法的不同实现以及所带来的不同功能所进行的分类。</p>
<p>​	在此时先不用去了解各个类型的迭代器的具体，先来简单过一遍概念即可。</p>
<h2 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h2><ol>
<li><strong>输入迭代器</strong></li>
</ol>
<p>​	输入是相对于程序来说的。不难推的，一个输入迭代器必须能够使得程序能够读取由这个输入迭代器管理着的数据。</p>
<p>​	这个体现在迭代器类中的设计中则是解引用符(*)的重载，通过对于这个迭代器进行解引用，程序能够实现对应数据的读取，这也是该迭代器被加上<strong>输入</strong>这一前缀的原因。</p>
<p>​	同时，为了单一职责原则以及对于数据的保护，输入迭代器不应该有对于数据的修改权限，这个则是通过不实现对应的修改数据方法实现的。</p>
<ol start="2">
<li><strong>输出迭代器</strong></li>
</ol>
<p>​	有了上面那个的初了解，我们应该也粗略知道了这个输出所应该的含义。通过这个输出迭代器，我们能够使用容器中的数据作为输出提供给其他需要的地方。跟输入迭代器一样，这里也应该对于迭代器处理数据的权限做一些限制。</p>
<p>​	对应的是，输出迭代器应该具有数据的修改权限而不具备数据的读取权限，这个的实现也很简单，略。</p>
<ol start="3">
<li><strong>正向迭代器</strong></li>
</ol>
<p>​	该迭代器与前面俩个迭代器一致，都使用++重载来进行容器的遍历，需要注意的是，这个迭代器类型应该能够是的先前的迭代器能够被保存，同时，这个迭代器还存在着一些对于数据的访问控制。但是这个正向迭代器不像之前的俩个迭代器有统一的规定。你可以根据自己的需求去进行修改。</p>
<ol start="4">
<li><strong>双向迭代器</strong></li>
</ol>
<p>​	这个就不进行赘诉了，跟正向迭代器都是大同小异的。主要就是相对于来说需要额外添加一个反向的重载运算符。没什么意思就不进行深入了。</p>
<p>​    5. <strong>随机访问迭代器</strong></p>
<p>​	这个迭代器具有双向迭代器的所有性质，除此之外，还支持能够进行随机访问。实际上就是对于[]的重载，毕竟指针的[]使用就是我们常用的一种随机访问，通过这种统一能够具有更好的扩展性。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​	简单来看，上面5种迭代器其实形成了一种比较直观的层次结构。以输入和输出迭代器为基础。在上面包裹了一层正向迭代器，在正向迭代器的基础上进行扩展产生了双向迭代器。最后再对双向迭代器进行包装实现了随机访问迭代器。这种架构下的每一层的实现难度逐渐递增，同时功能也逐渐强大，带来的代价也成正比增加。因此，我们可以根据自己的需求去选择自己需要的迭代器种类去平衡性能与损耗之间的关系。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>类模版</title>
    <url>/2025/02/16/C++%E5%AD%A6%E4%B9%A0/%E7%B1%BB%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><p>​	模版是C++中一个相对重要的特性了，直接来吧</p>
<h2 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h2><p>​	由于这种东西还是得上手去敲，所以我们在这里对很多内容将会进行简化。</p>
<p>​	模版这种东西最直观的作用就是进行方法与所使用的数据类型之间的解耦，使得在设计方法时能够更加专注于特定功能的方法的构建而不必要去关注所使用的数据类型。</p>
<span id="more"></span>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>​	一个模版的声明，无论是类模版，还是函数模版，都是基本一致的。通过template关键字来进行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;		||		<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br></pre></td></tr></table></figure>

<p>​	这样就完成了一个模版的创建，但仅仅声明一个模版是没有意义的，我们需要去使用这个模版。</p>
<p>​	总的来说，通过关键字<strong>template</strong>和尖括号的组合，我们能够创建出一个模版，这个模版中，可以去使用class关键字或者typename关键字，俩者等效，主要是习惯上的差别。接着，在class&#x2F;typename之后会跟上一个变量名，这一个就是我们模版的一个符号，我们在接下来的作用域中使用模版的直观体现，就是使用这里的符号。</p>
<blockquote>
<p>在使用前，我们需要了解一些简单的模板所具有的性质</p>
</blockquote>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>​	一个模版的作用域是有限的，简单的说，其只会在距离其最近的一个作用域中生效，并且在离开改作用域时，其他作用域中不可见。特别需要注意的是，在部分的模版使用中，可以看到系列的嵌套模版，这些的作用域可以用局部自动变量来进行类比，这里就不进行赘诉了。</p>
<h2 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h2><p>​	接下来通过一个简单的demo来了解一下简单的类模版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;MAX=<span class="number">10</span>&#125;;</span><br><span class="line">    T data[MAX];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>()&#123;top=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> stack&lt;T&gt;::<span class="built_in">isempty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> stack&lt;T&gt;::<span class="built_in">isfull</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top==MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> stack&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isfull</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        data[top++]=item;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> stack&lt;T&gt;::<span class="built_in">pop</span>(T&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isempty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    item=data[--top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	从上面可以了解到几点，一个template是一个独立的模版的声明。在这个关键字声明的模版之后紧邻的一个作用域中，该模版一直可见，直到出去了该作用域，该模版失效。</p>
<p>​	除此之外，我们还需要看到一点的是，模版类的一些特殊性质。</p>
<hr>
<h3 id="模版类"><a href="#模版类" class="headerlink" title="模版类"></a>模版类</h3><h4 id="实例时机"><a href="#实例时机" class="headerlink" title="实例时机"></a>实例时机</h4><p>​	对于一个使用模版的类来说，这个类其实并不是一个严格意义上实例的类，换句话说，这个类其实是不存在的，因为我们现在并没有一个实际的类声明可以供给我们去进行类的实例化。这是模版的设计上导致的。毕竟模版的性质就导致了程序能够根据不同的数据类型来进行对于的数据类型的类进行创建。</p>
<p>​	正如那句经典的话:不要为不需要的特性去浪费时间，这里其实也利用了一种类似于懒加载的机制。程序并不会在一开始就进行所有的类型的模版类的实例创建。具体的等下再继续阐述。</p>
<p>​	总的来说，现在需要知道的就是一个模版类在编写阶段其实是一种虚的阶段，在编译器层面不会存在任何模版类这种东西，毕竟带入实际的数据类型一个模版类才有存在的价值。</p>
<h4 id="模版类方法"><a href="#模版类方法" class="headerlink" title="模版类方法"></a>模版类方法</h4><p>​	可以观察到，在我们进行类方法的补充时，如果我们的定义是在类内进行的，其实跟普通的没什么区别。但是当我们需要再类外去进行类内方法的定义时，这里有几个需要注意的点。</p>
<p>​	首先，我们知道我们如果想要在类外去进行类方法的定义，那么我们需要再对于的方法前去加上类解析符(<strong>类名::</strong>)。在模版类中也是如此，但是前面说过了，一个模版类stack其本身不是一个完整的类，并不存在一个实际上的类声明表示这个类。模版类的正确解析符则是在类名之后加上我们的模版参数，通过这样，之后的各种方法，才能够被绑定到创建的各种模版类实例中去。就比如**stack&lt; int &gt;**就代表着一种使用int数据类型进行填充的stack类，这样的类在编译器层面才会生成对于的类定义，也就才有意义。</p>
<p>​	那我们这里再来观察下模版在类内的使用，前面我们已经知道创建的模版会以对于的声明的typename&#x2F;class后面的符号名来进行使用。在类内的体现就是**T data[MAX];**可以看到的是，一个模版的使用，其实就是跟一个基本数据类型的使用别无二致，我们只需要记住这个模版在未来会被替换为具体的数据类型来进行类的声明即可。</p>
<blockquote>
<p>​	除了这种模版的基础使用之外，还有俩种比较常用的模版使用。</p>
</blockquote>
<h4 id="多功能"><a href="#多功能" class="headerlink" title="多功能"></a>多功能</h4><h5 id="多参数模版"><a href="#多参数模版" class="headerlink" title="多参数模版"></a>多参数模版</h5><p>​	一个template能够承载多个参数，这个其实没有什么好说的，就是一个使用的扩展。例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>​	这样的模版声明就是一个多参数模版的构建，通过这样的声明，我们能在接下来的作用域中，去使用这俩个模版参数。这来个模版参数的使用与一个模版参数的使用并没有什么显著的区别。</p>
<h5 id="递归使用模版"><a href="#递归使用模版" class="headerlink" title="递归使用模版"></a>递归使用模版</h5><p>​	其实上面那个代码实例就是一个递归使用模版的例子。我们需要知道的是string其实是一个模版实例化后再进行一个名称转换后的产物，就是一个basic_string&lt;char*&gt;模版。</p>
<p>​	要了解这种递归的使用会产生什么效果，我们需要去观察到这里模版类生成的最后的具体的类声明到底是一个什么样的，理解了这个，我们接下来的很多关于类的使用都能减轻负担。</p>
<h2 id="模版具体化"><a href="#模版具体化" class="headerlink" title="模版具体化"></a>模版具体化</h2><p>​	前面已经提到过了，一个模版类不是一个真正的类，只有在一个模版类被指定特定的模版参数时，它才可能进行对应的模版类的构建，具体的表现就是使用对于的类型参数去替换对于的模版类中的模版参数，只有在进行了替换之后，这个生成的类才是一个真正意义上的类。这个阶段通常是由编译器在编译阶段自动执行的。</p>
<blockquote>
<p>​	模版的具体化存在着多种情况，一种种来进行分析。</p>
</blockquote>
<h3 id="隐式实例化"><a href="#隐式实例化" class="headerlink" title="隐式实例化"></a>隐式实例化</h3><p>​	这是我们最常见的一种形式，也是我们前面所说的，通过编译器自动判断我们传递给模版类的类型参数来进行对于的类定义的生成的方式。例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ArrayTP&lt;<span class="type">int</span>,<span class="number">100</span>&gt; stuff;</span><br></pre></td></tr></table></figure>

<p>​	需要注意的是，编译器在生成对于的类的时候，采取一种类似于懒加载的机制，只有在需要一个真正的被创建出来的类实例的时候，才会进行特定的类定义的生成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ArrayTP&lt;<span class="type">double</span>, <span class="number">30</span>&gt;* pt;		<span class="comment">//只是一个指针，不会导致对象的创建</span></span><br><span class="line">pt=<span class="keyword">new</span> ArrayTP&lt;<span class="type">double</span>, <span class="number">30</span>&gt;;		<span class="comment">//使用了new，需要调用构造函数去创建，因此会生辰对于的类定义</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>额外需要注意的是，对于模版类来说，不只是其的类定义是一种懒加载的机制，其的方法也可以看做是一种懒加载的机制，只有在使用到对于的类方法时，才会进行对于的类方法的实例化构建。</p>
</blockquote>
<h3 id="显式实例化"><a href="#显式实例化" class="headerlink" title="显式实例化"></a>显式实例化</h3><p>​	对应于隐式实例化的还有一种显式实例化。顾名思义，就是显式的指出编译器需要去进行这种模版类的构建，这种方法的使用也很简单，就是在给模版类提供类型参数时前面加上一个<strong>template</strong>关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">ArrayTP</span>&lt;<span class="type">double</span>,<span class="number">100</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>​	通过加上这个关键字，在编译器识别到这行语句时，会直接进行对应的类定义的构建。</p>
<hr>
<p>​	</p>
<blockquote>
<p>这里我们在对实例化的时机进行一下剖析，熟悉的从一个简单的东西突然发散然后给我感到想这想那，虽然浪费了一些时间，不过对于一些东西的理解也加深了，寒假末期也得逐渐找回状态了。</p>
</blockquote>
<h3 id="实例化时机"><a href="#实例化时机" class="headerlink" title="实例化时机"></a>实例化时机</h3><p>​	无论是显式还是隐式的实例化，它的实例化都是在编译阶段进行的，也就是说，即使是你在运行阶段完全没有涉及到部分模版类的使用，这些个模版类还是会在编译阶段被实例化。那么，隐式实例化相对于显式实例化的意义到底在哪呢？</p>
<p>​	这里我们就需要对于隐式实例化的实例时机来分析了，就现在我所了解到的，隐式实例化是在编译器识别到代码进行了特定的模版类的使用时进行的实例化。简单来说，编译器会进行一个全部文件代码的阅读，在这其中，我们可以简单的省略所有的判断条件，只要出现了特定的模版类使用(包括但不限于一个模版类对象的创建，类方法的使用)，那么这对应的类定义以及类方法定义都会被实例化。</p>
<p>​	知道了上面这点后，我们对于隐式实例化与显式实例化之间的区别应该有所了解了。一个隐式实例化相对于显式实例化能够更加节省编译器的资源，能够减少对于的类原型以及方法构建所需要的时间以及空间。那么，显式构建的优势在哪呢？</p>
<p>​	其实一直到现在，由于我还没有对于模版进行比较深入的使用与了解，对于提到的显式实例化的优势，我也是有点怀疑的，不过假设我已经知道了这一块的。或者说，假定这个隐式实例化会导致一定的多余定义。那么显式实例化能够起到的作用其实很明显，就是通知编译器去生成一个对于的完整的类，包括类声明以及对于的方法定义。在这种情况下只要使用到这个被显式实例化的模版类，编译器不会再尝试去生成一个相同的类，这样能避免一些编译层面可能存在的问题。</p>
<p>​	我们简单的使用链接性来进行隐式实例化与显式实例化之间存在的区别，</p>
<p>​	简单来说，隐式实例化生成的符号(类以及对应的方法)等都只是一个局部链接性。当我们想要在多个文件这种去使用这个模版类去进行相同的类型实例化时，将会导致每个文件都产生对应的相同符号并编入到符号表中，在最后的符号表中，会存在符号重复的情况。虽然说编译器一般会对这些重复的符号进行合并。但是，这种生成是一种花销，这种合并也是一种花销。为了减少这种花销，提高性能，因此，出现了显式实例化这种功能。</p>
<p>​	而显式实例化产生的类是一个全局链接性的，无论是在那个文件中，只要引用了对应的使用了显式实例的文件，那么这个显示实例产生的类就是全局可见的，再进行使用时，编译器不会再去进行对应的声明。这样就避免了一个相同的模版类被多次实例化。</p>
<blockquote>
<p>好了，上面耗费的时间有点多了，我们进入下一个具体化</p>
</blockquote>
<h3 id="模版具体化-1"><a href="#模版具体化-1" class="headerlink" title="模版具体化"></a>模版具体化</h3><p>​	很多时候，一个通用的模版其实是不够的，这些模版可能需要存在一些特例，在这些特例中，可能存在着一些与通用模版所不一致的行为，这时就需要使用显式具体化来实现了。通过显式具体化，我们能够定制一系列的在特定模版参数下的模版类。</p>
<p>​	模版具体化，或者说，模版特化允许开发者为特定类型或特定条件提供定制化的实现，从而在保持代码泛化的同时，针对特定情况进行优化或调整。模板特化主要分为两种形式：<strong>全特化</strong>（Full Specialization）和<strong>偏特化</strong>（Partial Specialization）。</p>
<h4 id="1-全特化（Full-Specialization）"><a href="#1-全特化（Full-Specialization）" class="headerlink" title="1. 全特化（Full Specialization）"></a>1. 全特化（Full Specialization）</h4><p>全特化是指为模板的所有参数提供具体的类型或值，从而完全指定模板的行为。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cpp复制编辑<span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通用实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int 类型的全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplate</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 针对 int 类型的特化实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>MyTemplate&lt;int&gt;</code> 是 <code>MyTemplate</code> 的全特化版本，专门为 <code>int</code> 类型提供了特定的实现。</p>
<h4 id="2-偏特化（Partial-Specialization）"><a href="#2-偏特化（Partial-Specialization）" class="headerlink" title="2. 偏特化（Partial Specialization）"></a>2. 偏特化（Partial Specialization）</h4><p>偏特化是指只为模板的部分参数提供具体的类型或值，保留其他参数为泛型。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通用实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个类型为 int 的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplate</span>&lt;<span class="type">int</span>, U&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一个类型为 int 的特化实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个类型为 int 的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplate</span>&lt;T, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第二个类型为 int 的特化实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>MyTemplate&lt;int, U&gt;</code> 和 <code>MyTemplate&lt;T, int&gt;</code> 分别是 <code>MyTemplate</code> 的偏特化版本，针对第一个或第二个类型为 <code>int</code> 的情况提供了特定的实现。</p>
<blockquote>
<p>关于模版的特性还有很多，但是由于我的动力已经在这里消失了，所以我将不会继续这一块，之后哪里遇到了感兴趣的模版的东西再回来更新吧。</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器与部分类回顾</title>
    <url>/2025/02/15/C++%E5%AD%A6%E4%B9%A0/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>​	高精度的加法主要是逐位的加，在大于10时向前进位即可，需要注意的就是需要一开始进行位的补齐，以方便后续的运算。</p>
<p>​	主要就是以下几个要点:</p>
<ul>
<li>对于进行运算的俩个字符串的位进行补齐，统一之后的位计算</li>
<li>对于每个位进行简单加法运算的时候需要注意进位的时机</li>
<li>对于运算后可能的额外位别给忘了</li>
</ul>
<span id="more"></span>

<p>​	在我的实现中，我将进行加法操作的俩个字符串进行了反转来方便后续的递推</p>
<p>​	我的实现如下，简单看看即可，熟练后需要自己来搓了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">precisionPlus</span><span class="params">(string str1,string str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string score;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len1=str<span class="number">1.</span><span class="built_in">size</span>(),len2=str<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(str<span class="number">1.</span><span class="built_in">begin</span>(),str<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(str<span class="number">2.</span><span class="built_in">begin</span>(),str<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//将位给设置为一定能够储存最后结果的情况，统一接下来的操作</span></span><br><span class="line">    <span class="keyword">if</span>(len1==len2)</span><br><span class="line">    &#123;</span><br><span class="line">        str<span class="number">1.</span><span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        str<span class="number">2.</span><span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len1&lt;len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len2-len1;i++)</span><br><span class="line">                str<span class="number">1.</span><span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len1-len2;i++)</span><br><span class="line">                str<span class="number">2.</span><span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max_l=<span class="built_in">max</span>(str<span class="number">1.</span><span class="built_in">size</span>(),str<span class="number">2.</span><span class="built_in">size</span>());</span><br><span class="line">    <span class="type">int</span> bit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max_l;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num1=str1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> num2=str2[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> sumOfNum=num1+num2+bit;</span><br><span class="line"></span><br><span class="line">        score+=(<span class="built_in">to_string</span>(sumOfNum%<span class="number">10</span>));</span><br><span class="line">        bit=sumOfNum/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bit)score+=<span class="built_in">to_string</span>(bit);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(score.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;score.<span class="built_in">back</span>()==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        score.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(score.<span class="built_in">begin</span>(),score.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>System Call</title>
    <url>/2025/03/10/OS/1-syscall/</url>
    <content><![CDATA[<h1 id="系统调用的本质解析"><a href="#系统调用的本质解析" class="headerlink" title="系统调用的本质解析"></a>系统调用的本质解析</h1><h2 id="1-为什么系统调用看起来像过程调用？"><a href="#1-为什么系统调用看起来像过程调用？" class="headerlink" title="1. 为什么系统调用看起来像过程调用？"></a>1. 为什么系统调用看起来像过程调用？</h2><p>在《OSTEP》一书中，提到了一个有趣的问题：为什么系统调用在高级语言层面上看起来像普通的过程调用？</p>
<p>要理解这个问题，需要认识到计算机程序的本质：无论是操作系统（OS）还是用户程序，它们在运行时都是对数据的处理，而数据的处理依赖于 CPU 执行的底层指令。因此，我们可以从 <strong>数据</strong> 和 <strong>指令</strong> 这两个维度来分析系统调用的特殊性。</p>
<hr>
<span id="more"></span>

<h2 id="2-数据与指令的关系"><a href="#2-数据与指令的关系" class="headerlink" title="2. 数据与指令的关系"></a>2. 数据与指令的关系</h2><p>计算机执行任何程序时，都需要处理数据，而数据主要存储在：</p>
<ul>
<li><strong>寄存器</strong>（用于存放临时变量和传递参数）</li>
<li><strong>内存</strong>（用于存放全局变量和堆栈数据）</li>
<li><strong>磁盘</strong>（用于持久化存储）</li>
</ul>
<p>由于寄存器是 CPU 访问速度最快的存储单元，因此无论是内核还是用户程序，都需要利用寄存器进行数据存取。这意味着，<strong>仅通过数据的存储位置（如寄存器或内存）无法区分系统调用与普通过程调用</strong>。</p>
<p>真正的区别在于 <strong>指令的执行权限</strong>。</p>
<hr>
<h2 id="3-为什么普通程序不能直接调用内核代码？"><a href="#3-为什么普通程序不能直接调用内核代码？" class="headerlink" title="3. 为什么普通程序不能直接调用内核代码？"></a>3. 为什么普通程序不能直接调用内核代码？</h2><p>在 CPU 设计中，<strong>用户态代码不能直接执行内核指令</strong>。即使用户程序知道某个内核函数的地址，试图直接跳转过去执行，也会触发 <strong>非法指令异常（General Protection Fault, GPF）</strong>，导致程序崩溃。</p>
<p>这是因为：</p>
<ol>
<li>CPU 通过 <strong>特权级（Privilege Levels）</strong> 限制了用户态程序的执行权限，防止其直接访问关键资源。</li>
<li>OS 设定了 <strong>系统调用表（Syscall Table）</strong>，用户程序只能通过受控的方式进入内核，而不能随意跳转到任意地址。</li>
</ol>
<hr>
<h2 id="4-系统调用的工作原理"><a href="#4-系统调用的工作原理" class="headerlink" title="4. 系统调用的工作原理"></a>4. 系统调用的工作原理</h2><p>尽管系统调用在高级语言中看起来像普通的函数调用，但其底层实现却有所不同。具体过程如下：</p>
<ol>
<li><p><strong>用户程序准备数据</strong></p>
<ul>
<li>按照 OS 规定的 <strong>系统调用参数约定</strong>，将参数存入特定的寄存器（例如，在 x86_64 Linux 下，<code>rax</code> 存 syscall 号，<code>rdi</code>、<code>rsi</code> 等存参数）。</li>
</ul>
</li>
<li><p><strong>执行 <code>syscall</code> 或 <code>int 0x80</code> 指令</strong></p>
<ul>
<li>这条指令会触发<strong>陷阱（trap）</strong>，使 CPU 切换到内核态，并跳转到 OS 设定的<strong>系统调用入口地址</strong>。</li>
</ul>
</li>
<li><p><strong>内核处理请求</strong></p>
<ul>
<li>OS 解析 <code>rax</code> 寄存器中的 <strong>系统调用号</strong>，并在 <strong>系统调用表（Syscall Table）</strong> 中查找对应的内核函数。</li>
</ul>
</li>
<li><p><strong>执行内核代码</strong></p>
<ul>
<li>OS 运行相应的系统调用处理函数（如 <code>sys_write()</code> ），完成请求（如写入文件）。</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>处理完成后，内核将返回值存入 <code>rax</code>，并执行 <code>sysret</code> 指令切换回用户态，恢复用户进程的执行。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-为什么系统调用比普通函数调用复杂？"><a href="#5-为什么系统调用比普通函数调用复杂？" class="headerlink" title="5. 为什么系统调用比普通函数调用复杂？"></a>5. 为什么系统调用比普通函数调用复杂？</h2><p>普通函数调用只是<strong>在相同的权限级别</strong>内执行，并且可以直接访问内存和寄存器。而系统调用则涉及：</p>
<ul>
<li><strong>用户态到内核态的切换</strong>（涉及 CPU 特权级变更）</li>
<li><strong>陷阱表和系统调用表的安全检查</strong>（防止越权访问）</li>
<li><strong>内核的执行环境切换</strong>（如切换页表、保存寄存器状态等）</li>
</ul>
<p>正是由于这些额外的机制，系统调用的<strong>开销比普通函数调用更大</strong>，因此在性能敏感的场景下（如高并发应用）需要尽量减少系统调用的次数。</p>
<hr>
<h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h2><ol>
<li><strong>系统调用看起来像普通的过程调用，但本质上依赖于 <code>syscall</code> 或 <code>int 0x80</code> 触发陷阱机制。</strong></li>
<li><strong>用户程序不能直接调用内核函数，而是通过系统调用号和系统调用表受控访问内核功能。</strong></li>
<li><strong>系统调用涉及用户态到内核态的切换，因此比普通函数调用更复杂，开销也更大。</strong></li>
<li><strong>为了提高效率，现代 OS 使用更高效的 <code>syscall</code> 指令替代传统的 <code>int 0x80</code>，并优化内核路径以减少上下文切换的开销。</strong></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>类模版</title>
    <url>/2025/08/12/C++%E5%AD%A6%E4%B9%A0/%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>本文分析一下在TinyCoro中对于协程遇到的一些问题</p>
<span id="more"></span>

<h2 id="父子关系建立"><a href="#父子关系建立" class="headerlink" title="父子关系建立"></a>父子关系建立</h2><p>​	在C++20所提供的协程中，我们如果想要实现协程的嵌套调用，默认情况下的编写会存在于一种不期望的情况，即，当协程内部co_await的另外一个协程结束的时候，其对应的接下来执行的函数可能比较混乱，其可能是main，也可能是调用协程的协程体内。这本质上是由于对于协程结束时的切换逻辑控制不到位的情况下导致的。</p>
<p>​	想要理解这个，我们需要来分析一下C++的协程锁提供的多个特性中的部分，本次注意力集中到调度点(又或者”暂停点”)。</p>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>​	在协程中，存在多处控制接下来的执行逻辑的地点，理清所有的可能的调度点是我们构建起整个父子关系协程的第一步。</p>
<h4 id="1-协程初始化"><a href="#1-协程初始化" class="headerlink" title="1. 协程初始化"></a>1. 协程初始化</h4><p>​	当在代码中编写代码调用一个协程函数时，实际上编译器会将一次简单的代码调用翻译成一系列的逻辑流，关于这部分的分析很多教程中都有解释，在此处我们关注与实际的程序执行流的流动。</p>
<p>​	<img src="/2025/08/12/C++%E5%AD%A6%E4%B9%A0/%E5%8D%8F%E7%A8%8B/协程.png" alt="协程" style="zoom:80%;"></p>
<p>​	在协程初始化时，我们的关注点在于initial_suspend的返回值中，此处的返回值决定接下来所需要执行的流程，实际上，在一个协程的initial_suspend实现中，一般只可能是suspend_always和suspend_never俩者二选一。即，考虑是先挂起协程不执行协程体还是立即执行协程体。在本次的lab中，所有的协程的initial_suspend都应该为suspend_always,这是由于我们需要由执行引擎本身去调度，以及等下会看到的另外一个用处。</p>
<ul>
<li>顶层协程首次启动，由于initial_suspend返回值始终使得协程暂停，可以使得在创建出对象之后进行一系列的操作，对于顶层协程，其需要注册到执行引擎中，由执行引擎来监控其中的一系列状态</li>
<li>内部嵌套协程首次启动，当内部嵌套协程初始化时，如果我们不加以暂停，其可能会直接开始执行甚至于到协程体结束，如果此时我们没有绑定该协程的上下文，那么可以说该协程执行完毕之后的下一次调度将会是随机的(实际上，如果你对于自己编写的程序很了解，你可以猜到该协程结束后的栈帧是谁，但是这种需要靠”猜”的行为对于我们的框架来说就是随机的)。</li>
</ul>
<p>​	我们接下来可以看到这里的暂停在上下文关系建立中的必要性。</p>
<h4 id="2-协程开始执行"><a href="#2-协程开始执行" class="headerlink" title="2.协程开始执行"></a>2.协程开始执行</h4><p>​	现在我们先抛弃执行引擎是如何启动的，我们现在假设顶层协程在完成一系列操作之后已经被resume。即，当对应的initial_suspend以及注册初始化之后，开始了协程体的内容执行。最简单的demo如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Task <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;func2 step1\n&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">co_await</span> <span class="title">suspend_never</span><span class="params">()</span></span>;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;func2 step1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;func1 step1\n&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">co_await</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;func1 step1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">fun1</span>();</span><br><span class="line">    <span class="comment">//...... maybe some action to save the info</span></span><br><span class="line">    task.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	初始，由于fun1的initial_suspend返回值阻塞了协程执行，所以执行流回到了main，此时main就相当于一个最基础的调度核心，我们需要去启动注册进来的协程，此处即是最基本的resume。当我们执行完<code>task.resume();</code>之后，fun1的协程体会开始执行，此时会打印<code>func1 step1</code>，接着其运行到了第一个暂停点，即<code>co_await fun2();</code></p>
<p>​	这里的co_await一个协程的实际语义相对有点意思。对于一个co_await关键字，其所需要的是一个await对象。一般来说，对于一个协程，其会存在一个co_await重载来提供该对象，而该重载函数一般不会是一个静态方法，否则其的局限性会很大。对于一个非静态方法的重载运算符，我们要使用的前提无论如何都是先具有对应的实际的对象，所在在这里，其也会先跑一趟对应的协程对象初始化。前面说过，由于我们的协程初始化中initial_suspend始终返回的是suspend_always，所以始终不会先执行对应的函数体。这是由于我们需要在正式执行逻辑之前绑定信息，上面已经提到，此时我们来看到内部的co_await的部分实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">awaitable_base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">awaitable_base</span>(coroutine_handle coroutine) <span class="keyword">noexcept</span> : <span class="built_in">m_coroutine</span>(coroutine) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> -&gt; <span class="type">bool</span> </span>&#123; <span class="keyword">return</span> !m_coroutine || m_coroutine.<span class="built_in">done</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; awaiting_coroutine)</span> <span class="keyword">noexcept</span> -&gt; std::coroutine_handle&lt;&gt;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定本身所在的协程句柄的父协程句柄</span></span><br><span class="line">        m_coroutine.<span class="built_in">promise</span>().<span class="built_in">setFaHandle</span>(awaiting_coroutine);</span><br><span class="line">        <span class="keyword">return</span> m_coroutine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; m_coroutine&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span> <span class="type">const</span>&amp; <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">awaitable</span> : <span class="keyword">public</span> awaitable_base</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">auto</span> <span class="title">await_resume</span><span class="params">()</span> -&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_coroutine.<span class="built_in">promise</span>().<span class="built_in">result</span>(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> awaitable&#123;m_coroutine&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	此处可以看到几个比较有意思的点，其一是对应的awaitable_base实现，对应的实现中存在了一个m_coroutine句柄，该句柄实际上即为本个await对象所属的promise对象的句柄，通过该句柄，我们能够实现在await_suspend中的执行流调度，使得其能够在结束时resume一次本协程的暂停点。再结合前文中的<code>co_await fun2();</code>，我们可以发现其能够推迟一个co_await的协程体的执行直到await_suspend执行完毕。</p>
<p>​	同时，注意点转到await_suspend的内容中，我们可以看到其中存在了一些其他的内容，如其中所示，其进行了将参数的句柄绑定到本协程句柄的属性中去，对应的作用如注释所示，绑定了本个协程的父协程(即最近一次的外部协程)。这样，我们实现了一种协程体执行的推迟，但是同时使得协程体始终在co_await这一句执行完毕之前能够开始执行一次。同时，其还能够实现一些成员属性的绑定，这是相当重要的，其是关于如何实现上下文正确调度的核心，需要着重理解。</p>
<h4 id="3-协程执行结束"><a href="#3-协程执行结束" class="headerlink" title="3.协程执行结束"></a>3.协程执行结束</h4><p>​	此处我们省略大部分的场景，着重于一个特殊的场景，即，当一个子协程结束时，程序接下来的操作会是如何。</p>
<p>​	在C++中，当一个协程结束时，省略其他return_<em>的分析的话，着重点就在于final_suspend了，该函数是C++中规定的协程的另外一个调度点，其的返回值也是一个await对象，此对象也承担起了调度的作用，其中的await_suspend也能够达到跳转执行流的作用。在此次lab中，我们的期望是在一个协程执行完毕之后能够转回到对应的父协程中去进行。注意时机，是在<strong>协程执行完毕之后</strong>，以及目的，*<em>调度回父协程</em></em>(如果存在)。因此，final_suspend的目标自然就很明确，就是正确的调度回对应的父节点。而这需要通过await对象来实现。</p>
<p>​	考虑前文所说的co_await时的逻辑，此时的promise中已经保存了本协程的父协程的句柄，所以此处我们所需要实现的就只是返回值的合理构造，实现起来很简单，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">final_awaitable</span>&#123;</span><br><span class="line">        std::coroutine_handle&lt;&gt; fa_handle_;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span><span class="keyword">noexcept</span></span>&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">        std::coroutine_handle&lt;&gt; <span class="built_in">await_suspend</span>(std::coroutine_handle&lt;&gt;)<span class="type">const</span> <span class="keyword">noexcept</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fa_handle_)&#123;</span><br><span class="line">                <span class="keyword">return</span> fa_handle_;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">noop_coroutine</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span></span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> final_awaitable&#123;fa_handle_&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	实际上可能存在多种实现，就比如不使用这里的fa_handle_成员，而是使用await_suspend的参数来进行额外的操作，不过本质上都与此处的逻辑相同。理解这里的本质逻辑即可。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>TinyCoro及杂谈</title>
    <url>/2025/10/08/OS/3-LSM/</url>
    <content><![CDATA[<h1 id="TinyCoro-Lab2"><a href="#TinyCoro-Lab2" class="headerlink" title="TinyCoro Lab2"></a>TinyCoro Lab2</h1><p>在本节中，我们将根据对应的TinyCoro的Lab2的内容来进行一次对应的LSM的熟悉以及各方面的一次总结还有我在本次Lab2中获取到的感悟。</p>
<span id="more"></span>

<h2 id="协程生命周期管理"><a href="#协程生命周期管理" class="headerlink" title="协程生命周期管理"></a>协程生命周期管理</h2><p>​	在本次Lab2中，我遇到了一个难题，”需要怎么来理解engine，context组件对于协程生命周期的管理”。该问题是主导我们如何实现后续的各个逻辑的核心。其的回答将会影响我们来如何设计engine对于协程任务的推进，如何设计context如何驱动engine推进所有的协程Task。</p>
<p>​	在开始之前，我们需要先来对于一些现有层次进行抽象以及隔离。首先，对于当前的实现来说，<strong>engine</strong>在逻辑上的地位是一把”武器”，通过它，我们能够驱动一个或多个协程任务的执行流的执行。但是，其本身并不知道如何使用其所拥有的性质，也就是其不知道如何来驱动一个协程的运行，其所能够实现的，是对于各个基本的逻辑单元，就比如协程各个状态之间的转化的桥梁的建模。我们能够通过它来驱动一些关键流程的前进。</p>
<p>​	其次，context就是上文中提到的”我们”。如果将engine类比为”武器”，那么context就是士兵。context能够利用”武器”去实现一系列的行为，在这里，所谓的行为包括但不限于驱动一个协程从提交到退出的整个行为等。所以，其相对于engine来说是一种调度者的角色，负责调度我们何时应该驱动engine执行什么行为，以及需要做什么来维护整个逻辑链条并不出错。</p>
<h3 id="Engine简略"><a href="#Engine简略" class="headerlink" title="Engine简略"></a>Engine简略</h3><p>​	对于Engine来说，其最核心的任务为驱动协程计算任务以及IO任务。在协程中，所谓的计算任务本质上就是对于一个已准备就绪的协程进行resume，然后其会自动跑在CPU的栈帧中进行计算；而对于IO任务，协程需要提交给Engine，由Engine本身来帮忙推进IO任务并在完成之后通过协程就绪。</p>
<p>​	此时我们可以给Engine的功能下一个粗略但够用的定义，通过对于Engine的api调用，我们能够驱动提交给Engine的协程的运行。因为一个协程本质上就是由一系列计算任务和IO任务形成的，所以通过合适的调用对应的api，我们就能够推动对应的已经投递到Engine内的协程任务的执行。我们下面给出几个实际上实现的api所提供的抽象。</p>
<ul>
<li><strong>submit_task</strong> Engine暴露给外部的往内部提交一个任务的接口</li>
<li><strong>exec_one_task</strong> 驱动Engine执行其协程就绪队列中下一个任务的计算任务执行</li>
<li><strong>poll_submit</strong> 驱动Engine执行IO任务，一次调用会驱动Engine进行一次内部的IO事件检测，包括提交待提交的IO，处理已完成的IO。需要注意，一次poll_submit的调用实际上可能会产出一些新的Task，这点特别需要注意。</li>
</ul>
<p>​	上诉三个api即为Engine的核心api，除此之外还存在一系列的重要的api。接下来在对于Context如何与Engine交互中会逐渐提及。下面给出其中最重要的poll_submit的实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">engine::poll_submit</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TODO[lab2a]: Add you codes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、提交当前存在的IO</span></span><br><span class="line">    <span class="built_in">do_io_submit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、等待已经完成的IO，需要注意，实际上可能不存在完成的IO</span></span><br><span class="line">    <span class="comment">// 需要配合对应的代理类中的eventfd来判断阻塞判断</span></span><br><span class="line">    <span class="comment">// 阻塞判断能够使得线程可以让出CPU，但是需要考虑如何使得唤醒条件确实为存在IO事件完成</span></span><br><span class="line">    <span class="keyword">auto</span> ret = m_upxy.<span class="built_in">wait_eventfd</span>();</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">wake_by_cqe</span>(ret))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、处理已经完成的IO</span></span><br><span class="line">    <span class="keyword">auto</span> num = m_upxy.<span class="built_in">peek_batch_cqe</span>(m_urc.<span class="built_in">data</span>(), m_running_io.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            <span class="built_in">handle_cqe_entry</span>(m_urc[i]);</span><br><span class="line">            m_urc[i]=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_upxy.<span class="built_in">cq_advance</span>(num);</span><br><span class="line">        m_running_io.<span class="built_in">fetch_sub</span>(num,std::memory_order_acq_rel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Context核心"><a href="#Context核心" class="headerlink" title="Context核心"></a>Context核心</h2><p>​	对于Context来说，其核心任务在于如何巧妙组合Engine中的api来驱动协程任务的完整推进，同时保证不丢失任何一个协程任务。我们本次的分析核心就在于Context这里的核心任务，在当前的设计中，我们通过Context的一个核心api来封装了整个流程，所以我们接下来的分析重点会集中在对于该api实现的思路以及对应的逻辑上。</p>
<p>​	下面给出实际的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">context::run</span><span class="params">(stop_token token)</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!token.<span class="built_in">stop_requested</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 处理 IO 完成（可能生成新的 runnable 协程）</span></span><br><span class="line">        m_engine.<span class="built_in">poll_submit</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Drain 所有就绪任务</span></span><br><span class="line">        <span class="keyword">while</span> (m_engine.<span class="built_in">ready</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_engine.<span class="built_in">exec_one_task</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 整个生命周期覆盖，如果为false，自然退出</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">empty_wait_task</span>())&#123;</span><br><span class="line">            <span class="built_in">m_stop_cb</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 防止空转占满 CPU，可后续替换为自适应 backoff</span></span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该api的逻辑实际上很简洁。首先是驱动Engine处理器所持有的IO事件，然后推进协程计算任务的进行，最后判断当前Context是否已经已经满足退出条件或者休眠等其他状态，并执行不同的逻辑。看起来很简单。但是，实际上会存在很多的细节需要处理。而这些细节的核心围绕着一点，<strong>如何来正确的维护一个协程任务的声明周期</strong>。</p>
<p>我们首先来给出结果基础的抽象层级，对应的<strong>empty_wait_task</strong>判断当前的Context是否满足退出条件，对应的<strong>m_stop_cb</strong>为当一个<strong>Context</strong>退出时的资源清理逻辑。同时我们来说明当前期望的context退出逻辑，当对应的context投递的所有的协程任务都执行完毕之后才能够退出。所以其中退出的核心条件为如何判断当前的context中确实已经完全执行完毕对应的任务。</p>
<p>为了避免文字描述上的抽象，对于这种生命周期的管理，我们需要来使用一种更加形象的语言来描述，这里选择使用FSM来对于一个协程的生命周期进行描述。</p>
<h2 id="协程生命周期"><a href="#协程生命周期" class="headerlink" title="协程生命周期"></a>协程生命周期</h2><p><img src="/2025/10/08/OS/3-LSM/image-20251008210755342.png" alt="协程生命周期FSM"></p>
<p>​	在本次的设计中，我将一个协程在程序中的流转是所位于的状态定义为了三种，分别为”Ready”,”Running”,”Suspend”。</p>
<ul>
<li>“Ready”代表着协程此时已经准备就绪，能够通过一次resume来跨越上一次导致阻塞的调度点。</li>
<li>“Running”代表协程此时正在CPU上执行计算任务</li>
<li>“Suspend”代表协程此时已经阻塞，正在等待某个条件满足，在本次的Lab代码中，这个条件一般就是某次IO操作的完成</li>
</ul>
<p>​	此时，我们将整个协程的声明周期划分为了这三者，为了来验证当前的实现中是否已经能够完整的管理协程的生命周期，我们需要来分析一遍整个Engine和Context中对于整个生命周期的覆盖和管理情况。</p>
<p>​	首先我们需要来看到其中的退出条件，你需要理解为什么退出条件实际上是对应的判断协程的生命周期是否被完整的管理的关键。下面是当前context中对于退出条件的检测。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">context::empty_wait_task</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; <span class="type">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_ref_cnt.<span class="built_in">load</span>(std::memory_order_acquire) == <span class="number">0</span> </span><br><span class="line">    		&amp;&amp; m_engine.<span class="built_in">ready</span>() == <span class="literal">false</span> &amp;&amp; m_engine.<span class="built_in">empty_io</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出其中几个变量在代码中的建模含义</p>
<ul>
<li><strong>m_ref_cnt</strong>			当前context中处于Suspend态的协程的数量</li>
<li><strong>m_engine.ready()</strong>          当前engine中处于Ready态的协程的数量</li>
<li><strong>m_engine.empty_io()</strong>    当前engine是否残留未处理的IO事件(待提交IO以及已完成未处理IO)</li>
</ul>
<p>接下来我们来看这几个变量如何能够来涵盖整个生命周期管理的，分析对应的代表含义以及为什么需要存在。我们将从现有的engine和context对于生命周期的覆盖入手，来建模各个变量。</p>
<h4 id="Engine覆盖的生命周期"><a href="#Engine覆盖的生命周期" class="headerlink" title="Engine覆盖的生命周期"></a><strong>Engine覆盖的生命周期</strong></h4><p>​	在Engine中，我们存在多个成员，包括如下几个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mpmc_queue&lt;coroutine_handle&lt;&gt;&gt; m_task_queue; </span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; m_wait_submit_io;       </span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; m_running_io;          </span><br></pre></td></tr></table></figure>

<p>其中的各个成员在逻辑上其实就是一个协程在某个特定阶段下的代表，从观察者角度来看的话，实际上这些成员统计的是出于某个特定状态下的协程的数量。</p>
<p><strong>m_task_queue</strong>成员的作用是储存当前已经就绪了的协程句柄并提供用于后续的resume操作的对象。所以其的was_size()成员属性反映的实际上就是当前处于<strong>Ready</strong>态的协程数量。<strong>m_wait_submit_io</strong>反映的是当前的Engine中等待被io_uring接受的IO事件，m_running_io反映的是当前Engine中已经完成，但是还没有被处理的IO事件。这俩者共同反映了在一个协程进入Suspend态后的内部状态转移。对于外部来说，通过这俩个状态，我们就能够观察当前位于Suspend态的协程数量。</p>
<p>综上，通过对于这些成员的统计，我们能够观察到位于Engine中，位于一些特定状态下的数量。包括了我们上面所提到的”Ready”态和”Suspend”态。</p>
<p>由此，我们根据这种状态的统计生成了俩个api，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">engine::empty_io</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; <span class="type">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !m_wait_submit_io&amp;&amp;!m_running_io;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">engine::ready</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; <span class="type">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !m_task_queue.<span class="built_in">was_empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对于这俩个api的调用，我们能够观察到当前执行引擎中的部分协程，但是由于我们还还没有涵盖整个生命周期，所以还是会存在一些遗漏的协程。如果我们只根据上面这俩个api就进行对应的退出判断。势必会导致部分协程被遗漏，甚至于导致内存泄漏以及UB行为。所以我们需要在一些其他地方进行对应的补偿。在TinyCoro中，即是通过<strong>Context</strong>来对于协程的监控进行补偿。</p>
<h4 id="Context覆盖的声明周期"><a href="#Context覆盖的声明周期" class="headerlink" title="Context覆盖的声明周期"></a>Context覆盖的声明周期</h4><p>​	如果你对于生命周期的管理足够敏感，你应该能够注意到，在上面Engine中，所观测到的实际上只是切实的位于对应的”Ready”态和”Suspend”态中的协程，那么，对于那些位于状态转换中的协程呢，对应的是否有能够正确的统计到，或者说，当前的是否能够成功的补偿到这一部分的统计。这是你所需要思考的内容。接下来我们进入Context是如何对于前文中遗漏的协程生命周期监控进行补偿的。</p>
<p>​	我们需要回过头来看到Context‘中的核心函数**”run”**。在这个函数中，我们可以看到一个比较有趣的实现，如果你足够敏感，你应该能够观察到这里实际上覆盖了一个状态，就是对应的”Running”态。在”run”中的第二步实际上是一种在本循环内执行所有Running态协程的行为。通过在本循环内执行该函数，我们能够提供一种保证，在对应的声明周期管理中，所有的”Running”态协程都能够被正确的执行，统计，以及转移。其中存在一个有趣的点，就是其是如何保证对应的涉及到”Running”态的转移能够不被遗漏的，你可能需要阅读engine和context的实现来理解。</p>
<p>​	好，接下来我们先来进行一次阶段性的总结，在当前的分析中，我们看到了Engine统计了位于”Ready”态和”Suspend”态的协程数量，而Context通过在核心流程上包裹对应的”Running”态协程实现了对应的位于”Running”态和处于涉及到”Running”态的俩条状态转移路线的监控。回顾一下我们前面的<strong>协程生命周期FSM图</strong>。在该图中，我们还缺乏一条关键路径没有统计，就是对应的”Suspend”态向”Ready”态的状态转移。为了完善对于协程的统计来实现安全的退出，我们势必需要完善对应这条路径上的协程数量的监控，为此，我们需要分析到底什么时候会触发这条路径以及我们如何来监控这条路径。</p>
<p>​	下面给出一个可能的并发竞态流程</p>
<p><img src="/2025/10/08/OS/3-LSM/image-20251008220145138.png" alt="错漏协程场景"></p>
<p>​	上图清晰的给出了如果我们没有对于该流程进行对应的监控时可能出现的统计的问题。在当前的设计中，一个Suspend态往对应的Ready态的转换并不是原子的，其涉及到取出sqe中的信息，解析其中的结构，调用其中的元信息并将其重新注入到就绪队列中，要是整体的监控流程监控到的**”2”**下的快照，那么其会认为当前任务已经结束，其会尝试停止对应的Context，但是实际上我们仍然存在一个正在搬运过程中的协程句柄，如果这次Context的停止导致了整体的Context的销毁，那么会导致对应的状态转移的终点将会导致一种未知的场景，也就是UB，即使幸运的，这次并没有进行对应的销毁，重新成功注入了队列中完成了状态的转移。但是这种语义是我们想要的吗？我们必须将并发以最坏的场景进行构想，所以我们必须监控这个流程中的协程数量。</p>
<p>​	为此，我们引入了一个引用计数的概念。我们尝试将这个流程中的协程使用一个引用计数留下一个钩子，只要存在这个钩子的值非0，Context就能够知道当前仍然存在一个状态转移中的协程，那么其就不会尝试进行自毁。如果我们能够更加的对于这种钩子进行精确的统计，那么我们就能够更好的使得Context感知当前的工作协程，并避免误判导致的各种UB。具体的更加详细的分析，你需要自己来进行分析以及理解。</p>
<p>​	接下来我们来分析我们应该如何来设计这种钩子。期望中的钩子自然是在对应的这条状态转移路径上的增减时进行统计，但是实际上这是很难做到的，可以自己考虑一下如何实现。在本次设计中，我们考虑扩大对应的钩子范围，我们在一个协程即将进入对应的”Suspend”态时就进行Context对于位于该路径上的协程数的++，在一个协程已经从”Suspend”态转移到“Ready”态后，就将对应的钩子数–。通过使用这种粗粒度的引用计数的统计，我们成功实现了对于该状态转移路径上的协程数量的钩子统计，并成功取得了想要的效果。而且这种对于外部的心智负担并不大，这受益于C++中的协程实现，其中的对于一个协程运行阶段的各种拆分允许我们在特定对应阶段进行一定的逻辑的注入，你可以分析一下我们实际上需要在哪里进行对应的引用计数的修改。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	对于本次Lab，其中最令人痛苦以及着迷的是我们到底需要如何来正确管理对应的协程的生命周期来使得能够正确的统计协程来使得Engine和Context能够真正的在任务执行完毕之后进行退出，不由于错漏而早退导致UB。而为了能够分析当前到底实现了什么功能，一个FSM建模对于生命周期这种模型来说是十分吻合的，特别就如这里，我们通过将一个协程的生命周期建模为一系列的状态以及状态间转移，再在这些状态和中间状态进行监控，我们实现了对于整体的持有协程数量的监控。这种使用建模来解析复杂模型的思路不失为一种好的方法。</p>
<p>​	实际上，在很多其他方面也能够看到FSM的身影，特别是在网络这方面。对于网络中的可靠网络传输等，由于设计到一系列复杂的实现，单纯使用文字俩描述是很麻烦且难以理解的，此时一个FSM就是”一图胜千言”。我们能够通过对于FSM的观察来分析当前的实现中涵盖了哪些重要的状态节点以及状态路径。是否存在错漏的路径，以及是否存在隐含的路径等待我们来发现以及建模等等。总而言之，当遇到一些难以分析的问题时。不妨尝试先分析出该问题的本质，然后尝试对于这个本质进行对应的状态机的建模。就比如我们上文为了解决这个Lab2的优雅退出对于整个协程生命周期的建模一样，只要我们实际上的FSM确实能够涵盖整体的流程，然后依照这个状态机进行实现，那么总归能够找到破题的思路。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Paging</title>
    <url>/2025/03/12/OS/2-paging/</url>
    <content><![CDATA[<h1 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h1><p>​	此篇是在我在OSTEP中看到内存虚拟化分页这一章时所遇到的。需要注意的是，此篇写时我还有点感冒后遗症，脑袋不大清晰，有些地方逻辑会存在混乱，谅解吧。</p>
<span id="more"></span>

<blockquote>
<p>​	在看到这篇时，我立刻就回想到了CSAPP中的关于虚拟内存这一块的内容，对比俩本教材，可以明显看到俩种不同的风格，OSTEP是一种很温和的态度来引导你来进行学习，而CSAPP在这时已经进入中间阶段了，一些概念开始成堆的出现了，这个会在一定程度上不利于对于这部分的理解。</p>
</blockquote>
<p>​	</p>
<h2 id="分页机制与内存管理"><a href="#分页机制与内存管理" class="headerlink" title="分页机制与内存管理"></a>分页机制与内存管理</h2><p>在操作系统的内存管理中，相较于使用分段（Segmentation）作为基本单位，分页（Paging）具有显著的优势。尽管分段可以提供更高的内存管理粒度，但其可变大小的特性导致较高的管理开销。例如，动态分配和回收不同大小的段会引入外部碎片问题，并增加管理的复杂度。因此，分页作为一种固定大小的管理方式，更适合作为内存管理的基本单位。</p>
<h3 id="分页的基本概念"><a href="#分页的基本概念" class="headerlink" title="分页的基本概念"></a>分页的基本概念</h3><p>在内存虚拟化过程中，我们希望将内存抽象为一系列可供管理的结构。除了可变大小的段之外，另一种方式是使用固定大小的页（Page）。</p>
<p>分页的核心思想是将整个内存空间划分为大小固定的页，以便进行高效的管理。这种方式具有以下优点：</p>
<ul>
<li>避免外部碎片问题。</li>
<li>提供灵活的内存分配策略。</li>
<li>便于地址映射和内存保护。</li>
</ul>
<p>在分页体系中，存在<strong>虚拟页（Virtual Page）</strong>和<strong>物理页（Physical Page）</strong>两种概念。</p>
<ul>
<li><strong>物理页</strong>：实际存储在RAM或磁盘上的内存块。</li>
<li><strong>虚拟页</strong>：处于虚拟地址空间中的页，作为进程可见的逻辑地址单元。</li>
</ul>
<p>操作系统的任务是维护虚拟页与物理页之间的映射关系，从而实现高效的内存管理。</p>
<h3 id="虚拟页到物理页的映射"><a href="#虚拟页到物理页的映射" class="headerlink" title="虚拟页到物理页的映射"></a>虚拟页到物理页的映射</h3><p>假设操作系统管理一个64KB的存储空间，并且页大小为16KB，则该存储空间可以划分为4个页框（Frame）。在虚拟内存视角下，这些页框可以被组织成一个页表（Page Table），用于存储页的映射信息。</p>
<p>然而，计算机通常需要同时运行多个进程，每个进程都会拥有独立的虚拟地址空间。这意味着：</p>
<ol>
<li>不同进程的虚拟地址空间在逻辑上是隔离的。</li>
<li>但在物理内存中，这些进程的页可能是分散存放的，而不是连续的。</li>
</ol>
<p>由于物理内存的分配通常是动态的，虚拟页和物理页之间的映射关系并不是固定的。如果直接按照虚拟地址的顺序映射到物理地址，不仅效率低下，还会限制灵活性。因此，我们需要一种机制来管理这种映射关系，使虚拟地址空间能够高效地映射到物理地址空间。</p>
<hr>
<p>​	</p>
<p>​	对于一个操作系统（OS）来说，分页相较于分段在内存管理上有其独特的优势。虽然分段能提供更灵活的内存管理，但由于其可变大小的特性，管理上的开销较大。而分页则采用固定大小的内存块，使得管理更加高效。因此，我们重点关注分页机制。</p>
<h2 id="为什么要分页？"><a href="#为什么要分页？" class="headerlink" title="为什么要分页？"></a>为什么要分页？</h2><p>在操作系统的内存管理中，我们希望将内存抽象成可管理的单元。除了分段这种可变大小的划分方式，还有一种固定大小的划分方式——<strong>页（Page）</strong>。页的大小固定，使得整个内存管理更加整齐，减少了碎片化问题，并且让映射管理变得更简单。</p>
<p>在分页系统中，我们主要关注两种页：</p>
<ul>
<li><strong>虚拟页（Virtual Page）</strong>：进程视角下的逻辑页，操作系统为每个进程维护的抽象地址空间。</li>
<li><strong>物理页（Physical Page）</strong>：实际存储在RAM或磁盘中的内存块，真正承载数据。</li>
</ul>
<p>但问题来了，如何把一个虚拟页转换到物理页？换句话说，我们如何建立二者之间的映射？</p>
<hr>
<h2 id="虚拟地址-vs-物理地址"><a href="#虚拟地址-vs-物理地址" class="headerlink" title="虚拟地址 vs 物理地址"></a>虚拟地址 vs 物理地址</h2><p>在计算机系统中，我们经常会听到<strong>虚拟地址</strong>（Virtual Address）和<strong>物理地址</strong>（Physical Address）这两个概念。</p>
<ul>
<li><strong>虚拟地址</strong>：进程使用的地址，提供了一层抽象，使得进程能够独立于物理内存进行访问。例如，在C语言中，使用指针访问变量时，实际上使用的就是虚拟地址。</li>
<li><strong>物理地址</strong>：数据在硬件中的实际存储地址，是最终被CPU访问的位置。</li>
</ul>
<p>为了理解它们之间的关系，我们举个例子：</p>
<p>假设一个操作系统管理着64KB的内存，每个页的大小是16KB。这样，总共可以划分出4个页槽位（64KB &#x2F; 16KB &#x3D; 4）。在进程的虚拟地址空间中，这些页是连续编号的，但在实际的物理内存中，它们的存放位置可能是离散的。因此，我们需要一种机制来建立映射。</p>
<hr>
<h2 id="虚拟地址的结构"><a href="#虚拟地址的结构" class="headerlink" title="虚拟地址的结构"></a>虚拟地址的结构</h2><p>为了精准地描述一个数据在进程地址空间中的位置，虚拟地址通常由两部分组成：</p>
<ol>
<li><strong>页索引（Page Index）</strong>：用于标识数据所在的虚拟页。</li>
<li><strong>页内偏移（Offset）</strong>：用于定位数据在该页中的具体位置。</li>
</ol>
<p>实际上，物理地址的结构也类似，同样由<strong>物理页索引</strong>和<strong>页内偏移</strong>构成。由于虚拟页和物理页的大小是相同的，<strong>页内偏移部分可以直接复用</strong>，这让地址转换的计算更加简单。</p>
<p>所以，<strong>虚拟地址到物理地址的转换，关键在于虚拟页索引到物理页索引的映射，而页内偏移部分保持不变</strong>。</p>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>分页机制的核心思想是：</p>
<ul>
<li>通过固定大小的页管理内存，使得内存分配更加高效。</li>
<li>虚拟地址由<strong>页索引</strong>和<strong>页内偏移</strong>组成，物理地址的结构类似。</li>
<li><strong>虚拟地址到物理地址的转换，主要依赖页索引之间的映射，而页内偏移保持不变</strong>。</li>
</ul>
<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a><strong>页表</strong></h2><p>在之前的内容中，我们已经初步了解了<strong>虚拟地址到物理地址转换</strong>的动机。现在，我们来看看操作系统如何<strong>管理</strong>这种转换的一种重要机制：<strong>页表（Page Table）</strong>。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>页表的主要作用是<strong>提供虚拟地址到物理地址的映射</strong>。在分页机制中，虚拟地址被划分为<strong>虚拟页号（VPN, Virtual Page Number）**和**页内偏移量**，而物理地址则由</strong>物理页号（PPN, Physical Page Number）**和相同的偏移量组成。因此，页表的核心功能是**将虚拟页号映射到物理页号**。</p>
<h3 id="页表项（Page-Table-Entry-PTE）"><a href="#页表项（Page-Table-Entry-PTE）" class="headerlink" title="页表项（Page Table Entry, PTE）"></a><strong>页表项（Page Table Entry, PTE）</strong></h3><p>页表中的每一个<strong>页表项（PTE）</strong>，需要满足以下基本要求：</p>
<ul>
<li><strong>能够通过虚拟页号索引到正确的页表项</strong></li>
<li><strong>在索引到页表项后，能够获取对应的物理页号</strong></li>
</ul>
<p>除此之外，页表项通常包含一些额外的<strong>控制位</strong>，用于管理页面的访问权限和状态：</p>
<ul>
<li><strong>有效位（Valid Bit）</strong>：判断该页是否在主存中，若无效，则需要触发<strong>缺页异常（Page Fault）</strong>并从磁盘加载该页。</li>
<li><strong>读&#x2F;写&#x2F;执行权限位</strong>：限制对该页的访问权限，如只读、可写、可执行等。</li>
<li><strong>缓存控制位</strong>：决定该页是否允许被 CPU 缓存，用于管理 I&#x2F;O 设备映射等。</li>
<li><strong>脏位（Dirty Bit）</strong>：指示该页是否被修改过，若为1，则需要在换出时写回磁盘。</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>DB环境构建</title>
    <url>/2025/02/15/java/1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="数据库环境构建"><a href="#数据库环境构建" class="headerlink" title="数据库环境构建"></a>数据库环境构建</h1><p>​	对于一个普通的java项目，想要实现对于数据库操作的支持，及连接数据库以及对于数据库的增删查改等。需要一下几个操作(可能存在的操作)</p>
<p>​	<span id="more"></span></p>
<ol>
<li><strong>安装数据库jdk依赖</strong></li>
</ol>
<p>​	以mysql为例，一个项目需要先安装对应的环境依赖包，该包一般需要额外安装，以下是一个可能的下载网址 <a href="https://dev.mysql.com/downloads/connector/j/">依赖下载</a>。</p>
<p><img src="/2025/02/15/java/1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/image-20250313110757287.png" alt="image-20250313110757287"></p>
<p>​	需要先选择自己当前的OS环境，个人电脑开发的话选择Platform Independent即可。再在接下来的列表中选择一个合适的包下载即可。</p>
<p>​	下载完后是一个压缩包，下载完寻找一个合适的位置解压缩即可。</p>
<ol start="2">
<li><strong>导入java项目</strong></li>
</ol>
<p>​	右键目标项目-&gt;打开模块设置(F4)-&gt;模块(model)-&gt;依赖(dependent)-&gt;”+”-&gt;导入解压后的文件夹-&gt;点击选择</p>
<p>​	此时应该存在一个新的包而且其就是我们下载的压缩包解压后的文件。</p>
<p><img src="/2025/02/15/java/1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/image-20250313111416507.png" alt="image-20250313111416507"></p>
<ol start="3">
<li><p><strong>测试demo</strong></p>
<p>有了上诉步骤后，一个java项目的数据库环境已经搭建完毕。接下来来看一个简单的demo。</p>
<p>需要注意的是，我默认你这里的电脑环境中已经存在着一个或多个数据库而且你的数据库服务已经被启动了。如果没有，可以单独去看电脑环境中对于数据库环境的搭建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 数据库连接信息（需替换为你自己的配置）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/******&quot;</span>;		<span class="comment">//改为自己选定的数据库</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;*****&quot;</span>;				<span class="comment">//改为自己的数据库账号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;********&quot;</span>;		<span class="comment">//改为自己的数据库密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1. 建立连接</span></span><br><span class="line">                <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">                <span class="comment">// 2. 创建 Statement 对象</span></span><br><span class="line">                <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据库连接成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;数据库连接失败！错误信息:&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	以下是运行结果</p>
<p><img src="/2025/02/15/java/1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/image-20250313111921507.png" alt="image-20250313111921507"></p>
</li>
</ol>
<p>​	好，这个环境搭建完毕，有兴趣的可以去研究下使用build工具来自动化搭建环境，我也还没看捏。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>QT布局</title>
    <url>/2024/12/27/QT%E6%8E%A7%E4%BB%B6/3-QT%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="QT布局"><a href="#QT布局" class="headerlink" title="QT布局"></a>QT布局</h1><p>​	QT中的大部分都是都是api，基本只要只要这东西的基本功能，再去用个几次，就能够比较熟练的运用了。至于布局，QT中的布局中存在三种方式，<strong>水平布局，垂直布局，栅格布局</strong>。</p>
<p>​	<span id="more"></span></p>
<h2 id="UI设置"><a href="#UI设置" class="headerlink" title="UI设置"></a>UI设置</h2><h3 id="布局控件"><a href="#布局控件" class="headerlink" title="布局控件"></a>布局控件</h3><p>​	如其他大部分的图形化控件一样，布局这种在UI设计师文件中也直接给集成好了，我们可以直接去拖动进行使用。而且一般来说吧，布局这种东西也一般只会在设计师文件中进行使用，需要使用代码去进行设计的情况其实不多，毕竟不好直观的控制它。</p>
<p>​	对于这些个控件的介绍，其实没什么好说的，只要是会用就行，所以我们这里主要来讲几个控件的使用。</p>
<p>​	首先，QT中ui文件的侧边栏中就可以找到我们所有的可以使用的控件，在这些个控件中，布局属于Layouts一栏中。</p>
<p><img src="/2024/12/27/QT%E6%8E%A7%E4%BB%B6/3-QT%E5%B8%83%E5%B1%80/1.png" alt="1"></p>
<p>​	上面这三个分别是Vertical Layout（垂直布局），Horizontal Layout（水平布局），Gird Layout（表格布局），Form Layout（表格布局），</p>
<p>​	其实我在这里对于这些布局控件是很难以描述的，所以还是得依靠自己去进行控件的使用去进行熟悉，虽然我也没有资格说这话就是了，我自己都对于这些个布局的使用不熟悉。</p>
<p>​	</p>
<h3 id="弹簧控件"><a href="#弹簧控件" class="headerlink" title="弹簧控件"></a>弹簧控件</h3><p>​	在常规的布局使用中，我们会存在一些问题，就是由于布局内部的自动调整，所以我们对于一些布局给我们生成的样式进行自行调整，我也不好描述，但是只要你自己亲手用过布局那你应该知道我在说什么。这时就需要我们去使用一个额外的控件去进行控制。在QT中，这系列控件就是下面这俩个Spacers控件</p>
<p><img src="/2024/12/27/QT%E6%8E%A7%E4%BB%B6/3-QT%E5%B8%83%E5%B1%80/3.png" alt="3"></p>
<p>​	这俩个存在的目的就是对于我们的布局进行一定的占位操作，通过这种占位我们可以实现一些我们布局的调整。说起来还是很抽象是吧，我们来上演示。</p>
<p>​	这里就没有给出没上这个控件前的演示了，主要是忘了。</p>
<p><img src="/2024/12/27/QT%E6%8E%A7%E4%BB%B6/3-QT%E5%B8%83%E5%B1%80/2.png" alt="2"></p>
<p>​	从图中，我们其实可以很清晰的看到这些个控件的布局效果，这里就不详细进行分析了，毕竟对于QT这种面向api编程的，去详细的了解它的底层并没有意义，主要是我也不知道，不然以我这发散思维不知道又能给我扯到哪里去。</p>
<p>​	对于这个弹簧形状的控件，我们还需要了解它的一个重要属性，就是调整它的形状，这个是在页面右下角的<strong>属性编辑器</strong>那里。</p>
<p><img src="/2024/12/27/QT%E6%8E%A7%E4%BB%B6/3-QT%E5%B8%83%E5%B1%80/5.png" alt="5"></p>
<p>​	在这个编辑器中，我们可以对于弹簧的一些属性进行设置，其中最常用的其实就是对于弹簧的宽度和高度进行设置，如果我们想要把这种设置福鼎下来，我们还需要去设置对应的sizeType为Fixed，这样的话我们一调整对应的数值，我们的ui界面上就能够有对应的改动。</p>
<p>​	这里还是没法多说，毕竟太抽象了，自己多动动手吧。</p>
<blockquote>
<p>​	坏了，对于这种面向api编程的东西，我烂尾了，我暂时不会再写这一类的东西了，毕竟这些实在是太无聊了，之后我看看视频跟着过一遍然后自己理解就行了，大家自求多福吧。</p>
</blockquote>
<h2 id="溜溜球"><a href="#溜溜球" class="headerlink" title="溜溜球"></a><strong>溜溜球</strong></h2>]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QLineEdit</title>
    <url>/2024/12/20/QT%E6%8E%A7%E4%BB%B6/1-QLineEdit/</url>
    <content><![CDATA[<p><em>该文档进行QT中的QLineEdit控件的介绍</em></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>QLineEdit属于QT中一种常用的输入控件，用于用户层与数据层之间的交互</p>
<span id="more"></span>

<h2 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h2><p><em>在QLineEdit中，允许我们对于输入格式进行规定，其中一种很经典的模式就是掩码</em></p>
<p>其中存在着几种模式，简单介绍下</p>
<blockquote>
<p>QLineEdit属于输入插件，用来实现单行录入。支持几种录入模式。</p>
<p>Normal表示正常录入,录入的信息会显示在QLineEdit上。</p>
<p>Password表示密码录入的方式，录入的信息不显示QLineEdit，只是通过黑色圆点显示。</p>
<p>NoEcho 表示不显示录入信息，类似于Linux输入密码时，显示的是一片空白。</p>
<p>PasswordEchoOnEdit 表示在输入的一刹那可以看到字符，但是立刻变为不可见的黑色圆点显示。</p>
</blockquote>
<p>位于QT的官方英文文档可以自行查看，这里给出GPT的中文翻译掩码文档</p>
<img src="/2024/12/20/QT%E6%8E%A7%E4%BB%B6/1-QLineEdit/rules.png" alt="rules" style="zoom:80%;">

<p><img src="/2024/12/20/QT%E6%8E%A7%E4%BB%B6/1-QLineEdit/moreRules.png" alt="moreRules"></p>
<p>我们可以使用这些字符的多种排列组合来进行我们掩码的设计</p>
<p>对于GPT给出的语言，有些地方可能有点疑惑，我们来进行一下分析：</p>
<blockquote>
<ol>
<li><h5 id="必须输入"><a href="#必须输入" class="headerlink" title="必须输入"></a>必须输入</h5><p>​	这个没什么好说的，就是这个掩码在的位置上必须输入对应要求的字符</p>
</li>
<li><p><strong>允许使用但不要求使用</strong></p>
<p>​	这个指的是这个位置上可以输入数据也可以不输入数据。但是如果你要输入数据，</p>
<p>那么你输入的这个数据就必须是我们要求的数据。就比如<strong>a</strong>,对于这个占位符在的地方，</p>
<p>要么直接略过，要么就输入A-Z,a-z的字母。</p>
</li>
</ol>
</blockquote>
<p>​	</p>
<p>由上面，我们来举出一个例子，不进行赘述了，自行搓码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString ip=<span class="built_in">QString</span>(<span class="string">&quot;000.000.000.000;_&quot;</span>);</span><br><span class="line">   QString mac=<span class="built_in">QString</span>(<span class="string">&quot;HH:HH:HH:HH:HH:HH&quot;</span>);</span><br><span class="line">   ui-&gt;ipEdit-&gt;<span class="built_in">setInputMask</span>(ip);</span><br><span class="line">   ui-&gt;macEdit-&gt;<span class="built_in">setInputMask</span>(mac);</span><br></pre></td></tr></table></figure>

<p><em>题外话，QT的官方英文文档确实多且杂，还好现在有大模型可以减轻这方面的阅读压力啊</em></p>
<p>除了限定我们的输入格式之外，QLineEdit还提供了我们输入时的显示格式等一系列功能</p>
<p>这里我们只说明下对应的输入显示功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ui-&gt;pwdEdit-&gt;setEchoMode(QLineEdit::Password);</span></span><br><span class="line">   <span class="comment">//ui-&gt;pwdEdit-&gt;setEchoMode(QLineEdit::PasswordEchoOnEdit);</span></span><br><span class="line">   <span class="comment">//ui-&gt;pwdEdit-&gt;setEchoMode(QLineEdit::Normal);</span></span><br><span class="line">   ui-&gt;pwdEdit-&gt;<span class="built_in">setEchoMode</span>(QLineEdit::NoEcho);</span><br></pre></td></tr></table></figure>

<p>QT中提供了4种输入格式，分别就是上面的四个宏，都可以在对应的帮助文档中查询到，这里不进行赘述</p>
<p>直接给出GPT的翻译，简单看一下功能即可</p>
<p><img src="/2024/12/20/QT%E6%8E%A7%E4%BB%B6/1-QLineEdit/editRules.png" alt="editRules"></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote>
<p><em>回过头来看，使用掩码来直接规定输入格式其实在一定程序上限制了程序</em></p>
<p><em>因此，我们需要考虑一种具有更强的扩展性又很规范的格式来规定我们的输入</em></p>
<p><em>在QT中，正则表达式就是其中的一种</em></p>
</blockquote>
<p>在这里，我们并不深入去了解正则表达式的格式，我直接贴出GPT翻译后的规则</p>
<p>其实，正则表达式这种具有严格规定的模式设计起来很麻烦，</p>
<p>但是现在我们可以直接使用GPT去为我们生成对应的正则表达式，所以啊，善用工具吧</p>
<p><img src="/2024/12/20/QT%E6%8E%A7%E4%BB%B6/1-QLineEdit/regularRule.png" alt="regularRule"></p>
<p><img src="/2024/12/20/QT%E6%8E%A7%E4%BB%B6/1-QLineEdit/regularRule2.png" alt="regularRule2"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QRegularExpression <span class="title">regex</span><span class="params">(<span class="string">&quot;^[\\w\\.-]+@[\\w\\.-]+\\.[a-zA-Z]&#123;2,&#125;$&quot;</span>)</span></span>;</span><br><span class="line">QRegularExpressionValidator* validator=<span class="keyword">new</span> <span class="built_in">QRegularExpressionValidator</span>(regex,ui-&gt;emailEdit);</span><br><span class="line">ui-&gt;emailEdit-&gt;<span class="built_in">setValidator</span>(validator);</span><br></pre></td></tr></table></figure>

<p>如上，这就是一个GPT辅助生成的正则表达式，我只要理解了这些个到底是一个怎么个使用情况，</p>
<p>对于生成正则表达式这种吃力不讨好的工作就可以交给大模型来完成。</p>
<p><em><strong>话毕，溜溜球</strong></em></p>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT对话框</title>
    <url>/2024/12/20/QT%E6%8E%A7%E4%BB%B6/2-QTDialog/</url>
    <content><![CDATA[<p>​	<em><strong>在该博文中，我们将会进行一些QT对话框的了解</strong></em></p>
<p>​	<em>在本文中，将基于QT的api进行简单的了解，不会进行深入</em></p>
<h1 id="颜色对话框"><a href="#颜色对话框" class="headerlink" title="颜色对话框"></a>颜色对话框</h1><p>​	<img src="/2024/12/20/QT%E6%8E%A7%E4%BB%B6/2-QTDialog/colorDialog.png" alt="colorDialog"></p>
<span id="more"></span>

<p>​	上面这个对话框就是我们QT控件中自带的颜色对话框样式。</p>
<h4 id="对话框类名-QColorDialog"><a href="#对话框类名-QColorDialog" class="headerlink" title="对话框类名:	QColorDialog"></a>对话框类名:	<code>QColorDialog</code></h4><h4 id="构造函数所需参数"><a href="#构造函数所需参数" class="headerlink" title="构造函数所需参数:"></a>构造函数所需参数:</h4><p>​		1~<em>QColor颜色宏</em>	使用任意一个颜色宏以指定打开对话框时的默认颜色</p>
<p>​		2~<em>QWidget</em>指针*	使用任意一个<em>QWidget</em>类型类对象，将颜色对话框挂载到该窗口</p>
<h4 id="一些简单性质："><a href="#一些简单性质：" class="headerlink" title="一些简单性质："></a>一些简单性质：</h4><blockquote>
<p>​		<em>对于这个对话框，右下角会有俩个默认的和[Cancel]按钮。对于这俩个按钮，当	我们选择完或者自定义完我们的颜色并按下按钮后，这个颜色对话框将会被关闭，在默认	情况下，只有你站在最后关闭窗口是使用按钮，最后窗口的颜色属性都会被保存。否	则，还是只会保存上一次设定的颜色值，没有就是默认的颜色属性。</em></p>
<p>​		<em>我们可以使用QColorDialog类的currentColor方法进行获取这个颜色的属性，当然可	能看不懂它的输出。</em></p>
</blockquote>
<p>​		</p>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QEventFilter</title>
    <url>/2024/12/29/QT%E6%8E%A7%E4%BB%B6/4-eventfiliter/</url>
    <content><![CDATA[<blockquote>
<p>​	在接下来的QT中，我将会是一个相对无厘头的形态，属于是看到哪学到哪，并且大部分时间不会搓代码，只在之后使用一俩个相对不错的项目来进行熟悉。</p>
</blockquote>
<span id="more"></span>

<h1 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h1><p>QT中存在着一系列的系统供我们使用，信号与槽系统就是其中最出名的一个，同时，事件机制也是一个相当重要的系统。</p>
<p>​	</p>
<p>​	事件系统中相当重要的是一套函数:<em><em>event(QEcent</em> pevent)</em>*</p>
<p>​	QT中通过这套函数来进行事件的传递，我们这里不进行一些详细的分析，只进行一些简单的介绍，主要是我自己也不是很了解这东西。</p>
<p>​	</p>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><blockquote>
<p>​	在QT中，基本所有的类都存在着一套继承下来的event机制函数，通过这套函数，可以去使用QT的事件机制。</p>
</blockquote>
<p>​	首先来看一些比较经典的事件函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyEdit::keyPressEvent</span><span class="params">(QKeyEvent * event)</span></span></span><br></pre></td></tr></table></figure>

<p>​	这里的MyEdit是我们继承的LineEdit类，而这里的函数是我们对于父类的keyPressEvent函数的重写，通过这个重写，我们可以自定义处理我们的这个事件的行为。这个没什么好说的。</p>
<h3 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h3><p>​	<strong>主要是来我们事件的传递机制。</strong></p>
<p>​	在这里，我们其实是对于QLineEdit进行了一次继承的封装，那么，如果从设计模式来看的话，这里其实类似于一种由继承实现的装饰模式。在这个装饰类中，我们可以去使用对应的父类的事件函数来进行重写来添加我们的行为。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyEdit::keyPressEvent</span><span class="params">(QKeyEvent * event)</span></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;MyEdit key press event&quot;</span>;</span><br><span class="line">    QLineEdit::<span class="built_in">keyPressEvent</span>(event);</span><br><span class="line">    event-&gt;<span class="built_in">ignore</span>();    <span class="comment">//将这个事件往上抛</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在这种装饰下，本来的话当我们想要去使用一个QLineEdit控件的时候，其的对应的事件会直接传递给我们的控件基类去进行处理，而我们这里继承了该类并且重写了对应的事件处理函数，这就意味着我们为我们的基类信号处理行为添加了一层代理，所有的信号将会优先通过这个接口，而不是基类的接口。</p>
<h3 id="包装"><a href="#包装" class="headerlink" title="包装"></a>包装</h3><p>​	在这里，你如果没有使用基类的方法，那么你会发现它只是一个日志输出。所以，我们可以使用C++11的特性去进行父类方法的使用，这样的话我们就能够同时使用原有的控件的功能了，这样的话，其实又像极了设计模式中的外观模式。添加了一层额外的包装，这层包装与原来的包装形成了一套更加复杂的系统。但是，我们不必要去了解这上下的层次关系，只需要去关注于当前的设计即可，优秀啊。</p>
<h3 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h3><p>​	需要注意的是，在QT的事件机制中，当一个事件被处理之后，它会被自动的标记为已处理，并且不会再继续地去场传递。但是有时候我们希望我们的这些个事件可以被父对象给进行处理，这时候我们就需要使用我们的Event类的ignore函数。</p>
<p>​	通过这个函数，我们可以把这个事件重新标记为一种还未被处理的状态，然后这个事件就能够被父对象给进行接受了。以此类推，整个事件链条都支持这种处理方式。</p>
<p>​	也就是说，这种处理方式其实还是使用了设计模式的行为性设计模式的责任链模式的。</p>
<h4 id="事件传递与责任链模式"><a href="#事件传递与责任链模式" class="headerlink" title="事件传递与责任链模式"></a><strong>事件传递与责任链模式</strong></h4><p>Qt 的事件传递机制本质上可以视为一种 <strong>责任链模式</strong>，因为：</p>
<ol>
<li>事件的默认处理方式：<ul>
<li>事件被目标对象的事件处理函数捕获。</li>
<li>如果事件被标记为 <code>accepted</code>，则不再继续传递。</li>
</ul>
</li>
<li>通过 <code>ignore()</code> 实现传递：<ul>
<li>调用 <code>event-&gt;ignore()</code> 可以将事件标记为未处理。</li>
<li>未处理的事件会沿着父对象链向上传递，直到找到可以处理的对象，或最终丢弃。</li>
</ul>
</li>
</ol>
<h2 id="阶段归纳"><a href="#阶段归纳" class="headerlink" title="阶段归纳"></a>阶段归纳</h2><p>​	也就是说，QT的事件机制其实可以看做是一种责任链模式的高级应用。在这些个责任链上，基础的消息就是我们的事件。而这些个责任链的传递起始点，就是我们的用户层。第一个处理用户发出的事件的，就是我们对于一些类的额外实现。如果没有，那么就是我们的系列控件类，以此类推。</p>
<p>​	让我们来重新归纳下这个责任链条。在这个责任链条上，每一种类都是责任链条上的一个处理者。整个责任链条的起始点就是我们的用户层面，我们发出的总总行为动作就是这个责任链条上传递的信息，这些责任链条的构成其实就是我们的一种父子关系的一种体现。可以这么说，每个责任链条上的节点的上一层节点都是他的父对象。注意，不是对应的继承的父对象，而是绑定的父对象。</p>
<p>​	这个责任链条上，每一层的节点代表的是一个大类，就比如我们的QLineEdit，这个会是对应的使用的原本的QLineEdit的链条上的一个环节。而如果是我们自己实现的MyEdit，这个会是我们另一个使用这个MyEdit对象的链条上的另一个节点，这俩者之间是不一定相交的。</p>
<h3 id="特殊处"><a href="#特殊处" class="headerlink" title="特殊处"></a>特殊处</h3><p>​	我们再来对这个责任链条上的节点进行一些分析，需要注意的是，这些</p>
<p>责任链条上对于事件的处理是有一定的逻辑的。所有的事件当它到达我们的对应的层级时，它会先被我们这个节点上的event函数进行分析并且处理，如果可能，这个信号还会被继续分发到更下层的处理函数中进行处理，以此类推，这些事件处理可能存在多个层次，但是总的来说一般只有event和具体的event处理这俩个层次。</p>
<p>​	还有，对于事件的处理，这俩个都会进行接受，但是否进行对应的操作，取决于这个事件中的一个特殊属性。姑且可以把这个属性称之为是否已处理。在进入任何一个event处理函数后，这个对应的事件都会被标记为已处理的，如果已经被标记为以处理，那么这个事件将不会被传递到这个链条的任何一层，哪怕是同一层的更深处也是一样。</p>
<h3 id="event和深层函数处理"><a href="#event和深层函数处理" class="headerlink" title="event和深层函数处理"></a>event和深层函数处理</h3><p>​	event是一个节点层次的一个相对来说更接近时间发出者的一个层次，在这个层次中，其控制了这个信号接下来的具体流向，其返回一个bool值，如果我们在这个函数处理后返回了一个true，就代表着这个信号已经处理完毕，接下来这个信号将不会被任何处理函数所接收。如果我们这个函数最后返回了一个false，那么这个函数还是会被接下来的下一层次的节点所进行解析。</p>
<p>​	但是，这里简单的返回true和返回false有时并不能满足我们的需求，因为这种返回是不会使得函数实现原有的功能的，要实现我们原有的功能，就需要去在这个event函数中去使用C++11中的新特性，去调用对应的事件处理函数。</p>
<p>​	我们一种常见的用法就是在我们的return语句中去进行对应的父类事件处理函数的调用，毕竟这些个事件处理函数都是一个受保护的状态，我们可以通过对应的操作去进行使用，就比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyEdit::event</span><span class="params">(QEvent *pevent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保证重写的是当前类的函数</span></span><br><span class="line">    <span class="keyword">if</span>(pevent-&gt;<span class="built_in">type</span>() == QEvent::KeyPress)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;my edit event&quot;</span>) &lt;&lt; Qt::endl;</span><br><span class="line">        <span class="comment">//return false;</span></span><br><span class="line">        <span class="comment">//在一层的event函数返回false就代表着这个类的这个信号处理结束</span></span><br><span class="line">        <span class="comment">//返回true标志处理好了，接下来会传递但不会继续处理</span></span><br><span class="line">        <span class="comment">//返回false会继续向下一层进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  QLineEdit::<span class="built_in">event</span>(pevent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	需要注意的是，在在这里面，其实就是进行了一次控制流的更改，将当前流转向对应的事件处理流中，等到全部处理完成后返回这个event才会继续去判断这个是否还要继续去往上层去传递。</p>
<p>​	也就是说，这种流的转向其实是用于我们当前event函数中去进行特定额外的信号处理的机制的。</p>
<p>​	接下来我们来时候一下这种流的转向会遇到的一种有趣的情况。</p>
<p>​	在我们的event函数中调用注入**QLineEdit::event(pavent);**函数后，这个函数会去进行对应的函数的调用，有趣的是，这里产生的效果却是我们重载的事件处理函数的效果。</p>
<p>​	目前来说这几个函数对我们来说都是黑盒，但是我们不难猜测，这是运用了多态的一种特性。在整个事件处理链条的层次中，每个层次中的事件处理函数只会存在一个。如果我们对于事件处理函数进行了重载，那么这个处理函数就会去替换原有的函数的位置，全部的事件处理函数都遵守这个规则。所以，我们如果需要去进行额外的添加，我们还需要做的是在重载的事件处理函数中去使用原有的事件处理方法去进行这个节点的行为的填充。这种又是一种装饰模式的体现。</p>
<p>​	</p>
<blockquote>
<p>接下来给出一个GPT的总结版本</p>
</blockquote>
<h2 id="GPT归纳版本"><a href="#GPT归纳版本" class="headerlink" title="GPT归纳版本"></a>GPT归纳版本</h2><hr>
<h3 id="事件机制与责任链模式"><a href="#事件机制与责任链模式" class="headerlink" title="事件机制与责任链模式"></a>事件机制与责任链模式</h3><ol>
<li><strong>事件的责任链传递</strong>：<ul>
<li>事件从用户层发起，沿着父对象关系形成的链条逐级向上传递。</li>
<li>每个对象是责任链上的一个处理节点，具有决定是否处理该事件的权利。</li>
</ul>
</li>
<li><strong>父对象 vs. 父类</strong>：<ul>
<li>父对象是通过 <code>QObject::setParent</code> 或构造函数参数指定的对象，形成实际的对象层级关系。</li>
<li>父类是继承层级中的基类，与责任链无直接关系。</li>
</ul>
</li>
<li><strong>节点上的事件处理逻辑</strong>：<ul>
<li>事件到达一个节点时，优先调用该节点的 <code>event</code> 方法。</li>
<li>如果未处理（返回 <code>false</code>），则事件继续向上层节点传递。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="event-函数的深度解析"><a href="#event-函数的深度解析" class="headerlink" title="event 函数的深度解析"></a><code>event</code> 函数的深度解析</h3><ol>
<li><strong><code>event</code> 的双层处理机制</strong>：<ul>
<li><strong>第一层</strong>：<code>event</code> 函数负责高层次的事件分发，比如识别事件类型。</li>
<li><strong>第二层</strong>：更具体的事件处理函数（如 <code>keyPressEvent</code>）完成细化逻辑。</li>
</ul>
</li>
<li><strong>流控制</strong>：<ul>
<li>返回 <code>true</code>：事件被标记为已处理，不再传递。</li>
<li>返回 <code>false</code>：事件未处理，继续向上层或同层其他处理器传递。</li>
</ul>
</li>
<li><strong>保留原功能的方式</strong>：<ul>
<li>调用基类的 <code>event</code> 或具体的事件处理方法（如 <code>QLineEdit::event</code>），保留该类原有的事件处理逻辑。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="多态与装饰模式的结合"><a href="#多态与装饰模式的结合" class="headerlink" title="多态与装饰模式的结合"></a>多态与装饰模式的结合</h3><ol>
<li><strong>多态性</strong>：<ul>
<li>当调用 <code>QLineEdit::event(pevent)</code> 时，实际上调用的是 <code>MyEdit</code> 的重载实现（如果存在）。</li>
<li>这是 C++ 中多态特性的体现，通过虚函数机制确保子类对基类行为的覆盖。</li>
</ul>
</li>
<li><strong>装饰模式的体现</strong>：<ul>
<li>在子类的 <code>event</code> 方法中，通过调用基类的 <code>event</code>，在其基础上添加额外逻辑，形成装饰模式的效果。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="示例补充"><a href="#示例补充" class="headerlink" title="示例补充"></a>示例补充</h3><p>可以扩展现有代码的注释，进一步强调核心逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyEdit::event</span><span class="params">(QEvent *pevent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断事件类型</span></span><br><span class="line">    <span class="keyword">if</span> (pevent-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;my edit event&quot;</span>) &lt;&lt; Qt::endl;</span><br><span class="line">        <span class="comment">// 处理自定义逻辑，但不阻止事件向下传递</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 返回 false 表示未完全处理，允许后续处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类的事件处理逻辑，保留 QLineEdit 原有行为</span></span><br><span class="line">    <span class="keyword">return</span> QLineEdit::<span class="built_in">event</span>(pevent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>你已经很好地总结了 Qt 事件机制与相关设计模式的核心思路。可以进一步结合代码实践，验证如下几个问题：</p>
<ul>
<li><strong>事件传递</strong>：在某节点标记为已处理后，观察事件是否会继续传递到父对象。</li>
<li><strong>多态行为</strong>：通过不同的继承与重写组合，探究多态在事件处理中的实际效果。</li>
</ul>
<h2 id="事件过滤器"><a href="#事件过滤器" class="headerlink" title="事件过滤器"></a>事件过滤器</h2><blockquote>
<p>​	在QT中的事件处理机制中，还存在着一个相当重要的机制，就是我们的过滤器机制。通过这个机制，我们可以对于一个用户发出的事件进行过滤，没错，就是你想的那种过滤。</p>
</blockquote>
<h3 id="使用事件过滤器的步骤"><a href="#使用事件过滤器的步骤" class="headerlink" title="使用事件过滤器的步骤"></a>使用事件过滤器的步骤</h3><ol>
<li>继承 <code>QObject</code> 并重写 <code>eventFilter</code> 方法：<ul>
<li>事件过滤器需要继承自 <code>QObject</code> 并实现 <code>eventFilter()</code> 方法。</li>
<li><code>eventFilter()</code> 接收两个参数：目标对象和事件本身。</li>
</ul>
</li>
<li>安装事件过滤器：<ul>
<li>通过 <code>installEventFilter()</code> 方法，将事件过滤器安装到目标对象上。</li>
</ul>
</li>
</ol>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEventFilter</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断事件类型</span></span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">            QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Key pressed:&quot;</span> &lt;&lt; keyEvent-&gt;<span class="built_in">text</span>();</span><br><span class="line">            <span class="comment">// 返回 true 阻止事件继续传播，返回 false 允许传播</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 事件被拦截</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> QObject::<span class="built_in">eventFilter</span>(watched, event);  <span class="comment">// 调用基类处理其他事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget w;</span><br><span class="line">    MyEventFilter *filter = <span class="keyword">new</span> <span class="built_in">MyEventFilter</span>();</span><br><span class="line">    w.<span class="built_in">installEventFilter</span>(filter);  <span class="comment">// 将事件过滤器安装到 QWidget 上</span></span><br><span class="line"></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件过滤器的作用"><a href="#事件过滤器的作用" class="headerlink" title="事件过滤器的作用"></a>事件过滤器的作用</h3><ul>
<li><strong>拦截和修改事件</strong>：比如，你可以拦截按键事件，修改或阻止某些特定的按键。</li>
<li><strong>监听多个对象的事件</strong>：事件过滤器可以安装到多个对象上，统一处理这些对象的事件。</li>
<li><strong>事件传播控制</strong>：通过返回 <code>true</code> 或 <code>false</code>，你可以控制事件是否继续传递，或是否被完全阻止。</li>
</ul>
<h3 id="事件过滤器的优缺点"><a href="#事件过滤器的优缺点" class="headerlink" title="事件过滤器的优缺点"></a>事件过滤器的优缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li>可以在不改变目标对象的情况下，灵活地处理事件。</li>
<li>适用于需要跨多个对象进行事件监听或处理的场景。</li>
</ul>
<h3 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h3><p>​	不难猜想到，这个事件过滤器其实是我们事件链条上的一环。再者，在这个链条上，这个事件过滤器的优先级甚至于要高于event函数的，所有的事件都需要先通过这个事件过滤器去进行一次过滤，所有返回true的事件将会被拦截。在经过我们的事件过滤器后，如果我们还想要在本层次中去进行对应的事件处理，我们需要使得这些个事件在最后在这个层级中能够返回false被event函数所接收。</p>
<p>​	对于一个经过事件处理器的事件，如果最后这个事件过滤器对这个事件的处理返回值是true，就代表这个事件被拦截了，如果返回false，那么这个事件就会被传递到对应的这个层次上的event中去进行后续的处理。当然，我们在这里还可以进行进一步的过滤，就比如再次的去调用另一个事件过滤器，但是总体来说处理逻辑都是一样的。</p>
<p>​	现在就可以对于这个节点的层次逻辑进行进一步的填充，所有的事件，都会先经过当前节点的事件过滤器去进行识别，当经过这个事件过滤器并且返回值是false后，这个事件将会被分发到event中去进行我们上面已经分析过的处理，这俩者之间没有一个紧密的联系。俩者之间的耦合度相当低使得我们可以只专注于当前事件过滤器的设计。</p>
<p>​	需要注意一点的是，事件过滤器的安装需要一个事件过滤器指针，这个指针可以有多种情况，最简单的就是去定义一个通用的事件过滤器，所有的都可以使用这个事件过滤器，如果我们是在一个类中去进行了我们事件过滤器函数的重写。如果我们想要安装这个重写的事件过滤器，需要注意的是，我们只需要去在对应的install函数中去传入这个对象的指针即可。</p>
<blockquote>
<p>事需缓图，欲速不达也。</p>
<p>得找个时间去练练手，今天就先到这，溜溜球。</p>
</blockquote>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>redis了解</title>
    <url>/2025/04/15/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/2-redis%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<hr>
<h1 id="Redis-自动结构调优机制与用户接口视图"><a href="#Redis-自动结构调优机制与用户接口视图" class="headerlink" title="Redis 自动结构调优机制与用户接口视图"></a>Redis 自动结构调优机制与用户接口视图</h1><h2 id="一、整体概述"><a href="#一、整体概述" class="headerlink" title="一、整体概述"></a>一、整体概述</h2><p>Redis 在内部为不同数据结构提供了一套 <strong>自动结构优化机制</strong>，其目的是在保证性能和内存效率的前提下，自动选择合适的底层结构。这种机制对用户是 <strong>完全透明的</strong>，开发者在使用时无需关注底层细节，只需专注于对外暴露的接口。</p>
<span id="more"></span>

<hr>
<h2 id="二、用户层面的“三层视图”"><a href="#二、用户层面的“三层视图”" class="headerlink" title="二、用户层面的“三层视图”"></a>二、用户层面的“三层视图”</h2><p>我们可以将 Redis 中的数据结构在用户侧抽象为三层：</p>
<ol>
<li><strong>第一层：顶层键值对</strong><ul>
<li>Redis 键空间中的键名，例如：<code>&quot;user:1001&quot;</code>、<code>&quot;config:system&quot;</code> 等。</li>
</ul>
</li>
<li><strong>第二层：结构内部的字段和值</strong><ul>
<li>对应 Hash、ZSet、List 等结构中的子键（如 <code>field</code>、<code>score</code>、<code>index</code>）。</li>
</ul>
</li>
<li><strong>第三层：具体的值</strong><ul>
<li>实际存储的数据内容，如字符串、数字等。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="三、自动调优机制说明"><a href="#三、自动调优机制说明" class="headerlink" title="三、自动调优机制说明"></a>三、自动调优机制说明</h2><h3 id="1-自动优化场景"><a href="#1-自动优化场景" class="headerlink" title="1. 自动优化场景"></a>1. 自动优化场景</h3><p>Redis 根据数据结构的大小与数据特性（如长度、数量等），动态选择以下结构：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>小规模时的结构</th>
<th>自动升级结构</th>
</tr>
</thead>
<tbody><tr>
<td>Hash</td>
<td>ziplist</td>
<td>hashtable</td>
</tr>
<tr>
<td>List</td>
<td>ziplist</td>
<td>quicklist</td>
</tr>
<tr>
<td>Set</td>
<td>intset</td>
<td>hashtable</td>
</tr>
<tr>
<td>Sorted Set</td>
<td>ziplist</td>
<td>skiplist + dict</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ Redis 会在插入&#x2F;修改数据时实时判断是否需要结构升级。</p>
</blockquote>
<hr>
<h3 id="2-示例：Hash-类型结构升级"><a href="#2-示例：Hash-类型结构升级" class="headerlink" title="2. 示例：Hash 类型结构升级"></a>2. 示例：Hash 类型结构升级</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HSET user:1001 name Alice</span><br><span class="line">HSET user:1001 email alice@example.com</span><br><span class="line">...（插入过多 field 后）</span><br><span class="line"><span class="comment"># Redis 自动将 ziplist 转换为 hashtable</span></span><br></pre></td></tr></table></figure>

<p>用户无需感知这种转变，接口始终统一。</p>
<hr>
<h2 id="四、设计理念：适配器封装"><a href="#四、设计理念：适配器封装" class="headerlink" title="四、设计理念：适配器封装"></a>四、设计理念：适配器封装</h2><p>Redis 暴露给用户的操作接口（如 <code>HSET</code>、<code>HGET</code> 等），本质上是对多种底层结构的统一封装。可以理解为：</p>
<blockquote>
<p>Redis 是通过“<strong>适配器模式</strong>”将不同的物理结构封装为统一的逻辑接口。</p>
</blockquote>
<hr>
<h2 id="五、开发者关注点"><a href="#五、开发者关注点" class="headerlink" title="五、开发者关注点"></a>五、开发者关注点</h2><ul>
<li>✅ 我们只需要了解各类结构的对外接口及其参数格式；</li>
<li>✅ 完全不需要关心当前使用的是哪种底层结构；</li>
<li>⚠️ 只有在进行极致性能调优或自定义 Redis 构建时，才需要深入了解结构转变的逻辑与阈值。</li>
</ul>
<hr>
<h2 id="六、配置项（进阶）"><a href="#六、配置项（进阶）" class="headerlink" title="六、配置项（进阶）"></a>六、配置项（进阶）</h2><p>可以通过配置文件控制结构优化的触发阈值，例如：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hash结构转为hashtable的条件</span></span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><ul>
<li>Redis 提供自动结构调优能力；</li>
<li>所有细节由 Redis 内部适配器封装；</li>
<li>用户只需按接口正确传参；</li>
<li>层级视图便于理解逻辑与结构划分；</li>
<li>性能相关内容可在后续需要时再深入。</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>架构分析</title>
    <url>/2025/04/13/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/1-%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="项目架构分析"><a href="#项目架构分析" class="headerlink" title="项目架构分析"></a>项目架构分析</h1><p>​	在本文中，我将基于一个项目的结构进行一些分析，目的是为了清晰自己对于一个项目的熟悉。避免在之后不断扩展时丢失对于整个项目的掌控性。</p>
<span id="more"></span>

<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;(<span class="number">8080</span>);</span><br><span class="line">		net::io_context ioc&#123; <span class="number">1</span> &#125;;</span><br><span class="line">		boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(ioc, SIGINT, SIGTERM)</span></span>;</span><br><span class="line">		signals.<span class="built_in">async_wait</span>([&amp;ioc](<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">int</span> signal_number) &#123;</span><br><span class="line">			<span class="keyword">if</span> (error) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ioc.<span class="built_in">stop</span>();</span><br><span class="line">		&#125;);</span><br><span class="line">		std::<span class="built_in">make_shared</span>&lt;CServer&gt;(ioc, port)-&gt;<span class="built_in">Start</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;GateServer listen the port &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">		ioc.<span class="built_in">run</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception <span class="type">const</span>&amp; e)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里是一个十分经典且简单的服务器启动流程，使用ASIO内部的信号已经事件驱动机制来实现优雅退出。并没有什么好说的。在这个入口逻辑中，我们需要知道的是其在错误处理逻辑的防御性编程之后，其进行了一个对应的服务器的启动，我们接下来来看这里的启动逻辑。</p>
<h2 id="高层网关CServer"><a href="#高层网关CServer" class="headerlink" title="高层网关CServer"></a>高层网关CServer</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(_socket, [self](beast::error_code ec) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//出错放弃该连接并监听其他连接</span></span><br><span class="line">			<span class="keyword">if</span> (ec) &#123;</span><br><span class="line">				<span class="comment">//self-&gt;Start();</span></span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;Accept error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//创建新连接，并且创建HttpConnection管理该连接</span></span><br><span class="line">			std::<span class="built_in">make_shared</span>&lt;HttpConnection&gt;(std::<span class="built_in">move</span>(self-&gt;_socket))-&gt;<span class="built_in">Start</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//继续监听</span></span><br><span class="line">			self-&gt;<span class="built_in">Start</span>();</span><br><span class="line"></span><br><span class="line">		&#125;<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">			std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	在这个启动函数中，可以看到，其本身并不复杂，本质就是一个监听套接字的创建以及对应的监听行为注册。这里需要注意的是对于异步监听的回调函数的注册。这里使用的是匿名函数来实现回调逻辑的。并且这里通过传递一个自身对象来延长对象的生命周期避免被杀死。这里的回调处理逻辑中使用了又一次的匿名构造去实现对应的请求处理。由于我们本身设计的其实是一个Http服务器，所谓我们在设计中是存在一个HttpConnection类来处理所有的来自外部的请求的，一但出现一个请求，就单独创建一个对应的处理类进行处理。</p>
<p>​	但是这里其实存在一个问题，不知道你有没有看到，下面是给出的.h文件以及修改后的start方法，自行查找现有的错误逻辑处。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HttpConnection.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span> :<span class="keyword">public</span> std::enable_shared_from_this&lt;CServer&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CServer</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span>&amp; port);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	tcp::acceptor _acceptor;</span><br><span class="line">	net::io_context&amp; _ioc;</span><br><span class="line">	tcp::socket _socket; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>修改后的start方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用智能指针管理每个新的 socket</span></span><br><span class="line">	<span class="keyword">auto</span> new_socket = std::<span class="built_in">make_shared</span>&lt;tcp::socket&gt;(_ioc);</span><br><span class="line"></span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(*new_socket, [self,new_socket](beast::error_code ec) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//出错放弃该连接并监听其他连接</span></span><br><span class="line">			<span class="keyword">if</span> (ec) &#123;</span><br><span class="line">				<span class="comment">//self-&gt;Start();</span></span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;Accept error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//创建新连接，并且创建HttpConnection管理该连接</span></span><br><span class="line">			std::<span class="built_in">make_shared</span>&lt;HttpConnection&gt;(std::<span class="built_in">move</span>(*new_socket))-&gt;<span class="built_in">Start</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//继续监听</span></span><br><span class="line">			self-&gt;<span class="built_in">Start</span>();</span><br><span class="line"></span><br><span class="line">		&#125;<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">			std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，这里是基于当前有限的逻辑流中去实现的逻辑，如果看源码，你会发现其中并没有创建新的套接字进行对应的传递，而这种操作的原因涉及到了对应的套接字的传递方式。简单说一下，就是通过俩次std::move方法来实现一个套接字的控制逻辑的转交</p>
</blockquote>
<p>​	好了，到此为止，我们理清了目前服务器的简单逻辑。在主函数中去启动对应的高层网关服务器。接着，其会将逻辑流转到对应的<code>CServer</code>的执行流，在<code>start</code>函数中，其会进行对应的异步监听事件的调用，注册对应的处理函数，由于我们职责的解耦，所以我们这里的逻辑其实就是将对应的连接套接字交给对应的<code>HttpConnection</code>类进行对应的处理。</p>
<p>​	此时，由于我们在设计上的职责的解耦，此时提到的多层调用结构将不必关心我们这里的连接套接字，其会交由对应的处理类进行处理，我们还需要做的就是重新注册我们的对应监听逻辑来实现一个逻辑的闭环，实现服务器的不断监听。对于现有的俩层的分析结束。接下来需要看到我们的对于连接套接字进行处理的<code>HttpConnection</code>处理逻辑。</p>
<h2 id="HttpConnection逻辑处理"><a href="#HttpConnection逻辑处理" class="headerlink" title="HttpConnection逻辑处理"></a>HttpConnection逻辑处理</h2><p>​	对于该类，我们在设计上希望其能实现的功能是对于来自外部的请求的处理。我们前面已经了解到，在高层逻辑结束后，该类所收到的其实是一个成功与客户端建立起连接的监听套接字。接下来该类将可以通过该套接字与客户端之间进行通信，同时将不必再去关注其他的高层逻辑。</p>
<p>​	接下来，我们来看到对应的类设计模块</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpConnection</span> :<span class="keyword">public</span> std::enable_shared_from_this&lt;HttpConnection&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">LoginSystem</span>;</span><br><span class="line">	<span class="built_in">HttpConnection</span>(tcp::socket socket);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CheckDeadline</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WriteResponse</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleReq</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PreParseGetParam</span><span class="params">()</span></span>;</span><br><span class="line">	tcp::socket _socket;</span><br><span class="line">	beast::flat_buffer _buffer&#123; <span class="number">8192</span> &#125;;</span><br><span class="line">	http::request&lt;http::dynamic_body&gt; _request;</span><br><span class="line">	http::response&lt;http::dynamic_body&gt;_response;</span><br><span class="line">	<span class="comment">//使用花括号使用时能够以更好的可读性的格式进行列出</span></span><br><span class="line">	net::steady_timer deadline_&#123; _socket.<span class="built_in">get_executor</span>(),std::chrono::<span class="built_in">seconds</span>(<span class="number">60</span>) &#125;;</span><br><span class="line"></span><br><span class="line">	std::string _get_url;			<span class="comment">//储存要解析的url</span></span><br><span class="line">	std::unordered_map&lt;std::string, std::string&gt; _get_params;	<span class="comment">//储存本次在参数解析中解析出的参数列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	首先需要再强调一点，在网络编程中，由于使用裸指针可能导致的对象过期而导致的严重内存问题，所以一般来说都是使用的智能指针来进行内存管理。但是智能指针在异步设计的一些函数本身也存在一些问题。因为异步函数是不会立刻被调用的，所以如果我们不注意对应的智能指针的引用计数变化，则可能会导致智能指针管理的对象会在一些不希望的地方就直接被析构掉。所以有一个很朴素的思想。对于所有需要用到一个智能指针所管理着的对象的回调函数，我们都往其中去传递一个智能指针的对象来增加我们的引用计数来保证我们的生命周期，这样能够保证在函数调用时智能指针的引用计数永远不可能为0，也就是说在回调函数使用对应的对象管理着的指针时，其永远有效。</p>
<p>​	当然，这里也需要一个额外的帮助，就是ASIO对于它底层的事件队列中过期事件的处理，如果一个连接关闭了，有关其的所有事件都应该从队列中清除。这样我们对应的智能指针的引用计数才能够减少为0，对应的对象才能够被清除。否则，其会永远留存在内存中，导致我们的内存泄漏。</p>
<p>​	这里也就是为什么我们经常能够看到继承<code>public std::enable_shared_from_this&lt;HttpConnection&gt;</code>的类出现的原因，有了这个，我们才能够对于类本身进行一个智能指针对象的拷贝，具体的可以自己去了解。</p>
<hr>
<blockquote>
<p>​	接下来我们来看到这个类的设计逻辑。</p>
</blockquote>
<p>​	对于该类，我们需要的是对应的来自套接字的请求的逻辑处理，这其中最基本的应该是我们的读写处理，只有基于读写的操作才能够实现我们的双端通信。由于我们使用的是基于<code>beast</code>网络库的<code>http</code>实现，所以这里也就直接创建了对应的成员</p>
<h3 id="启动逻辑"><a href="#启动逻辑" class="headerlink" title="启动逻辑"></a>启动逻辑</h3><p>​	首先来看到一个有意思的构造函数，其能够解决我们前面为什么不使用一个新的套接字也能够实现CServer的套接字紧缺的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HttpConnection::<span class="built_in">HttpConnection</span>(tcp::socket socket) :_socket(std::<span class="built_in">move</span>(socket))&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​	接下来是我们的<code>http</code>处理类的逻辑执行入口<code>start</code>函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConnection::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	http::<span class="built_in">async_read</span>(_socket, _buffer, _request, [self](beast::error_code ec,std::<span class="type">size_t</span> bytes_transferred) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (ec) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;Http read error is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			boost::<span class="built_in">ignore_unused</span>(bytes_transferred);</span><br><span class="line">			self-&gt;<span class="built_in">HandleReq</span>();</span><br><span class="line">			self-&gt;<span class="built_in">CheckDeadline</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; ec) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;exception is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	我们来分析一下这个函数的调用逻辑。对于外部，其会在创建一个由智能指针管理着的类对象后直接调用这里的<code>Start</code>逻辑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">make_shared</span>&lt;HttpConnection&gt;(std::<span class="built_in">move</span>(*new_socket))-&gt;<span class="built_in">Start</span>();</span><br></pre></td></tr></table></figure>

<p>​	此时我们的套接字在一系列的逻辑转移中已经成功绑定到了对应的建立起连接的套接字上了。也就是说我们接下来的所有读写操作，都是直接对于对应的连接套接字进行的。对于这里的异步读函数逻辑，其传递了一个缓冲区进行数据的接受，指定了最终的数据写入位置。这里我们还需要一点beast的基础，对于<code>http::request&lt;http::dynamic_body&gt; _request;</code>对象，其是一个容器，内部储存的是一个http报文请求，具体的格式自行了解。这里只需要了解的是，在http通信中，客户端发送过来的应该是一个标准的http请求，那么服务器端就能够基于该请求去直接解析对应的数据，而<code>beast</code>网络库为我们完成了对应的解析逻辑的封装。也就是说，在一个正确运行的http服务器之下，我们的<code>_socket</code>中开头的http请求内容将会被储存到我们的<code>_request</code>结构中去。</p>
<p>​	在接受处理完对应的数据之后，其应该处理的是对应的回调函数。在该回调函数中，其进行了一定的防御式编程。我们主要注意到我们的<code>self-&gt;HandleReq(); self-&gt;CheckDeadline();</code>逻辑，其是对于我们的http请求的逻辑处理以及对于该次连接中我们的处理事件，如果一个请求的处理事件过长，我们直接判断其为恶意的，并且直接断开该连接。这里就显示这样简单的处理。</p>
<hr>
<blockquote>
<p>​	了解完我们的Http处理类对于一些基础逻辑的设计之后，我们需要来进行对应的数据包处理逻辑</p>
</blockquote>
<h3 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConnection::HandleReq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//设置回答的版本，关于HTTP回答头的部分通用属性</span></span><br><span class="line">	_response.<span class="built_in">version</span>(_request.<span class="built_in">version</span>());</span><br><span class="line">	_response.<span class="built_in">keep_alive</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (_request.<span class="built_in">method</span>() == http::verb::get) &#123;</span><br><span class="line">		<span class="built_in">PreParseGetParam</span>();</span><br><span class="line">		<span class="comment">//我们的LoginSystem中预先注册了一些URL所匹配的事务，如果没有，则会返回false</span></span><br><span class="line">		<span class="type">bool</span> success=LoginSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">HandleGet</span>(_get_url, <span class="built_in">shared_from_this</span>());</span><br><span class="line">		<span class="keyword">if</span> (!success) &#123;</span><br><span class="line">			_response.<span class="built_in">result</span>(http::status::not_found);</span><br><span class="line">			_response.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;type/plain&quot;</span>);</span><br><span class="line">			beast::<span class="built_in">ostream</span>(_response.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;url not found\r\n&quot;</span>;</span><br><span class="line">			<span class="built_in">WriteResponse</span>();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		_response.<span class="built_in">result</span>(http::status::ok);</span><br><span class="line">		_response.<span class="built_in">set</span>(http::field::server, <span class="string">&quot;GateServer&quot;</span>);</span><br><span class="line">		<span class="built_in">WriteResponse</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (_request.<span class="built_in">method</span>() == http::verb::post) &#123;</span><br><span class="line">		<span class="built_in">PreParseGetParam</span>();</span><br><span class="line">		<span class="type">bool</span> success = LoginSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">HandlePost</span>(_request.<span class="built_in">target</span>(), <span class="built_in">shared_from_this</span>());</span><br><span class="line">		<span class="keyword">if</span> (!success) &#123;</span><br><span class="line">			_response.<span class="built_in">result</span>(http::status::not_found);</span><br><span class="line">			_response.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;type/plain&quot;</span>);</span><br><span class="line">			beast::<span class="built_in">ostream</span>(_response.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;url not found\r\n&quot;</span>;</span><br><span class="line">			<span class="built_in">WriteResponse</span>();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		_response.<span class="built_in">result</span>(http::status::ok);</span><br><span class="line">		_response.<span class="built_in">set</span>(http::field::server, <span class="string">&quot;GateServer&quot;</span>);</span><br><span class="line">		<span class="built_in">WriteResponse</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	明确一下本函数的功能，其是为了在该处理类在接收解析完对应的http请求之后，进行我们的更加具体的逻辑处理。其最终的目的是构建出一个能够发送给客户端的数据包。</p>
<p>​	在该处理函数中，我们进行了一定的逻辑分流，其先基于我们当前的一些需求设置了一些回复报头的属性，这部分可以自行进行定制，这里的硬编码对于部分人来说可能会看起来很难受。接下来，我们前面已经提到，我们的_rquest中已经储存了对应的http请求头中的一些格式信息，其中就包括了我们当前的请求类型，到底是一个GET类型还是一个POST类型。这里进行了一次分流，后续可能考虑独立出对应的处理逻辑。</p>
<blockquote>
<p>​	无论是在对应的GET逻辑，POST逻辑，还是之后可能扩展的一系列逻辑中，其本质的处理方式都时大差不差的，所以这里只取出一种来进行分析</p>
</blockquote>
<p>​	我们来看到对应的GET处理逻辑</p>
<p>​	其内部的设计其实很简单，因为我们其实把具体的逻辑处理又给分发出去了，这是我们接下来需要了解的地方。在当前的逻辑中，我们会现对于整个<code>HTTP</code>请求中的<code>URI</code>进行解析，其中会包括一系列的解析函数，有兴趣可以自己分析一下。在解析完对应的<code>URI</code>之后，我们使用其中的<code>URL</code>进行对应的逻辑处理，由于我们这里的请求是<code>GET</code>类型。逻辑上分发的任务应该只是对应的静态资源的获取，所以这里直接传递了对应的<code>url</code>给我们的<code>LoginSystem</code>类对象。</p>
<p>​	该方法会返回一个<code>bool</code>值标识该操作是否成功实现了对应的功能，我们接下来会根据对应的状态来设计我们的回复报文，这块的逻辑设计自行分析。这一块先这样简单的理解，接下来我们需要进入<code>LoginSystem</code>来观察到底的实现逻辑是怎么样的。</p>
<h3 id="LoginSystem逻辑处理"><a href="#LoginSystem逻辑处理" class="headerlink" title="LoginSystem逻辑处理"></a>LoginSystem逻辑处理</h3><p>​	前文提到，我们在外部需要调用<code>LoginSystem</code>类来进行一些额外的底层逻辑的处理。对于该类，其的职责很明确，就是实现对于外部发送来的信息的解析已经处理，这系列信息将会是有关登录逻辑的。就比如我们登录验证码的收发等等，但是这里先不必深入如此。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpConnection</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(std::shared_ptr&lt;HttpConnection&gt;)&gt;HttpHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginSystem</span> :<span class="keyword">public</span> Singleton&lt;LoginSystem&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;LoginSystem&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">LoginSystem</span>();</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">HandleGet</span><span class="params">(std::string path,std::shared_ptr&lt;HttpConnection&gt; con)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">HandlePost</span><span class="params">(std::string path, std::shared_ptr&lt;HttpConnection&gt; con)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RegGet</span><span class="params">(std::string,HttpHandler handler)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RegPost</span><span class="params">(std::string url, HttpHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">LoginSystem</span>();</span><br><span class="line">	std::map&lt;std::string, HttpHandler&gt;_post_handlers;</span><br><span class="line">	std::map&lt;std::string, HttpHandler&gt; _get_handlers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	对于该类的处理，我们使用单例来实现对象的创建。毕竟在一个系统中并不需要多个登录类来对于我们处理逻辑的分流(至少我们这里不需要)。对于其内部的逻辑，其实是一种类似的事件驱动机制，就相当于外部会传入一些数据，该类将这些数据转换为一些有关的触发逻辑，然后根据这些触发逻辑在类内进行对应的逻辑跳转。</p>
<p>​	我们来看到该类的核心</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LoginSystem::<span class="built_in">LoginSystem</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">RegGet</span>(<span class="string">&quot;/get_test&quot;</span>, [](std::shared_ptr&lt;HttpConnection&gt; connection) &#123;</span><br><span class="line">		beast::<span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;receive get_test req&quot;</span>;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; elem : connection-&gt;_get_params) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			beast::<span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;\nparam &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:key is &quot;</span> &lt;&lt; elem.first;</span><br><span class="line">			beast::<span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;\nparam &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:value is &quot;</span> &lt;&lt; elem.second &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">RegPost</span>(<span class="string">&quot;/get_varifycode&quot;</span>, [](std::shared_ptr&lt;HttpConnection&gt;connection) &#123;</span><br><span class="line">		<span class="keyword">auto</span> body_str = boost::beast::<span class="built_in">buffers_to_string</span>(connection-&gt;_request.<span class="built_in">body</span>().<span class="built_in">data</span>());</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;received body id &quot;</span> &lt;&lt; body_str &lt;&lt; std::endl;</span><br><span class="line">		connection-&gt;_response.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/json&quot;</span>);</span><br><span class="line">		Json::Value root;</span><br><span class="line">		Json::Reader reader;</span><br><span class="line">		Json::Value src_root;</span><br><span class="line">		<span class="type">bool</span> parse_success = reader.<span class="built_in">parse</span>(body_str,src_root);</span><br><span class="line">		<span class="keyword">if</span> (!parse_success) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Failed to parse JSON data!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			root[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Error_Json;</span><br><span class="line">			std::string jsonStr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">			beast::<span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonStr;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将合法的JSON加载到对应的root中去</span></span><br><span class="line">		<span class="keyword">if</span> (!src_root.<span class="built_in">isMember</span>(<span class="string">&quot;email&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Failed to parse JSON data!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			root[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Error_Json;</span><br><span class="line">			std::string jsonStr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">			beast::<span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonStr;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">auto</span> email = src_root[<span class="string">&quot;email&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;email is &quot;</span> &lt;&lt; email &lt;&lt; std::endl;</span><br><span class="line">		root[<span class="string">&quot;error&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">		root[<span class="string">&quot;email&quot;</span>] = src_root[<span class="string">&quot;email&quot;</span>];</span><br><span class="line">		std::string jsonStr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">		beast::<span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonStr;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里的处理逻辑是根据我们的高层规定去限制的，就比如Http请求的格式是GET,那么域名所紧跟着的内容就应该是串对应的资源地址，总总这些，都是我们高层协议的一部分。为了更好的分析，我们来使用<code>RegPost</code>的逻辑进行分析，对于该方法，其实需要了解我们类内是怎么设计对应的注册函数的。如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LoginSystem::RegGet</span><span class="params">(std::string url, HttpHandler handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_get_handlers.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(url, handler));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LoginSystem::RegPost</span><span class="params">(std::string url, HttpHandler handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_post_handlers.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(url, handler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	其实就是简单的将我们的对应的URL与可调用对象进行一次键值对的关联，通过解析用户输入的URI来实现URL的传输，进而来触发我们这里的处理逻辑。</p>
<p>​	回到我们的<code>RegPost</code>处理逻辑。其现在的逻辑处理相对简单，就是对于当前连接的请求体数据进行一次解析，由于我们程序内部的使用都是面向一个字符串的，所以需要使用方法将我们的字节流数据转换为我们可以使用的字符串数据。接着我们根据对应的类型再去设置一些回复报文的信息。再然后，我们使用转换后的字符串流信息来进行解析，其内包含的即是客户端所发送来的信息，一但该解析过程中出现错误或者最终的解析结果中存在一些我们规定之外的数据。我们往其中写入一些错误信息并返回。如果各种都没有发生错误，这里简单的使用一个回写进行测试并返回。</p>
<p>​	最后再来处理一下<code>Handle</code>系列函数的逻辑，这里只是简单的进行我们注册在映射逻辑中的方法的调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LoginSystem::HandleGet</span><span class="params">(std::string path, std::shared_ptr&lt;HttpConnection&gt; con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_get_handlers.<span class="built_in">find</span>(path) == _get_handlers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	_get_handlers[path](con);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LoginSystem::HandlePost</span><span class="params">(std::string path, std::shared_ptr&lt;HttpConnection&gt; con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_post_handlers.<span class="built_in">find</span>(path) == _post_handlers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	_post_handlers[path](con);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	通过这些，实现了一种简单的事件驱动。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	接下来进行一下这里的整个程序逻辑的简短分析。</p>
<p>​	首先，其简单的启动一个服务器，然后将逻辑转向我们的<code>CServer</code>类，在该类中，我们启动了一个监听套接字并绑定了对应的回调函数。在回调函数中，我们实现了更一步的逻辑转移，将来自客户端的连接转移到对应的<code>HttpConnection</code>中去，由其来进行处理，其内部会进行我们<code>http</code>报文的解析以及<code>http</code>回复报文的构建。在这其中，会存在着来自<code>LoginSystem</code>模块的协助，对应的<code>HttpConnection</code>需要改模块来实现对应的逻辑实现，也就是说，该类进行的操作是一些简单的解析以及逻辑处理的分发。使得各个模块各司其职，逐渐构建其一个健壮的<code>HTTP</code>服务器。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>ResServer</title>
    <url>/2025/06/22/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/4-ResServer/</url>
    <content><![CDATA[<h1 id="ResServer"><a href="#ResServer" class="headerlink" title="ResServer"></a>ResServer</h1><p>本节进行资源服务器的简单分析</p>
<span id="more"></span>



<h2 id="基础逻辑"><a href="#基础逻辑" class="headerlink" title="基础逻辑"></a>基础逻辑</h2><p>​	为了提高一个我们资源服务器的吞吐量，自然而然的，我们需要考虑使用多线程来进行对应的资源服务器的搭建，因为IO操作是耗时的，资源服务器需要将对应的资源持久化到服务器上，那么势必会带有对应的IO操作。如果只是一个单线程的服务器，势必会导致被阻塞，这种吞吐量是很低的。</p>
<p>​	我们考虑一种情况，就是IO操作本身对于OS来说是同步阻塞的，这是由IO操作本身的性质来说的。但是，这并不意味着我们的业务层的感知就一定会是同步阻塞的，我们完全可以通过引入一层间接性来进行这种同步阻塞等待操作往异步操作层面的转换。再次强调一遍，我们这里的操作本质上也还是一个同步阻塞操作，这是一个IO操作的基本性质，我们所能做的不是去修改这个操作的本质，而是在这上面去封装它使得用户层对于调用的感知是一种异步的操作。</p>
<blockquote>
<p>​	具体可以去学习Linux下的5种IO模型，其中有一个特别需要明确的点，<strong>不同IO模型之间是正交的，不是互斥的</strong>。</p>
</blockquote>
<h2 id="实现动机"><a href="#实现动机" class="headerlink" title="实现动机"></a>实现动机</h2><p>​	前面已经多次提到，IO操作本身阻塞的性质无法改变，那么，我们只要在一个线程中发起了一个IO操作请求，那么势必会阻塞当前线程，我们想要实现一种在用户层面异步的感知，我们的关注点就不能关注于这种发起IO操作的线程，而是应该拔高我们的视角。就比如，看到调度这些实际发起IO请求的管理者线程。</p>
<p>​	下面给出将一个IO操作转变为一个异步操作的感知情况。当一个客户端连接请求到来时，我们习惯性的从一个iocontext服务池中去取出一个服务来管理该次连接。在本次会话管理中，假设对应的客户端发起了一次数据包上传请求(可能是要通过聊天来传递多媒体信息，上传自己的头像资源……)，管理着该连接的iocontext服务会接受到这个请求(注意，这种请求是涉及到大量的磁盘IO工作的),如果直接由iocontext服务本身来处理这种IO操作，那么势必会阻塞这个服务本身。那么，在处理当前IO操作的过程中，如果存在新的数据包处理请求到来，或者说，顶层又给当前的iocontext服务分配了一个连接处理的要求，都会因为当前被阻塞了而无法执行，必须等到对应的IO操作实际结束之后才能够处理这些请求，这在拥堵情况下势必会造成很大的时延，这是不可接受的。</p>
<p>​	为了解决一个IO操作阻塞住整个服务的情况，我们自然而然的选择引入一层间接性(间接性在设计中也是一个常客了)。既然在本线程中处理IO请求会导致对应的阻塞，而且这种阻塞不可避免，那么我们就考虑就对应的IO操作给分离出去，让其在别的线程中去进行对应的处理。即一种很平常的思想。在陈硕的<strong>《Linux多线程服务端编程》</strong>一书中有提到这种的相似场景，书中的问题是**多线程程序如何让IO和’计算’相互重叠，降低latency(延迟)**。其中详细的解答了这个问题，值得一读。</p>
<p>​	对于我们这里的场景，我们需要明确一下我们讨论的对象，我们讨论的是一个资源服务器处理一系列IO请求时候的性能问题，实际上，我们在这里存在容易误解的一点，就是在我们实际的聊天服务中，这种多线程其实不一定能够提高对应的一个IO服务的响应时间，考虑一个实际的使用场景，一个客户端在发送对应的文件上传请求后，其需要等待对应的文件处理完成之后的服务器响应，(提前说明，在我们的多线程服务器中，对于一个IO操作，为了简单，我们还是串行的进行的)，对应的响应时间其实是跟对应的单线程服务器中没有什么区别。吗？</p>
<p>​	上面的场景其实是相对于一种特殊情况的，就是并发请求量不高的情况，如果说对应的服务器的并发量是与单线程时候的并发量差不多的情况下，其的提升其实相当有限，或者说甚至是劣化的，其的应用场景实在并发请求数上来之后的处理效率问题。单线程本身其实有一个与生俱来的特性，就是其天生的会限制对应的CPU使用率。在现代化的多核机器中，就比如一个8核机器中，你如果开辟一个单线程服务器，那么无论你如何优化，这个服务器最多只能应用到对应的1&#x2F;8的CPU资源。这里你其实会想，这里的CPU资源的利用率好像跟我们的磁盘IO的使用没关系啊。但是事实真是这样吗？</p>
<p>​	我们强调过，磁盘IO其实本质上是阻塞的，对于一个线程，其一个快照只可能最多存在一个IO请求在运行，这是由磁盘IO的阻塞本质决定的。也就是说，无论你如何优化你的单线程服务器，其每一时刻都只可能发出一个IO请求。那么，我们来考虑使用多线程的情况。对于多线程的情况，即使其每个线程同一时候都只能发出一个IO请求然后被阻塞，但是多个线程那也就意味着会发出多个IO请求。就比如你在一个8核机器上开辟了8个线程，这每个线程都发起了一个IO请求然后阻塞，此时相对于单线程来说也是一个巨大的提高，这也就是多线程给出的优势：<strong>其不是优化一个IO请求的响应时间，而是优化在高并发下的平均IO响应时间</strong>。</p>
<p>​	同时，需要注意这里存在一个边界效应，这个熟悉多线程的应该很了解。就是我们机器的IO资源是有限的，即使你开辟了很多的线程同时发出对应的IO请求，但是对应的总线就那么大，在你逼近对应的边界值时再开辟线程就不仅不会提高平均响应时间，相反，其会开始劣化了，因为存在对应的线程切换的开销，这个需要在各个机器的实际使用环境中去进行测量，需要用数据说话，这里不再赘诉。</p>
<p>​	总结，我们使用多线程来实现一个资源服务器的动机，是为了提高对应的高并发下各个用户的平均响应时间，其本身还是受限于本地机器的性能，对应的耗时IO等瓶颈。但是相对来说，其在现代的多核机器上能够更好的压榨对应的性能。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p><img src="/2025/06/22/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/4-ResServer/d11261708af96149c32f02e5d99a875.png" alt="d11261708af96149c32f02e5d99a875"></p>
<p>​	</p>
<p>​	多线程的第一版逻辑如上图，其对于每个IOcontext，其都是共享一个IO处理的线程池。对于该IO线程池中的每个线程，其都存在着一个暴露给上层的队列，该队列允许外部进行任务的推送，避免因为线程本身的挂起而导致对应的任务丢失。在实际的设计中，这种结构会被封装为一个类，其中的成员变量存在一个消息队列和后台处理线程，之所以是后台处理线程，就是为了避免因为消息队列位于该IO线程上而导致无法接受对应的信息。</p>
<p>​	下面进行一次流程的推演，当用户连接上服务器后，其会被分配一个iocontext进行管理，在本次连接会话中，其可能发出一个传输大文件的请求，就比如4M大小的包，这种大小的包对于TCP来说肯定是会被切包的，最终服务器方的感知就是多个顺序数据包的状态。那么，就需要来对于这些顺序包进行对应的处理，对应的iocontext在收到这些数据的时候，不会对于这些包进行处理，而是进行一层包装，对应的，这里是将一次请求的一个特定属性进行哈希值处理，将其丢到对应的处理文件IO的线程池中去，通过哈希值来取出对应的IO处理线程。接着逐渐将这些顺序包丢到对应的线程的队列中，之后对应的后台处理线程就会逐个从队列中取出数据进行处理，通过队列的串行化保证顺序，避免复杂状态的逻辑维护。这就是这里的多线程的文件IO处理逻辑。</p>
<p>​	在这一版的基础上，还存在另外一半进行了进一步的解耦的逻辑，感兴趣可以自行分析一下，逻辑大致相同，只是为对应的底层的IO处理线程也引入了一层间接性。</p>
<p><img src="/2025/06/22/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/4-ResServer/image-20250622105711721.png" alt="image-20250622105711721"></p>
<p>​	</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>异步日志实现思路</title>
    <url>/2025/07/06/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/6-AsyncLogger/</url>
    <content><![CDATA[<h1 id="AsyncLogger"><a href="#AsyncLogger" class="headerlink" title="AsyncLogger"></a>AsyncLogger</h1><p>本节进行一个异步日志打印组件的实现分析</p>
<span id="more"></span>

<h2 id="实现动机"><a href="#实现动机" class="headerlink" title="实现动机"></a>实现动机</h2><p>本组件是为了避免在一个项目中需要的日志库中，因为使用简单的同步日志打印导致对应的阻塞关键的逻辑操作，即避免由于对于整体项目的日志检测导致的项目整体的性能下降，自然而然想到使用多线程，异步来实现一个异步日志组件来实现对应的日志的记录，避免对应的IO操作的阻塞。</p>
<p>总体需要以下这么几个子功能:</p>
<ul>
<li><p>支持不同的日志级别，日志级别的区分是一个日志组件中所必须的，其能够在后续的使用中区分当前的error级别，以及后续对于日志文件的维护筛选起到很强大的作用</p>
</li>
<li><p>支持日志的模式化输出，一个项目中的所有的日志都应该支持一个统一的格式，这样能够方便后续的审计等操作，而且这种统一的格式能够避免不规范的麻烦</p>
</li>
<li><p>日志最终输出的日志文件名称应该能够一定程度上被自定义，这样在后续对于各个模块的日志区分时可以通过一些工具快速的进行筛选。</p>
</li>
<li><p>日志本身是IO操作，为了避免频繁触发IO导致的用户态与内核态的切换开销，势必需要引入一层缓冲来进行日志数据的缓存，本实现中考虑使用双缓冲或者说多缓冲机制来进行这种日志的缓存。</p>
</li>
</ul>
<h2 id="子组件实现"><a href="#子组件实现" class="headerlink" title="子组件实现"></a>子组件实现</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">LogLevel</span> &#123;</span><br><span class="line">	TRACE,</span><br><span class="line">	DEBUG,</span><br><span class="line">	INFO,</span><br><span class="line">	WARN,</span><br><span class="line">	ERROR_,	<span class="comment">//这个通常存在系统宏冲突，改名进行手动映射</span></span><br><span class="line">	FATAL,</span><br><span class="line">	NUM_LOG_LEVELS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	在日志组件的实现中，一般会使用枚举来实现日志级别的区分，枚举本身能够天然的根据声明的顺序来进行对应的级别筛选。如：声明顺序越往后的对应的级别就越高，对应的整数枚举值就越高，可以方便后续的对应的日志级别的控制。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FixedBuffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="keyword">constexpr</span> std::<span class="type">size_t</span> kBufferSize = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FixedBuffer</span>() :<span class="built_in">cur_</span>(data_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> cur_ - data_; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">avail</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> kBufferSize - <span class="built_in">length</span>(); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, std::<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">avail</span>() &gt; len) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(cur_, data, len);</span><br><span class="line">			cur_ += len;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123; cur_ = data_; &#125;</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">data</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cur_ = data_;</span><br><span class="line">		data_[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bzero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(data_, <span class="number">0</span>, kBufferSize);</span><br><span class="line">		cur_ = data_;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> data_[kBufferSize];	<span class="comment">//本次缓冲区所拥有的大小，暂且固定为4M</span></span><br><span class="line">	<span class="type">char</span>* cur_;					<span class="comment">//当前空闲的位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	一个缓冲区的实现在一个高效的日志组件中是必不可少的，如果一个外部的日志调用就出发一次实际的磁盘写入，那么将会导致对应的IO零碎化，也就是天生的破坏了对应的IO串行。</p>
<p>​	通过使用缓冲区来进行对应的日志的接受，我们能够解耦对应的日志的生成以及实际的日志写入操作。这种解耦能够天然的进行一次填谷的操作，避免由于零碎的日志请求多次触发导致多次陷入内核态与用户态的切换。同时，也能够进行对应的削峰的操作，使得突发的一系列日志请求不会突然压垮内部的线程，实际上是通过将多个零碎的短IO请求合并为一个大的缓冲区的IO写入请求。</p>
<p>​	除此之外，这个日志缓冲区还存在一个非常重要的作用，实际上也是一个最本质的作用，就是其能够保证对应的并发下的日志有序，避免由于并发的操作导致对应多个日志产生的IO流互相交错导致最后产生的日志文件乱码。</p>
<p><img src="/2025/07/06/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/6-AsyncLogger/image-20250706182529952.png" alt="image-20250706182529952"></p>
<p>​	对于一个日志缓冲区，同一时间可能存在多个生成者请求储存对应的日志，此时对应的请求是并行的，如果不对于对应的日志进入缓冲区的顺序进行对应的约束，就会导致最终出现在缓冲区的数据可能是一个乱序的结果，具体可以参考标准C++的cin&#x2F;cout流与传统printf和scanf之间的冲突。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>一个日志的缓冲区需要具有几个重要的性质</p>
<ul>
<li>整个缓冲区的大小</li>
<li>当前缓冲区剩余空间的大小</li>
<li>当前缓冲区已有数据的大小</li>
<li>当前缓冲区中对外的允许数据流入的接口</li>
<li>当前缓冲区中数据可被使用的接口</li>
<li>当前缓冲区可以复用的接口</li>
</ul>
<blockquote>
<p>总结出来其实只有最本质的俩点：</p>
<p>​	当前缓冲区是否还可接受数据，当前缓冲区是否可以使用。</p>
</blockquote>
<p>在本次的实现中，我们使用char定容数组来进行数据的承接，使用cur_指针来指明当前缓冲区内下一个可写字节的地址。通过指针操作来加速各种的已有数据量，剩余容量等的计算。其中大多都是平平无奇的实现，需要结合实际后续对于该缓冲区的使用来进行分析。</p>
<h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><p>​	文件IO类的实现是日志类的核心，其涉及到的是最本质的文件IO的实现，在本次的实现中，考虑该LogFile类只提供最简单的文件IO的接口的封装，不考虑复杂的内部逻辑，提供简洁的API接口让上层去进行排列组合，其实也是一种端到端的思想，如果想要在这个文件IO内部去实现复杂的多线程写入等的逻辑，可能能够在部分场景中带来一些优化，但是实际上却不够通用，所以本次考虑实现的是一个简洁的LogFile类而不是一个完善的LogFile类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogFile</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LogFile</span>(<span class="type">const</span> std::string&amp; basename, std::<span class="type">size_t</span> roll_size)</span><br><span class="line">		:<span class="built_in">basename_</span>(basename), <span class="built_in">roll_size_</span>(roll_size) &#123;</span><br><span class="line">		written_bytes_ = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rollFile</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, std::<span class="type">size_t</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!file_.<span class="built_in">is_open</span>())<span class="built_in">rollFile</span>();</span><br><span class="line">        <span class="keyword">if</span> (written_bytes_+len &gt; roll_size_) &#123;</span><br><span class="line">            <span class="built_in">rollFile</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        file_.<span class="built_in">write</span>(data, len);</span><br><span class="line">        written_bytes_ += len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (file_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">			file_.<span class="built_in">flush</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//重新初始化当前的日志文件</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">rollFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (file_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">			file_.<span class="built_in">close</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		std::string filename = <span class="built_in">getFilename</span>();</span><br><span class="line">		file_.<span class="built_in">open</span>(filename, std::ios::app | std::ios::out);</span><br><span class="line">		written_bytes_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置缓冲区</span></span><br><span class="line">		<span class="keyword">if</span> (file_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">			file_.<span class="built_in">rdbuf</span>()-&gt;<span class="built_in">pubsetbuf</span>(io_buffer_,<span class="built_in">sizeof</span>(io_buffer_));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更具指定的前缀名和当前的时间来生成一个日志文件名</span></span><br><span class="line">	<span class="function">std::string <span class="title">getFilename</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::string filename;</span><br><span class="line">		filename.<span class="built_in">reserve</span>(basename_.<span class="built_in">size</span>() + <span class="number">64</span>);	<span class="comment">//预分配内存大小避免频繁触发扩展</span></span><br><span class="line">		filename = basename_;</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> timebuf[<span class="number">32</span>];</span><br><span class="line">		<span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">tm</span> tm;</span><br><span class="line">		<span class="built_in">localtime_s</span>(&amp;tm, &amp;now);</span><br><span class="line">		<span class="built_in">strftime</span>(timebuf, <span class="built_in">sizeof</span>(timebuf), <span class="string">&quot;.%Y%m%d-%H%M%S&quot;</span>, &amp;tm);</span><br><span class="line">		filename += timebuf;</span><br><span class="line">		filename += <span class="string">&quot;.log&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> filename;</span><br><span class="line">	&#125;</span><br><span class="line">	std::string basename_;	<span class="comment">//打开的文件的基础名称</span></span><br><span class="line">	std::<span class="type">size_t</span> roll_size_;	<span class="comment">//现已写入的文件的大小</span></span><br><span class="line">	<span class="type">size_t</span> written_bytes_;	<span class="comment">//已经写入的文件的大小</span></span><br><span class="line">	std::ofstream file_;	<span class="comment">//输入输出流</span></span><br><span class="line">	<span class="type">char</span> io_buffer_[<span class="number">64</span> * <span class="number">1024</span>];	<span class="comment">//IO缓冲区</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在本次的设计中，考虑一个LogFile类需求如下</p>
<ul>
<li>根据一个简单的用户传来的前缀名能够生成一段唯一标识的名来作为本次日志记录的储存文件名</li>
<li>允许用户能够自定义一次日志文件的最大大小，所有通过该工具类生成的对应的文件不会超过这个大小</li>
<li>当本次日志文件写入会导致对应的文件大小超过最大文件的限制时，需要能够自动进行分文件的写，同时，需要保证对应的文件标识名与本个实例类一致方便维护</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p><strong>需求分析：</strong></p>
<ol>
<li>自动生成唯一文件名。允许用户自定义一个前缀，类内使用当前调用的时间撮进行拼接，最终的文件后缀名为**’.log’**,最终的格式为<code>prefix.yyyymmdd-hhmmss.log</code>，其中<code>prefix</code>为用户指定的前缀，<code>yyyymmdd-hhmmss</code>为当前格式化的时间字符串</li>
<li>我们希望我们当前的文件IO类具有一定的扩展性，即：其能够允许外部实现自己的文件缓冲区，而不是强绑定先前实现的<strong>FixedBuffer</strong>类</li>
<li>自动处理文件过大时的分文件写入操作</li>
<li>该文件工具类应该能够直接最直接的数据强制刷盘，保证外部在崩溃时能够完全的写入一次的日志文件数据。</li>
</ol>
<p>关于上面3点，我们来逐步解决</p>
<p>​	对于第一点的自动生成文件名，其是最容易解决的，由于在本个文件类中我们可能会出现日志文件的分片，所以我们需要持久化对应的前缀名，接下来我们通过调用对应的系统api来获取当前的系统时间，接着对这系列字符串进行拼接(附带.log)得出一个完整的日志文件名即可使用。</p>
<p>​	对于第二点，这个稍微涉及到了接口设计上的规范，一般来说，一个类想要实现一个更加通用的接口，其需要使用的思想不再是面向对象，而是面向过程。如果说，我们使用面向对象的设计，那么该类中会储存一个对应的参数成员，这能够使得更加的内聚，但是一定程度上也限制了对应的扩展性，就比如下面我们设计的数据接口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, std::<span class="type">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	我们的参数类型是<code>const char*</code>，也就意味着所有的基础字符串都可以被该类处理，这也就意味着只要外部传递进来的是一个char* 数组，内部即可处理，不再需要像面向对象中对象类型的强绑定导致的一些约束。就比如，我们前面实现的<strong>FixedBuffer</strong>类，其本身不可以作为参数，但是由于其底层数据储存使用的是<strong>char</strong>*数组，所以可以直接使用内部的数据进行对应的日志打印。</p>
<p>​	这种操作给我带来了一种启发，就是我们想要一个类实现更好的对外的兼容性，我们对应的对外api设计就不能过于OOP化，而是应该更加的面向过程，更加的贴近基础的数据结构&#x2F;数据类型。这样使得在保留原有的功能的同时，外部的封装也是被允许的，而且不会影响到内部的使用，你可以在外部对于数据缓冲区进行各种封装来自定义功能，只要你保证你存在一个最基本的数据接口即可。这正是面向对象和面向过程进行交织所能带来的优雅性。</p>
<p>​	当然，当前的设计虽然提供了一定的可拓展性，但是同时带来了一些心智负担。即，你无法使用现有的常用的数据类型，即string等。但是这个不是问题，你大可通过一个适配器函数来进行对应的调用，一般来说，这种适配器函数需要放置在对应的调用该LogFile类的主类中，通过一层接口来平衡OOP和POP之间的关系，在接口抽象性与复用性之间找到一种权衡。</p>
<p>​	至于第三点，我们在类内维护了多个全局的变量，其一是当前打开的文件已经写入的字节数，其二是外部规定的本次写入所最大的容量。在每次进行append写入时，我们判断当前已经写入的字节数再加上本次要写入的字节数是否大于规定的最大字节数，如果是，我们将会根据当前的时间撮以及先前传进来的前缀来生成一个新的日志文件进行储存。</p>
<p>​	最后，该类文件IO类都应该支持一个强制刷盘的操作，保证外部在崩溃时能够强制把剩余的缓存而未被写入的数据持久化，避免丢失重要数据。具体即是通过显式调用<strong>flush</strong>来实现的。</p>
<hr>
<blockquote>
<p>至此，我们结束了在外面的日志类中俩个关键的子组件的实现，其中<strong>FixedBuffer</strong>主要是对于日志数据的缓存，起到一个削峰填谷，保证有序的作用。而<strong>LogFile</strong>是为了实现一个基本的文件IO持久化的工具，提供基本的分文件以及落盘的操作。下一步，我们就应该来进行我们上层的组合，来实现我们真正的异步日志工具类了。</p>
</blockquote>
<h2 id="异步日志类AsyncLogger"><a href="#异步日志类AsyncLogger" class="headerlink" title="异步日志类AsyncLogger"></a>异步日志类AsyncLogger</h2><p>​	对于本次实现的日志类，我们的基本实现要求是：日志在系统中的全局可用性。在这种驱动下，对应的我们自然而然将该异步日志类实现为一个单例，实际上，可能存在多个模块之间需要单独记录自己的日志的需求等等，不过这不属于本次demo的讨论范围，感兴趣的可以自行实现。</p>
<p>​	为了实现一个全局共享的属性，我们自然考虑使用单例实现日志类，这是基础的内容，我们不再赘诉，主要来分析一下我们该日志类需要具备什么功能。</p>
<ul>
<li>日志类需要通过组合缓冲和文件IO来提供具体的功能，如，通过缓存来承接对应的日志数据，通过文件IO来实现日志的落盘</li>
<li>日志类需要实现异步的操作，避免发出的一个日志请求会阻塞住日志发起的线程，这是本类所需要实现的核心，否则一个同步的日志类不需要我们耗费这么多心神</li>
<li>该日志类应该在一定程度上具有高效性，毕竟对应的日志落盘线程跑满CPU导致其他一些工作线程的挤占</li>
<li>一个日志类不一定需要提供一个外部设置格式化的接口，我们考虑内部约束对应的日志格式来避免允许动态设定日志格式的麻烦</li>
</ul>
<p>​	我们主要注重于本次实现中对于异步的实现和一些个人的优化思路。</p>
<p>​	要想实现日志操作的异步，自然而然的想法就是避免在调用对应的接口时出现直接的写入操作，而是将该类写入操作分配给后台线程进行处理。</p>
<p>​	我的思路如下，每次外部的日志调用，我们在本次调用中将对应的数据格式化后拷贝到该日志类所提供的缓冲区中，然后直接进行返回。在这种外部的不断操作下缓冲区不断被填充知道后续唤醒后台的工作线程来进行一次总的缓冲区内部的数据的IO写入。</p>
<p>​	在这个思路中可以看到，外部的调用会存在一个开销，就是对应的数据格式化以及拷贝的开销，这个后续可以考虑进行分离出一个额外的格式化线程以及格式化缓冲区进行外部线程的压力分担，这里为了简便没有进行实现，不过由于都是内存上的操作所以事实上这个在目前来说理应不会是瓶颈，所以还没有进行实现，感兴趣的可以自行测量性能进行对应的优化。</p>
<p>​	</p>
<p>下面先给出一个实际调用中对应的日志输出在文件中的显示格式</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[2025-07-06 16:01:19.409]</span><span class="section">[23100]</span><span class="section">[INFO]</span><span class="section">[E:\distributedServers\AsyncLogger\PerformanceTester.h:40]</span>Thread 0 Log 0 Msg XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX </span><br></pre></td></tr></table></figure>

<p>其中分为几块内容</p>
<ul>
<li>头部 	包含 [ 时间 ][线程ID][日志级别][调用文件路径:代码所在行数]</li>
<li>内容         包含 用户传入的消息体参数，使用’ ‘进行分割</li>
</ul>
<p>下面为一次日志输出调用时实际调用的函数，注意到其中存在一个formatToBuffer函数，其实际的约束了对应的头部和对应的内容体的消息解析。对应的即使对于本次log调用的可变参数列表的解析</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(LogLevel level, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!running_ || <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(level) &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(min_level_)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//缓冲区满，需要切换缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (current_buffer_-&gt;<span class="built_in">avail</span>() &lt; kMaxLogItemSize) &#123;</span><br><span class="line">		buffers_to_write_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(current_buffer_));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (next_buffer_) &#123;</span><br><span class="line">			current_buffer_ = std::<span class="built_in">move</span>(next_buffer_);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;	<span class="comment">//一般很少走到这里</span></span><br><span class="line">			current_buffer_ = std::<span class="built_in">make_unique</span>&lt;FixedBuffer&gt;();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//通知后台线程进行处理，注意这里的调用的场景</span></span><br><span class="line">		cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	formatToBuffer(level, file, line, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>下面来分析对应的格式化操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">formatToBuffer</span><span class="params">(LogLevel level, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 添加日志头 [时间][线程ID][日志级别][文件:行号]</span></span><br><span class="line">	formatHeader(level, file, line);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//处理每个参数，使用折叠表达式</span></span><br><span class="line">	(formatArg(std::forward&lt;Args&gt;(args)), ...);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//每条日志单独一行</span></span><br><span class="line">	current_buffer_-&gt;<span class="built_in">append</span>(<span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在本次顶层调用中，对应的参数的职责分类其实很明显，前三个参数都是交由头部来进行解析，用于基本的日志格式约束，实际上，我们的设计中这前三个参数都是由系统内部来自动进行填充，不会交由用户来自行进行传递的。</p>
<p>​	接着是对于可变参数列表的解析，本次设计中利用了<strong>C++17</strong>中对于可变参数列表的折叠表达式的支持，避免了复杂的解析，同时我们还约束了事实上每一条日志在缓冲区内的位置，即，每条日志独立的占据文件的一行，这是一个很好的规范。</p>
<p>​	接下来考虑对应的头部和可变参数列表的格式化操作，先来看头部的解析操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">formatHeader</span><span class="params">(LogLevel level, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">	<span class="keyword">auto</span> since_epoch = now.<span class="built_in">time_since_epoch</span>();</span><br><span class="line">	<span class="keyword">auto</span> secs = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(since_epoch);</span><br><span class="line">	<span class="keyword">auto</span> ms = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(since_epoch - secs);</span><br><span class="line">	</span><br><span class="line">	<span class="type">time_t</span> t = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tm</span> tm_time;</span><br><span class="line">	<span class="built_in">localtime_s</span>(&amp;tm_time, &amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> time_buf[<span class="number">64</span>];	</span><br><span class="line">	<span class="type">size_t</span> len = <span class="built_in">snprintf</span>(time_buf,<span class="built_in">sizeof</span>(time_buf),</span><br><span class="line">		<span class="string">&quot;[%04d-%02d-%02d %02d:%02d:%02d.%03d]&quot;</span>, </span><br><span class="line">		tm_time.tm_year + <span class="number">1900</span>, tm_time.tm_mon + <span class="number">1</span>, tm_time.tm_mday,</span><br><span class="line">		tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec,</span><br><span class="line">		<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(ms.<span class="built_in">count</span>()));</span><br><span class="line"></span><br><span class="line">	current_buffer_-&gt;<span class="built_in">append</span>(time_buf, len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加线程ID</span></span><br><span class="line">	std::ostringstream tid_ss;</span><br><span class="line">	tid_ss &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">	std::string tid_str = tid_ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> tid_buf[<span class="number">64</span>];</span><br><span class="line">	<span class="type">size_t</span> tid_len = <span class="built_in">snprintf</span>(tid_buf, <span class="built_in">sizeof</span>(tid_buf), <span class="string">&quot;[%s]&quot;</span>, tid_str.<span class="built_in">c_str</span>());</span><br><span class="line">	current_buffer_-&gt;<span class="built_in">append</span>(tid_buf, tid_len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加日志级别</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* level_str = <span class="built_in">levelToString</span>(level);</span><br><span class="line">	<span class="type">char</span> level_buf[<span class="number">32</span>];</span><br><span class="line">	len = <span class="built_in">snprintf</span>(level_buf, <span class="built_in">sizeof</span>(level_buf), <span class="string">&quot;[%s]&quot;</span>, level_str);</span><br><span class="line">	current_buffer_-&gt;<span class="built_in">append</span>(level_buf, len);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> file_line_buf[<span class="number">256</span>];</span><br><span class="line">	len = <span class="built_in">snprintf</span>(file_line_buf, <span class="built_in">sizeof</span>(file_line_buf), <span class="string">&quot;[%s:%d]&quot;</span>, file, line);</span><br><span class="line">	current_buffer_-&gt;<span class="built_in">append</span>(file_line_buf, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	对于整个头部的解析，我们可以简单的总结为三板斧：格式化出对应的实际日志中需要的字符串，计算该字符串所需要的长度，填充中预留的缓冲区中并继续拷贝到实际的日志buffer中。该头部格式化和对应的单个参数格式化都是该三板斧，没什么好讲的，下面给出单个参数的解析。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">formatArg</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//类型特化处理，避免运行时的类型检查</span></span><br><span class="line">	<span class="comment">//数字类型统一为32位大小</span></span><br><span class="line">	<span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_arithmetic_v&lt;std::<span class="type">decay_t</span>&lt;T&gt;&gt;)</span> </span>&#123;</span><br><span class="line">		<span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">		<span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;std::<span class="type">decay_t</span>&lt;T&gt;&gt;)</span> </span>&#123;</span><br><span class="line">			<span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%ld&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(arg));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%f&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(arg));</span><br><span class="line">		&#125;</span><br><span class="line">		current_buffer_-&gt;<span class="built_in">append</span>(buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_convertible_v &lt;T, std::string_view&gt;) &#123;</span><br><span class="line">		std::string_view sv = arg;</span><br><span class="line">		current_buffer_-&gt;<span class="built_in">append</span>(sv.<span class="built_in">data</span>(), sv.<span class="built_in">size</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//通用类型处理</span></span><br><span class="line">		std::ostringstream os;</span><br><span class="line">		os &lt;&lt; arg;</span><br><span class="line">		<span class="keyword">auto</span> str = os.<span class="built_in">str</span>();</span><br><span class="line">		current_buffer_-&gt;<span class="built_in">append</span>(str.<span class="built_in">data</span>(), str.<span class="built_in">size</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加分割符</span></span><br><span class="line">	current_buffer_-&gt;<span class="built_in">append</span>(<span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​	现在，我们了解了实际的一次日志格式化的流程，回到对应的外部的<strong>log</strong>调用，我们来分析一下此处的逻辑实现。在本次日志打印接口的实现中，我们考虑实现一种双缓冲(多缓冲)的思路来优化对应的缓冲实现，简述如下：</p>
<p>​	在AsyncLogger的主线程中，我们同一时间着俩个缓冲区，其中一个是<code>current_buffer_</code>，另外一个是<code>next_buffer_</code>。对于这俩个buffer，本质上都是相同的，但是其的工作地位不同，为了起到双缓冲的作用，我们会在每次log调用时去判断<code>current_buffer_</code>中的剩余控件是否比设定中最大的日志长度(本次设计中为4kb)还要小，如果剩余空间小于当前这个长度，那么我们就认定为当前的buffer已满，其应该也能够被后台的线程去工作持久化到磁盘中去。所以我们在本次的log中就进行对应的log所使用的buffer的切换。在这个过程中，我们实现了俩个重要动作：1.实现了当前承接数据的缓冲区的切换，将对应的已满的缓冲区推入到后台线程的工作队列中去；2.通知后台线程开始工作，这个动作会使得工作完成后刷新现有的缓冲区，并在一定程度上能够实现内存复用(后续分析)</p>
<p>​	具体的即是通过下面这段代码实现的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (current_buffer_-&gt;<span class="built_in">avail</span>() &lt; kMaxLogItemSize) &#123;</span><br><span class="line">	buffers_to_write_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(current_buffer_));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (next_buffer_) &#123;</span><br><span class="line">		current_buffer_ = std::<span class="built_in">move</span>(next_buffer_);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;	<span class="comment">//一般很少走到这里</span></span><br><span class="line">		current_buffer_ = std::<span class="built_in">make_unique</span>&lt;FixedBuffer&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h3><p>​	接下来进入到本个日志类的重中之重，<strong>后台工作线程</strong>。</p>
<p>​	预先分析一下该线程存在的动机，该线程的动机</p>
<ul>
<li>消费前台生成出来的大块日志缓冲区</li>
<li>修改对应的缓冲区状态，实现内存复用</li>
</ul>
<p>​	下面给出对应的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(start_mutex_)</span></span>;</span><br><span class="line">		thread_ready_ = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	start_cond_.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function">LogFile <span class="title">output</span><span class="params">(basename_, roll_size_)</span></span>;</span><br><span class="line">	BufferPtr new_buffer1 = std::<span class="built_in">make_unique</span>&lt;FixedBuffer&gt;();</span><br><span class="line">	BufferPtr new_buffer2 = std::<span class="built_in">make_unique</span>&lt;FixedBuffer&gt;();</span><br><span class="line">	new_buffer1-&gt;<span class="built_in">bzero</span>();</span><br><span class="line">	new_buffer2-&gt;<span class="built_in">bzero</span>();</span><br><span class="line"></span><br><span class="line">	BufferVector buffers_to_write;	<span class="comment">//临时的交换，一次性取出全部的任务</span></span><br><span class="line">	buffers_to_write.<span class="built_in">reserve</span>(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (running_.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">			<span class="keyword">if</span> (buffers_to_write.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				cond_.<span class="built_in">wait_for</span>(lock,</span><br><span class="line">					std::chrono::<span class="built_in">seconds</span>(flush_interval_),</span><br><span class="line">					[<span class="keyword">this</span>]() &#123;</span><br><span class="line">						<span class="keyword">return</span> !buffers_to_write_.<span class="built_in">empty</span>() || !running_;</span><br><span class="line">					&#125;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (current_buffer_-&gt;<span class="built_in">length</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				buffers_to_write_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(current_buffer_));</span><br><span class="line">				current_buffer_ = std::<span class="built_in">move</span>(new_buffer1);</span><br><span class="line">			&#125;</span><br><span class="line">			buffers_to_write.<span class="built_in">swap</span>(buffers_to_write_);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!next_buffer_ &amp;&amp; new_buffer2) &#123;</span><br><span class="line">				next_buffer_ = std::<span class="built_in">move</span>(new_buffer2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; buffer : buffers_to_write) &#123;</span><br><span class="line">			<span class="keyword">if</span> (buffer-&gt;<span class="built_in">length</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				output.<span class="built_in">append</span>(buffer-&gt;<span class="built_in">data</span>(), buffer-&gt;<span class="built_in">length</span>());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//重置缓冲区，复用内存</span></span><br><span class="line">		<span class="keyword">if</span> (!new_buffer1) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!buffers_to_write.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				new_buffer1 = std::<span class="built_in">move</span>(buffers_to_write.<span class="built_in">back</span>());</span><br><span class="line">				buffers_to_write.<span class="built_in">pop_back</span>();</span><br><span class="line">				new_buffer1-&gt;<span class="built_in">reset</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				new_buffer1 = std::<span class="built_in">make_unique</span>&lt;FixedBuffer&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!new_buffer2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!buffers_to_write.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				new_buffer2 = std::<span class="built_in">move</span>(buffers_to_write.<span class="built_in">back</span>());</span><br><span class="line">				buffers_to_write.<span class="built_in">pop_back</span>();</span><br><span class="line">				new_buffer2-&gt;<span class="built_in">reset</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				new_buffer2 = std::<span class="built_in">make_unique</span>&lt;FixedBuffer&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		buffers_to_write.<span class="built_in">clear</span>();</span><br><span class="line">		output.<span class="built_in">flush</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//程序退出前刷新剩余日志</span></span><br><span class="line">	<span class="built_in">flushAll</span>();</span><br><span class="line">	output.<span class="built_in">flush</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在该后台线程的初始化过程中，我们省略几个无关紧要的内容，主要在于内部的逻辑处理以及怎么实现内存的复用提高性能。</p>
<p>​	在该线程函数栈中，我们初始化了多个基础组件，文件IO组件，缓冲区组件等。在实际的进入对应的<strong>while</strong>循环体处理逻辑逻辑后，我们首先对于现有的任务队列<strong>buffers_to_write</strong>的状态进行查询，如果为空，则进入条件变量开始等待被唤醒。否则，我们将把当前快照下的所有的日志数据都压入任务队列中，具体的则是以下实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (current_buffer_-&gt;<span class="built_in">length</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			buffers_to_write_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(current_buffer_));</span><br><span class="line">				current_buffer_ = std::<span class="built_in">move</span>(new_buffer1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	通过这样，我们获取了当前系统中所有等待打印的数据，在当前所有的日志任务都存在对应的队列之后，我们使用栈内对象将其移动出来，然后函数将离开锁的临界区。此时接下来我们会将该日志类中用于接受数据的<code>current_buffer_</code>赋予其一个全新的缓冲区，此时可能是新建的缓冲区，也可能是后续被复用的缓冲区。但是无论如何，我们保证该缓冲区一定有效。</p>
<p>​	再接下来，函数的逻辑离开了对应的临界区，此时对应的任务队列为空，锁被释放，缓冲区为全新的状态，外部的日志写可以与后台进行并发进行。</p>
<p>​	在后台函数体内，在交换了对应的任务队列之后，其开始进行处理，具体的则是遍历当前队列中的每一个任务。若其的长度非0(即内容有效)，那么就通过对应的文件流进行对应的日志的写入，由于对应的整个IO操作位于一个循环体内，所以相对来说可以利用对应的IO串行的性能。</p>
<p>​	在完成了任务队列中的所有的任务之后，我们开始对于整个后台线程的函数栈进行一次重置。具体的，就是如果存在先前俩个预创建的buffer为空，则从对应的该线程函数栈中的临时工作队列弹出任务节点，并清空后赋值给对应的原先的俩个成员实现一种初始化，此时可能存在多余的任务节点，可能是由于先前的某个时刻的并发压力导致的创建的多任务节点，我们这里的设计是简单的丢弃，后续可以考虑进一步的复用，但是个人感觉在此栈上留存俩个buffer已经足够，留存过多会导致栈帧过于庞大。</p>
<p>​	最后就是在线程退出时的行为，需要了解的是，我们的文件IO使用的是<strong>ofstream</strong>流，实际上也可能存在数据的缓存，为了避免一些重要数据的丢失，我们应该在线程退出时确保所有的数据都已经落盘，避免一些数据丢失带来的麻烦。</p>
<p>​	</p>
<p>​	总结，在本次后台工作IO线程中，我们实现了一定程度上的缓冲区的内存复用，虽然实际上可能会存在生成者与消费者之间速率失衡导致的缓冲区被频繁创建导致的栈帧的不断庞大，这是之后需要优化的一个方向。</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>​	对于本异步日志类，个人进行了一个基础的性能测试，主要是在不同线程下对应的日志落盘的效率时间，意料之外情理之中的是，目前这个异步日志工具类在多线程的环境下对应的性能劣化严重，如下</p>
<table>
<thead>
<tr>
<th>Threads</th>
<th>LogsPerThread</th>
<th>TotalLogs</th>
<th>Time(s)</th>
<th>Throughput(logs&#x2F;s)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10000</td>
<td>10000</td>
<td>0.0473013</td>
<td>211411</td>
</tr>
<tr>
<td>2</td>
<td>10000</td>
<td>20000</td>
<td>0.103107</td>
<td>193974</td>
</tr>
<tr>
<td>4</td>
<td>10000</td>
<td>40000</td>
<td>0.303058</td>
<td>131988</td>
</tr>
<tr>
<td>8</td>
<td>10000</td>
<td>80000</td>
<td>0.743923</td>
<td>107538</td>
</tr>
</tbody></table>
<p>​	当前的设计在当线程写入的情况下表现良好，能够达到将近<strong>21klogs&#x2F;s</strong>的量级，这个性能相对来说也是够用的了，不过在多线程并发下，对应的<strong>TotalLogs</strong>上来后，对应的吞吐量下降，我个人的猜测是因为在现有的设计中，由于只存在一个后台线程，对应的处理效率上不来，而且在并发量高的情况下会花费更多的事件在缓冲区的创建下，这也是由于后台的工作线程速率上不来导致数据堆积。所以后续应该考虑在多线程的情况下优化线程模型，使用线程池来进行对应的日志数据的收集，而不是现在的统一小<strong>buffer</strong>管道导致对应的瓶颈。</p>
<p>​	所以，接下来的进一步的优化方向是：</p>
<ul>
<li>优化多线程模型下的日志数据收集方式，使用别的方式来替代现有的统一的流入小<strong>FixedBuffer</strong>中，将<strong>FixedBuffer</strong>大小扩大并不是解决之策，我们需要使用别的方式，就比如线程池，或者说缓存池来缓解当前多线程的数据接受瓶颈</li>
<li>优化异步日志类的消费者线程，当前的消费者线程只存在一个，对应的IO操作都由一条<strong>fstream</strong>管道来进行流入，这在一定程度上限制了对应的处理速率，但是这是现有的日志模型的限制，即一个日志类同一时间只能写入一个文件。如果存在别的应用场景，可以考虑优化这里的单消费者模型，可能扩展到多消费者?</li>
</ul>
<h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><p>​	锁的使用并不是一个设计的性能瓶颈，锁的竞争才是瓶颈，在本次的设计中，对应的后台线程与对应的前台的<strong>log</strong>调用会涉及同一个锁的竞争来保护当前<strong>buffer</strong>的使用，这个会导致双方的各自多个方面围绕这个锁相互影响，我们对应的优化操作应该集中于这种临界区的优化。就比如，这里一次的后台线程调用会将当前类中所有的任务一次性的取出，减少遍历以及单独的取出操作的开销等等。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>GateServer Review</title>
    <url>/2025/04/27/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/3-GateServerReview/</url>
    <content><![CDATA[<h1 id="GateServer"><a href="#GateServer" class="headerlink" title="GateServer"></a>GateServer</h1><p>​	在该栏目中，我将会对于我的项目中的服务器进行一次review，在review中去重新回顾我的服务器架构来巩固我对于一个服务器设计上的理解，话不多说，直接开始。</p>
<span id="more"></span>

<p>​	</p>
<h2 id="项目流程"><a href="#项目流程" class="headerlink" title="项目流程"></a>项目流程</h2><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>​	在该文中，进行对应的网关服务器<code>GateServer</code>的分析。在该服务器中，首先会在一个main入口处启动一个<code>io_context</code>上下文，该上下文是我们对应的主监听线程所使用的上下文。我们使用该上下文来初始化我们的监听类<code>CServer</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp; gCfgMgr=ConfigMgr::<span class="built_in">Inst</span>() ;</span><br><span class="line">std::string gate_port_str = gCfgMgr[<span class="string">&quot;GateServer&quot;</span>][<span class="string">&quot;Port&quot;</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> gate_port = <span class="built_in">atoi</span>(gate_port_str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;(<span class="number">8080</span>);</span><br><span class="line">net::io_context ioc&#123; <span class="number">1</span> &#125;;</span><br><span class="line">boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(ioc, SIGINT, SIGTERM)</span></span>;</span><br><span class="line">signals.<span class="built_in">async_wait</span>([&amp;ioc](<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">int</span> signal_number) &#123;</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ioc.<span class="built_in">stop</span>();</span><br><span class="line">&#125;);</span><br><span class="line">std::<span class="built_in">make_shared</span>&lt;CServer&gt;(ioc, port)-&gt;<span class="built_in">Start</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;GateServer listen the port &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">ioc.<span class="built_in">run</span>();</span><br></pre></td></tr></table></figure>

<p>​	在初始化好之后，程序启动我们的CServer的函数，该函数保证了单一职责原则，只负责了整个服务器的连接监听工作，在客户端连接到来时，其会创建一个<code>HttpConnection</code>对象，该对象是我们的网关服务器中负责一个连接处理的一个基本单位，起到一个类似于<code>Session</code>的作用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; io_context = AsioIOServicePool::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetIOService</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用智能指针管理每个新的 socket</span></span><br><span class="line">	<span class="comment">//auto new_socket = std::make_shared&lt;tcp::socket&gt;(_ioc);</span></span><br><span class="line">    std::shared_ptr&lt;HttpConnection&gt; new_con = std::<span class="built_in">make_shared</span>&lt;HttpConnection&gt;(io_context);</span><br><span class="line"></span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(new_con-&gt;<span class="built_in">GetSocket</span>(), [self, new_con](beast::error_code ec) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//出错放弃该连接并监听其他连接</span></span><br><span class="line">			<span class="keyword">if</span> (ec) &#123;</span><br><span class="line">				<span class="comment">//self-&gt;Start();</span></span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;Accept error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//创建新连接，并且创建HttpConnection管理该连接</span></span><br><span class="line">			<span class="comment">//std::make_shared&lt;HttpConnection&gt;(std::move(self-&gt;_socket))-&gt;Start();</span></span><br><span class="line">            new_con-&gt;<span class="built_in">Start</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//继续监听</span></span><br><span class="line">			self-&gt;<span class="built_in">Start</span>();</span><br><span class="line"></span><br><span class="line">		&#125;<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">			std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	在该函数中，我们创建了对应的连接请求到达时的回调函数，类会创建一个新的HttpConnection对象，并通过对其属性的一些设置之后启动Start函数来进行我们本次连接的处理。提前注意，我们的该函数是一个异步的行为，利用了一下对应的底层事件异步机制来进行我们的单线程的性能的压榨。接下来我们进入对应的<code>HttpConnection</code>处理逻辑。</p>
<h2 id="HttpConnection"><a href="#HttpConnection" class="headerlink" title="HttpConnection"></a>HttpConnection</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConnection::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	http::<span class="built_in">async_read</span>(_socket, _buffer, _request, [self](beast::error_code ec,std::<span class="type">size_t</span> bytes_transferred) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (ec) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;Http read error is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			boost::<span class="built_in">ignore_unused</span>(bytes_transferred);</span><br><span class="line">            <span class="comment">//这里应该保证该计时器的启动位于下面的程序处理逻辑之前</span></span><br><span class="line">            <span class="comment">//避免出现一种数据都发送完了你才启动计时器的可笑情况</span></span><br><span class="line">            self-&gt;<span class="built_in">CheckDeadline</span>();</span><br><span class="line">			self-&gt;<span class="built_in">HandleReq</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; ec) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;exception is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在该方法中，我们使用beast封装好的功能进行对应的事件处理。首先还是存在着异步的机制，不阻塞当前的逻辑。这点是我们之前的能够实现迅速的恢复监听的基础。当然，这里可能会存在一种严重的线程饥饿问题，可以自己分析一下。</p>
<p>​	我们来回顾一下在<code>beast</code>库中需要注意的几个点。由于我们使用的这个库是一个面向HTTP协议封装好的框架，所以我们使用了对应的async_read函数来进行我们的协议头的读取，同时我们保证了一个缓冲区能够缓存住我们一个来自客户端的请求包，这是在外面的客户端设计决定的，我们的客户端设计中发送的HTTP始终不会太大，至少现在来说不会超过我们设计的缓冲区大小。因此，我们直接简单的使用</p>
<p><code>http::async_read(_socket, _buffer, _request, [self](beast::error_code ec,std::size_t bytes_transferred&#123;...&#125;);</code></p>
<p>来辅助我们实现对于HTTP传输过来的数据的处理。略过对应的处理模式，我们接下来看我们的逻辑分发。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConnection::HandleReq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//设置回答的版本，关于HTTP回答头的部分通用属性</span></span><br><span class="line">        _response.<span class="built_in">version</span>(_request.<span class="built_in">version</span>());</span><br><span class="line">        _response.<span class="built_in">keep_alive</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (_request.<span class="built_in">method</span>() == http::verb::get) &#123;</span><br><span class="line">            <span class="built_in">PreParseGetParam</span>();</span><br><span class="line">            <span class="comment">//我们的LoginSystem中预先注册了一些URL所匹配的事务，如果没有，则会返回false</span></span><br><span class="line">            <span class="type">bool</span> success = LoginSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">HandleGet</span>(_get_url, <span class="built_in">shared_from_this</span>());</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                _response.<span class="built_in">result</span>(http::status::not_found);</span><br><span class="line">                _response.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;type/plain&quot;</span>);</span><br><span class="line">                beast::<span class="built_in">ostream</span>(_response.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;url not found\r\n&quot;</span>;</span><br><span class="line">                <span class="built_in">WriteResponse</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _response.<span class="built_in">result</span>(http::status::ok);</span><br><span class="line">            _response.<span class="built_in">set</span>(http::field::server, <span class="string">&quot;GateServer&quot;</span>);</span><br><span class="line">            <span class="built_in">WriteResponse</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_request.<span class="built_in">method</span>() == http::verb::post) &#123;</span><br><span class="line">            <span class="type">bool</span> success = LoginSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">HandlePost</span>(_request.<span class="built_in">target</span>(), <span class="built_in">shared_from_this</span>());</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[DEBUG] HandlePost success: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; success &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">if</span> (!success) </span><br><span class="line">            &#123;</span><br><span class="line">                _response.<span class="built_in">result</span>(http::status::not_found);</span><br><span class="line">                _response.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;type/plain&quot;</span>);</span><br><span class="line">                beast::<span class="built_in">ostream</span>(_response.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;url not found\r\n&quot;</span>;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[HttpConnection] response&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">WriteResponse</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[HttpConnection] response&quot;</span> &lt;&lt; endl;</span><br><span class="line">            _response.<span class="built_in">result</span>(http::status::ok);</span><br><span class="line">            _response.<span class="built_in">set</span>(http::field::server, <span class="string">&quot;GateServer&quot;</span>);</span><br><span class="line">            <span class="built_in">WriteResponse</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception caught in HandleReq: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        _response.<span class="built_in">result</span>(http::status::internal_server_error);</span><br><span class="line">        _response.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        beast::<span class="built_in">ostream</span>(_response.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;internal server error\r\n&quot;</span>;</span><br><span class="line">        <span class="built_in">WriteResponse</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在解析完对应的头部数据之后，我们开始进行我们的服务器逻辑处理。简单来看，我们会根据我们解析出来的HTTP头部中的方法类型来进行我们的逻辑分发。对应的其实是通过我们更底层的字模块<code>LoginSystem</code>中编写的事件驱动逻辑来进行处理的。在这里，我们传递了对应的URL资源符和我们本次会话的对象本身过去交予处理。在这里，其实可以进行优化，在后续的服务器中，其实存在着一种更加优雅的模块调用逻辑，遇到再说吧。接下来我们来看对应的模块调用逻辑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LoginSystem::HandlePost</span><span class="params">(std::string path, std::shared_ptr&lt;HttpConnection&gt; con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_post_handlers.<span class="built_in">find</span>(path) == _post_handlers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[LoginSystem] 成功处理请求&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	_post_handlers[path](con);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	我们在对应的<code>HttpConnection</code>调用的函数逻辑其实只是一层代理，用于更加底层的一层逻辑的调用。</p>
<p>​	</p>
<h2 id="LoginSystem"><a href="#LoginSystem" class="headerlink" title="LoginSystem"></a>LoginSystem</h2><p>​	接下来我们对于我们的<code>LoginSystem</code>模块进行分析</p>
<p>​	该类我们使用单例来进行设计，事实上，很多设计网络功能的模块的设计都是使用的单例。目的是实现重用，避免重复创建的开销。在该类中，我们使用一种类似的事件注册和事件驱动的机制来提供我们的功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(std::shared_ptr&lt;HttpConnection&gt;)&gt;HttpHandler;</span><br><span class="line">std::map&lt;std::string, HttpHandler&gt;_post_handlers;</span><br><span class="line">std::map&lt;std::string, HttpHandler&gt; _get_handlers;</span><br></pre></td></tr></table></figure>

<p>​	这是我们的事件容器，使用一个接口来进行注册的事件的统一，由于我们的键值对中的值根本上是一个可调用对象，所以我们可以通过键来取出对应的值并提供对应的参数来实现我们的功能以此来实现我们的事件驱动。</p>
<p>​	接下来我们简单来分析一个我们注册的事件来了解我们本类的实际功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LoginSystem::RegPost</span><span class="params">(std::string url, HttpHandler handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_post_handlers.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(url, handler));</span><br><span class="line">&#125;</span><br><span class="line">#-----------------------------------------------------------------------</span><br><span class="line"><span class="built_in">RegPost</span>(<span class="string">&quot;/reset_pwd&quot;</span>, [](std::shared_ptr&lt;HttpConnection&gt; connection) &#123;</span><br><span class="line">    <span class="comment">//使用beast和buffer和json来进行对应数据的接受和处理</span></span><br><span class="line">    <span class="keyword">auto</span> body_str = boost::beast::<span class="built_in">buffers_to_string</span>(connection-&gt;_request.<span class="built_in">body</span>().<span class="built_in">data</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;receive body is &quot;</span> &lt;&lt; body_str &lt;&lt; std::endl;</span><br><span class="line">    connection-&gt;_response.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/json&quot;</span>);</span><br><span class="line">    Json::Value root;</span><br><span class="line">    Json::Reader reader;</span><br><span class="line">    Json::Value src_root;</span><br><span class="line">    <span class="comment">//将body_str解析到src_root中</span></span><br><span class="line">    <span class="type">bool</span> parse_success = reader.<span class="built_in">parse</span>(body_str, src_root);</span><br><span class="line">    <span class="keyword">if</span> (!parse_success) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to parse JSON data!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        root[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Error_Json;</span><br><span class="line">        std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">        beast::<span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出对应的数据</span></span><br><span class="line">    <span class="keyword">auto</span> email = src_root[<span class="string">&quot;email&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">    <span class="keyword">auto</span> name = src_root[<span class="string">&quot;user&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">    <span class="keyword">auto</span> pwd = src_root[<span class="string">&quot;passwd&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要先查找对应的验证码是否与输入也就是传输过来的验证码一直</span></span><br><span class="line">    std::string varify_code;</span><br><span class="line">    <span class="type">bool</span> b_get_varify = RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Get</span>(CODEPREFIX + src_root[<span class="string">&quot;email&quot;</span>].<span class="built_in">asString</span>(), varify_code);</span><br><span class="line">    <span class="keyword">if</span> (!b_get_varify) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; get varify code expired&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        root[<span class="string">&quot;error&quot;</span>] = ErrorCodes::VarifyExpired;</span><br><span class="line">        std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">        beast::<span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (varify_code != src_root[<span class="string">&quot;varifycode&quot;</span>].<span class="built_in">asString</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; varify code error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        root[<span class="string">&quot;error&quot;</span>] = ErrorCodes::VarifyCodeErr;</span><br><span class="line">        std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">        beast::<span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询数据库判断用户名和邮箱是否匹配</span></span><br><span class="line">    <span class="type">bool</span> email_valid = MysqlMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">CheckEmail</span>(name, email);</span><br><span class="line">    <span class="keyword">if</span> (!email_valid) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; user email not match&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        root[<span class="string">&quot;error&quot;</span>] = ErrorCodes::EmailNotMatch;</span><br><span class="line">        std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">        beast::<span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新密码为最新密码</span></span><br><span class="line">    <span class="type">bool</span> b_up = MysqlMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">UpdatePwd</span>(name, pwd);</span><br><span class="line">    <span class="keyword">if</span> (!b_up) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; update pwd failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        root[<span class="string">&quot;error&quot;</span>] = ErrorCodes::PasswdUpFailed;</span><br><span class="line">        std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">        beast::<span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;succeed to update password&quot;</span> &lt;&lt; pwd &lt;&lt; std::endl;</span><br><span class="line">    root[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">    root[<span class="string">&quot;email&quot;</span>] = email;</span><br><span class="line">    root[<span class="string">&quot;user&quot;</span>] = name;</span><br><span class="line">    root[<span class="string">&quot;passwd&quot;</span>] = pwd;</span><br><span class="line">    root[<span class="string">&quot;varifycode&quot;</span>] = src_root[<span class="string">&quot;varifycode&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">    std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">    beast::<span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	首先我们需要明确一点，该可调用对象由于其的定义在被调用时其会存在着额外的俩个参数，一个是调用的该对象的连接对象，我们可以使用该链接对象来进行我们的一些操作，最直接的就是使用对应的成员，实际上，我们声明了本模块类为我们的会话连接类的友元，所以可以看到在这里对于私有成员对象的读取操作。这是很便捷的。避免一些复杂逻辑的编写。</p>
<p>​	接着我们来注重于内部的逻辑实现。由于我们前面通过代理来实现了本次需要执行的逻辑的分流，在我们的这个示例中，我们需要做的是对于密码的重置。在逻辑的一开始，我们进行了一些接下来需要使用的内容的初始化，我们取出了对应的会回答给客户端套接字的<code>HTTP</code>回复结构体来构建我们的缓冲区。接下来我们的所有回答操作直接写入该结构中即可。最后再由上层自由控制发送。又起到一层职责分离的作用。</p>
<p>​	除此之外，我再补充一点，在本项目中，基本所有的<code>LoginSystem</code>会处理到的数据都是以<code>JSON</code>格式传输过来的。这是我们双端的规定。对应与<code>/reset_pwd</code>请求，我们在客户端报文中发送了对应的邮箱，用户名和密码过来，通过使用<code>JSON</code>自带的解析器进行简单的解析与使用。再然后，我们开始在这一层去陷入更深的逻辑中去。我们这里像之前的<code>HttpConnection</code>陷入<code>LoginSystem</code>模块一样，陷入了一系列的模块。包括但不限于<code>RedisMgr</code>模块，<code>MysqlMgr</code>模块，这些不再进行分析，对应的逻辑其实跟这里的陷入逻辑没有什么不同，在该层中，由于我们较为良好的设计，我们可以将深层的子模块看做为更多的子黑盒，直接调用对应的功能即可。</p>
<p>​	在一层层的子模块的陷入又返回之后，我们的该层会根据最终的逻辑来确定我们的回复报文中到底需要写入什么逻辑，然后进行对应的写入然后逐层的退出。</p>
<p>​	在最后，该<code>LoginSystem</code>层将会彻底退出，我们的程序逻辑将会回退到我们的<code>HttpConnection</code>层</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_request.<span class="built_in">method</span>() == http::verb::post) &#123;</span><br><span class="line">    <span class="type">bool</span> success = LoginSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">HandlePost</span>(_request.<span class="built_in">target</span>(), <span class="built_in">shared_from_this</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[DEBUG] HandlePost success: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; success &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (!success) </span><br><span class="line">    &#123;</span><br><span class="line">        _response.<span class="built_in">result</span>(http::status::not_found);</span><br><span class="line">        _response.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;type/plain&quot;</span>);</span><br><span class="line">        beast::<span class="built_in">ostream</span>(_response.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;url not found\r\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[HttpConnection] response&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">WriteResponse</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[HttpConnection] response&quot;</span> &lt;&lt; endl;</span><br><span class="line">    _response.<span class="built_in">result</span>(http::status::ok);</span><br><span class="line">    _response.<span class="built_in">set</span>(http::field::server, <span class="string">&quot;GateServer&quot;</span>);</span><br><span class="line">    <span class="built_in">WriteResponse</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	例如，在陷入又返回之后，我们会逐层的逻辑推动，到最后，我们始终会执行一个 <code>WriteResponse();</code>函数，该函数的功能就是调用一次我们的<code>http::async_write</code>方法，将我们在逐层的调用中产生的回复报文写回到我们的通信套接字中，由于我们是HTTP连接，此时底层自动推送该报文回去给客户端。同时，由于我们采取的是一个短连接的形式，所以该<code>HttpConnection</code>对象也会在不久之后被销毁，一次会话行为结束，对应的在这同步过程中积攒的更多的连接可以被处理。自此，程序实现一种闭环。通过不断处理客户端请求来实现一个服务器所应该有的功能。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>GateServer</title>
    <url>/2025/06/25/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/5-GateServer/</url>
    <content><![CDATA[<h1 id="GateServer"><a href="#GateServer" class="headerlink" title="GateServer"></a>GateServer</h1><p>本节进行网关服务器的线程模型的分析</p>
<span id="more"></span>



<h2 id="基本地位"><a href="#基本地位" class="headerlink" title="基本地位"></a>基本地位</h2><p>​	该网关服务器的逻辑目标是实现一个服务器集群中的<strong>HTTP</strong>服务器，用于接受在用户登录时候发来的对应的请求，为了保证对应的登录服务能够正确的被提供，所以需要保证对应的服务的请求不会被丢失。但是由于我本身对于QUIC这种协议不是很熟悉，而且C++中不存在这种的框架，所以不考虑使用这种协议来进行对应的实现。最终，我们敲定的是基于HTTP协议提供可靠登录服务验证的服务器。</p>
<p>​	</p>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><p>​	对于<strong>GateServer</strong>，其对应的每次<strong>HTTP</strong>请求都会触发一次监听套接字的监听，对应的会存在一个封装的<strong>HttpConnection</strong>结构来进行本次连接的处理。下面直接给出一个实际的简单的流程图。</p>
<p><img src="/2025/06/25/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/5-GateServer/image-20250625231520092.png" alt="image-20250625231520092"></p>
<p>​	在程序的一开始，我们开辟出一个独立的线程进行对应的监听，该线程实际上即为我们的主线程，主线程上运行我们的<strong>acceptor</strong>来进行对应的连接请求的监听</p>
<p>​	为了提高我们的并发能力，对于每个HTTP请求处理，我们都会存在一个IO_Context进行管理，避免所有的处理都跑在主线程上导致性能不高。而这个IO_Context是由一个池子来统一提供的，这种避免对应的创建销毁开销的池化思想很常见了，不再赘诉。主要来关注一下我们对应的下面的逻辑处理与整个的线程模型。</p>
<p>​	</p>
<h2 id="逻辑处理"><a href="#逻辑处理" class="headerlink" title="逻辑处理"></a>逻辑处理</h2><p>​	对于每个IO_Context，其跑在一个独立的线程上，其管理着对应的一系列的建立起来的<strong>HTTP短连接</strong>，对应的所有的连接都是在本个上下文中串行的执行的。通过这中串行的逻辑，我们省去了在IO_Context内部去调度对应的多个服务的并发的复杂度，同时，由于多个<strong>IO_Context</strong>本身线程本身物理隔离。同时，我们在设计上避免了对应的多个IO_Context的通信，这样能够避免我们需要关注对应的多个<strong>IO_Context</strong>间的任务调度竞态问题。</p>
<p>​	接下来考虑一下在一个服务内部的一个任务的一个实际处理情况。首先，我们确认一下一个任务在外面的这里的地位是什么，这里的一个任务是实现一个功能的验证的一个单位。就比如，存在对应于**&#x2F;getVerifyCide<strong>的回调，其中会涉及数据库的数据的查询，Redis职工共享数据的查询，通过RPC向其他的服务器通信的服务。总总这些，再组合一些业务逻辑，实现了一个完整的任务，提供起了一个验证码服务的提供，这个即使一个基本的</strong>任务**。</p>
<p>​	在一个任务中，目前的设计是一个串行处理的，这是基于目前我的能力和对应的业务一致性决定的。即，要想实现一个注册服务，我需要先拉取对应的数据库信息，判断是否存在等信息，在操作完成之后(我们此处推演一次全部的正确流程，错误流程自行源码分析)，再来进行对应的Redis的操作，存在一个<strong>MySQLService-&gt;RedisService</strong>的先后依赖关系。在某种程度上，这种同步操作可能会导致一些性能问题，但是，怎么理解这种场景呢？</p>
<h2 id="性能的陷阱"><a href="#性能的陷阱" class="headerlink" title="性能的陷阱"></a>性能的陷阱</h2><p>​	在我一开始实现这个服务的时候，我其实存在一些很多的考虑。在之前的书上，我其实看到了对应的在同步操作中去进行对应的数据库，grpc等连接IO操作的代价，所以我会在潜意识里想要去优化掉对应的同步操作为一个异步的逻辑。但是在一个简单的思考过后(或许并不简单)，我推翻了进行重构为异步的想法。其中有多方面因素，其中最重要的是俩个</p>
<h3 id="1-将同步优化为异步的复杂"><a href="#1-将同步优化为异步的复杂" class="headerlink" title="1.将同步优化为异步的复杂"></a>1.将同步优化为异步的复杂</h3><p>​	异步操作确实能够带来很多的便捷性，但是与之同时到来的，是为了实现这种便捷性本身所需要的复杂性，对于现有的ASIO中的**async_<em><strong>等的逻辑。我们值所以倾向于在对应的网络中使用它，首先就是因为其给我们封装了一系列的异步处理逻辑，其能够保证大多数情况下对应的异步回调能够正常被执行，其所带来的</strong>心智负担</em>*并不是很大。</p>
<p>​	其中的重点是<strong>心智负担</strong>这一词。如果我们想要在业务层实现一个自己的异步逻辑，至少对于现在的我来说，我是无法想象的。如果以类似于<strong>Asio</strong>的异步逻辑的写法来实现的话，其会造成一种多层嵌套的局面，其对应的实际的逻辑会变得支离破碎。这是由于异步本身的性质决定的，异步想要正常执行，那么其就需要保留一个异步注册和调用时候的上下文状态，在框架级别的使用中，ASIO给我们封装了这些的操作，使得我们不用关心。但是这里，如果我们想要把一个任务中的一个数据库处理操作，一个grpc调用操作都给封装为一个异步的，其所引入的状态机模型将会指数级别的提升。这对于现在的我来说，这是无法接受的，无论是编码还是理解维护层面。</p>
<p>​	就比如下面的伪代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">RegPost</span>(<span class="string">&quot;/user_login&quot;</span>, [=](<span class="keyword">auto</span> conn) &#123;</span><br><span class="line">    <span class="built_in">parse_json</span>(conn, [=](Json::Value parsed_json)&#123;</span><br><span class="line">        <span class="comment">// 封装数据、进入异步状态1</span></span><br><span class="line">        <span class="built_in">mysql_async_check_pwd</span>(email, pwd, [=](<span class="type">bool</span> valid, UserInfo userInfo) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!valid) <span class="keyword">return</span> <span class="built_in">send_error</span>(conn, <span class="string">&quot;pwd invalid&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 异步状态2</span></span><br><span class="line">            <span class="built_in">grpc_async_get_chat_server</span>(userInfo.uid, [=](Reply reply) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reply.<span class="built_in">error</span>()) <span class="keyword">return</span> <span class="built_in">send_error</span>(conn, <span class="string">&quot;grpc fail&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回包</span></span><br><span class="line">                Json::Value root;</span><br><span class="line">                root[<span class="string">&quot;uid&quot;</span>] = userInfo.uid;</span><br><span class="line">                root[<span class="string">&quot;token&quot;</span>] = reply.<span class="built_in">token</span>();</span><br><span class="line">                <span class="built_in">send_json</span>(conn, root);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	如果按照ASIO的风格来进行对应的异步的优化，在我的个人理解中，其最终的形态大概率会导致一个<strong>回调地狱</strong>，这对于我之后回来熟悉这一段的逻辑，以及扩展对应的逻辑，都是相当不利的，更重要的是，我根本无法实现在异步条件下安全的该类异步回调函数，而且，即使能够实现，由于业务功能的多样性，我实现的一个异步函数也无法适配所有的场景，对应的复杂度是我当前无法想象的，所以我在这一点中放弃了对应的异步逻辑的优化。</p>
<h3 id="2-优化本身的意义"><a href="#2-优化本身的意义" class="headerlink" title="2.优化本身的意义"></a>2.优化本身的意义</h3>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁分析(1)</title>
    <url>/2025/09/06/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/7-distributedLock/</url>
    <content><![CDATA[<h1 id="Distributed-lock"><a href="#Distributed-lock" class="headerlink" title="Distributed lock"></a><strong>Distributed lock</strong></h1><p>本节进行项目中分布式锁的使用的分析</p>
<p>​	分布式锁是一种跨进程的保护全局共享资源的一种机制，实际上与普通的锁本身没有什么本质上的不同，只是视角不同，普通的锁最多也只是在进程内部，对于线程共享，协程共享等资源的保护，而分布式锁，其是在对于一些复杂分布式场景下的资源的保护。实现起来跟OS课上了解的基本锁实现没有什么区别，难度不大。因此，分布式锁的使用实际上不在于如何设计之上，而是在于为何使用，不使用可以吗，为了达成分布式锁的效果，是否存在别的更加简单的机制能够实现同样的效果呢？</p>
<p>​	下面从多个问题方面进行分析。</p>
<span id="more"></span>

<h2 id="1-为什么要锁？"><a href="#1-为什么要锁？" class="headerlink" title="1. 为什么要锁？"></a>1. 为什么要锁？</h2><p>在本次分析中，我们围绕一个核心需求: <strong>单点登录</strong>。为什么要实现单点登录？首先是需要考虑到一个IM系统的特殊性，一般来说，IM软件是比较私密的软件，不会期望你一个账户能够多人同时在线，这样可能会导致一些潜在的信息泄露，就比如在你当前无感知的情况下存在一个用户登录了你的账户来窃取信息。当然，市面上存在一个其他的设计，就比如微信，其能够支持同个账户多台设备的同时登录，但是，对应的设备本身是存在区别的，就比如其允许的实际上是手机app，PC端，IPad端的同时登录，但是对于手机端，PC端这种，其同一时间只允许一个用户登录，这是一个IM所应该具有的基本素质。</p>
<p>对于为什么要保持单点登录，我们再来分析一个更加明确的场景，还是先前的账户被窃取时另外一端在你在线或不在线登录的时候，用户期望的是什么？用户一定期望能够识别这种被窃取的行为，此时其会尝试去找回账户等动作，此时对应的关注点会在于账户窃取者的身上，而不是对应的IM运营方身上，这也是对于设计者本身的保护。我们应该提供一种保障，一种至少能够让用户识别当前账户是否安全的机制。更加抽象一点，我们期望的是一具完整的尸体能够让我们能够分析问题，而不是一具消失的尸体。</p>
<p>而且实际上我们如果考虑后续移植APP端的话，会存在一个重要的场景，就比如如果手机APP端在不断的移动中基站变量，此时对应的IP已经改变，如何来保证对应的服务正确提供，此时就需要涉及到一个无损迁移，这个也涉及到一个异地登录的场景，虽然只是物理上移动导致的，但是本质上也是一种异地登录的需求(类似场景就比如高铁或火车上的移动)。当然，这个场景会更加复杂，其涉及到如何无损的迁移或保持连接，暂且不在本次的考虑范围中，本次先考虑简单的异地登录逻辑即可。</p>
<p>回过头来。在明确单点登录这个需求之后，我们需要考虑如何来实现它。首先我们需要来回顾一下登录的流程</p>
<img src="/2025/09/06/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/7-distributedLock/image-20250906141759990.png" alt="image-20250906141759990" style="zoom:80%;">

<p>在初始时刻，客户端通过携带登录的账户密码信息去到GateServer请求登录，GateServer收到该请求会回解析该数据并通过grpc向StatusServer请求一个合法的ChatServer信息。而StatusServer本身的这个查询ChatServer信息过程以及登录流程会涉及到集群内Redis的数据的查询和修改。在处理成功后，通过层层冒泡将数据返回给client，client依据这些信息来进行后续的ChatServer的TCP连接，注意在建立连接的这段过程中，会涉及到一些复杂状态的修改，因为实际上我们前面StatusServer的处理流程中只是简单的负载均衡查询连接数较少的一个服务器，没有进行更加复杂的操作。后续可以考虑将对应的处理分离到StatusServer中，这里为了简单，放置到ChatServer的处理中。</p>
<p>在这其中，最重要的是StatusServer与Redis的通信，这其中涉及到了部分共享信息的修改，这涉及到一系列的敏感情况，需要详细分析，这也是为什么需要分布式锁的一个因素，后续进行对于实际场景的分析应该能够更加清晰。</p>
<h2 id="2-异地登录场景分析"><a href="#2-异地登录场景分析" class="headerlink" title="2.异地登录场景分析"></a>2.异地登录场景分析</h2><p>在本次的分析中，由于个人能力问题，只专注于一个场景的分析，对应的本次考虑的场景是<strong>双端并发登录</strong>与<strong>踢人竞态</strong>场景。</p>
<p>在当前的项目设计中，存在一个token机制，当一个数据中UID为x的用户登录请求打到对应的StatusServer中时，该StatusServer会生成一份token并且将其设置到对应的Redis中，实际上，该次过程中的设置是一个并发操作，可能存在多个RPC连接同时发起，可能会导致一个UID为x的用户的多次设置Token，并尝试携带各自的Token都进行登录，这在当前的系统中是可能的，如果被攻击，攻击者通过同一个用户来批量发起请求，此时就可能导致这种并发情况，不过这种情况是可以接受的。这是由于Redis本身的命令执行线程是一个单线程操作，并发到达的命令其并不会出现一种中间状态。最后这种攻击的结构只会是存在最后一次物理写入的Token作为该UID的token值。</p>
<p>那么，这种情况对于我们是否存在影响呢，或者说，我们是否需要进行处理呢，目前来说，其实有点风险。当用户携带其从GateServer最终得到的数据尝试去进行登录的时候，对应的ChatServer的校验逻辑目前只是进行一个token的匹配，实际上存在一种可能的情况，当对应的Redis修改请求串行中夹杂了某一次ChatServer的获取Token请求，而本次获取请求的最近一次Token设置刚好设置的就是本次校验所对应的Token时，此时就能够通过，以此类推，实际上可能存在多个客户端在严重并发压力下的同时登录情况下。当然，这种情况非常极端，其需要满足多个条件，其一是对应的登录请求是恶意且批量的，其二是对应的请求处理非常快，甚至于对应的RTT等使得用户连接ChatServer的RTT和ChatServer通信Redis的RTT等加起来赶上了前面某次特定登录请求的命令执行。</p>
<p>给上述分析总结一段简短的分析</p>
<p>在<strong>高并发或恶意请求</strong>场景下：</p>
<ul>
<li>A 请求写入 token1</li>
<li>B 请求写入 token2</li>
<li>C 请求在 token2 写入前读到 token1，并继续去 ChatServer 验证</li>
<li>结果 token1 和 token2 都有机会在不同客户端上被用来登录。</li>
</ul>
<p>实际上，这是非常极端的一种情况，并不在本次探讨的范围内，所以我们可以在本次先假定这种Token登录的并发请求暂且不会出现上面那种情况，我们可以先假设我们的系统要求的是一种最终一致性的模型。</p>
<p>下面就更加可能的场景进行分析，我们先考虑一种最普通的场景，当UID为1的用户成功登录后，该用户用其的用户信息在另外一个设备上尝试登录，在当前的设计中，我们初步设定只允许一个UID代表的用户只能同时登录一个设备。此时，我们就需要完善一个踢人逻辑。</p>
<p><strong>多端登录踢人竞态</strong></p>
<p><img src="/2025/09/06/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/7-distributedLock/image-20250906152003463.png" alt="image-20250906152003463"></p>
<p>直接观察多服务端登录时可能的竞态情况，对于单服务器登录时的竞态在多服分析后自然也就清晰了。</p>
<p>优先明确当前的几个前提条件：</p>
<ul>
<li>一个UID为x的设备已经登录，在另外一个设备中，另外一个UID也为x的设备也尝试登录</li>
<li>当前已登录的设备已经处在一个完整的登录状态，而待登录设备处于一种等待与Server建立连接的状态</li>
</ul>
<p>上诉流程图基本解释了在异地登录时所需要执行的基本操作，接下来就可能的竞态场景进行分析。当Server2查询到当前系统Redis中已经存在一个login_x的KV对的时候，其断定此时该用户已经在系统中存在登录的账户。本次系统设计以最后一次登录为准，因此会踢掉当前系统中已经存在的用户而保留当前新登录的用户。为了踢掉该用户，其需要执行下列步骤：</p>
<ul>
<li>查看当前已登录的改用户所在的服务器信息，判断是否为本服，对应的存在不同的逻辑</li>
<li>若该用户当前位于本服务器上，此时与上图中的逻辑大致相同，只是省去了grpc间的通信，直接处理对应的socket关闭和key删除逻辑即可。如果是在它服上，则通过grpc进行通知，并执行对应相同的逻辑踢人即可</li>
<li>在服务器收到对端服务器成功踢人之后，进入常规的逻辑即可，写入对应的登录信息并进行常规的业务逻辑。</li>
</ul>
<p>接下俩针对于多服登录时的踢人逻辑进行详细分析。</p>
<p>当一个服务器收到需要踢人的请求后，其会去查找当前服务器中挂载的session，并向客户端发送一个close信号，注意此处不能由服务器本身进行close，否则可能出现TimeWait现象。然后其需要去修改Redis信息，将该用户所对应的信息进行删除，由于是调用的Redis服务，所以该次操作实际上只是投递了一个删除请求信息，在收到Redis的ACK信息后就返回了，然后其需要通过gRPC通知踢人请求发起者，该发起者收到后也会向Redis中发起一次请求，该请求本次是尝试对于key进行写入。</p>
<p>注意，在本个踢人流程中，我们对于Redis的操作，实际上只是投递了请求过去，实际上Redis内部是同步执行还是异步执行后返回的ACK信息，我们并无法保证，或者说，不能够依赖于其的保证，避免后续的Redis的迭代中由于其同步异步逻辑的切换导致的问题。所以我们需要以一种最坏的情况进行假设，就假设Redis本身是一个异步执行的逻辑，其会在收到请求后直接ACK，内部再切实执行。那么此时就可能存在下面的可能竞态。</p>
<p>我们知道，Redis内部的逻辑执行模块是单线程，但是其网络接收模块是多线程的。在多线程接受单线程处理的情况下，实际上我们不能够保证我们Server1的信息处理一定能够在Server2的处理之前完成。如果Server2发出的请求实际的排队在了Server1的请求之前，那么Redis的最终一致性将会导致该Key:login_TCWW在Redis中为空，这是不可接受的。这是因为实际上我们的业务逻辑中存在一个时序性，我们的写入新Key的这个逻辑需要严格串行在删除旧Key这个操作之后。然而由于当前是一个跨进程的操作，所以无锁的情况下难以保证，所以需要引入一个机制来保证这俩个操作的串行性。这也就是我们引入分布式锁的基础动机。</p>
<p>当前我们的需求是通过一种机制来保证删除Key的操作严格位于写入Key的操作之前。此时，分布式锁基本是最简单的方法。考虑将对应的key的修改权限锁住，由于本身删除key的请求一定严格先于删除key的请求到达。所以其一定能够优先获取到锁，由此能够人为的跨进程的维护一种先后顺序。对于此处的需求，使用分布式锁就能够轻松的解决。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁分析(2)</title>
    <url>/2025/09/07/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/8-distributedLock2/</url>
    <content><![CDATA[<h1 id="Distributed-lock"><a href="#Distributed-lock" class="headerlink" title="Distributed lock"></a><strong>Distributed lock</strong></h1><p>紧接上文，进行跨服登录中涉及到的分布式锁分析</p>
<span id="more"></span>

<p>首先，先来分析在当前的服务中，需要在跨服登录中进行分析处理的场景</p>
<p>下面给出一个在未进行分布式锁定同步情况下的一个可能场景</p>
<p><img src="/2025/09/07/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/8-distributedLock2/image-20250909222513337.png" alt="image-20250909222513337"></p>
<p>在详细分析前，先明确当前场景与需求：当多个用户并发登录时，需要考虑数据流动情况。这里假设这些用户并非同一 uid，而是普通的并发登录。  </p>
<p>回顾架构设计：系统包含一个 GateServer、一个 StatusServer、多个 ChatServer。拆分多个 ChatServer 是为水平扩展和负载均衡，目前的策略仅为统计每个 ChatServer 的连接数。要保证负载均衡能起作用，就必须分析其中可能的竞态。本文借助分布式锁的视角进一步分析。  </p>
<p>负载均衡策略：当 Client 获取到 ChatServer 信息并建立长连接时，ChatServer 会更新 Redis 中的连接数。核心依赖于：  </p>
<ul>
<li>StatusServer 从 Redis 读取 LoginCount 并选择负载最小的服务器；  </li>
<li>ChatServer 在连接建立或销毁时更新 LoginCount。</li>
</ul>
<hr>
<p>​	</p>
<h2 id="登录流程推导"><a href="#登录流程推导" class="headerlink" title="登录流程推导"></a>登录流程推导</h2><p>为了使得流程清晰，我们来重新推理一遍用户的登录流程来跟踪数据流动</p>
<ol>
<li>Client 登录请求 → GateServer  </li>
<li>GateServer → StatusServer 请求可用 ChatServer  </li>
<li>StatusServer 从 Redis 获取 LoginCount，返回最小负载服务器  </li>
<li>GateServer 将结果返回给客户端  </li>
<li>Client 与 ChatServer 建立长连接  </li>
<li>ChatServer 更新 Redis 中 LoginCount，并初始化</li>
</ol>
<p>此时，我们能够清晰的看到，在整个登录流程中，为了支持负载均衡，核心由StatusServer对于Redis的LoginCount域的读取和ChatServer对于LoginCount域的写入合作提供，所以我们需要保证这俩者能够符合我们预想的逻辑。但是这个实际上比较难以思考，实际上，由于没有接触过，我也只能够根据他人对于该类场景的分析来排查对应的竞态条件，本文来对于该类竞态场景进行二次分析。</p>
<p>在一次登录流程中，我们观察到，在用户发起登录请求到获取到登录所必须的信息，获取到必须的信息到真正成功的登录之间，都存在着一段时间窗口，这是由于一系列的网络通信导致的。在Client1获取到登录信息尝试登录到真正登录成功更新连接数信息这段时间内，可能存在任一用户尝试登录。此时可能会出现一种竞态条件，假设初始连接数都为(0,0)，那么此时StatusServer返回的服务器信息都会是ChatServer1的信息。如果一个新连接在另外一个已获取到ChatServer1信息但是尚未建立起连接更新连接数时将请求打到了StatusServer上，并成功获取返回了一个ChatServer信息。那么此时可能存在俩种情况，StatusServer可能返回ChatServer1的信息，也可能返回ChatServer2的信息。为什么呢？</p>
<p>如前文所说，这是由于一个登录用户在获取到服务器信息到实际登录更新服务器连接数之间存在一个时间窗口所致。我们这里先不考虑直接在StatusServer中更新连接数，具体为什么可以交由个人自己考虑。那么，既然存在这个时间窗口，那么任一登录请求都可能在这个窗口内到达StatusServer获取服务器信息，此时由于先前的登录请求可能还未实际的更新，所以StatusServer实际查到的LoginCount域中数据还是(0,0)的情况，此时期望中的负载均衡操作就会被打破。</p>
<p>但是，实际上存在一个问题，要实现一种机制来排除这种竞态是比较麻烦的。我们考虑对应的StatusServer返回信息一直到ChatServer成功登录的时间窗口跨越的时间，其中涉及到了<code>StatusServer-&gt;GateServer，GateServer-&gt;Client，Client-&gt;ChatServer，ChatServer-&gt;Redis</code>，这一整个网络链条，而一次普通的登录请求所要考虑的网络链条为<code>Client-&gt;GateServer,GateServer-&gt;StatusServer,StatusServer-&gt;Redis</code>。实际上后一个链条想要位于前一条链条的子集是相当容易的。但是，注意，我没能力，我目前懒的实现一种机制实现一种互斥，使得对应的一次先到达的StatusServer获取信息的登录请求最终的处理能够位于另外一个先发起的登录请求获取服务器信息之前。或者说，目前要实现起来过于麻烦，其需要涉及到一系列的跨服信息传递，需要后续继续进行进一步的详细分析。</p>
<p>我们这里先按下不表，如果存在一个可能的实现，欢迎交流。</p>
<p>由于我们决定目前先不解决对应的一个登录请求位于另外一个已处理一般的登录请求的窗口中，所以为了能够继续推进问题，我们需要进行一些假设和约束。我们假设对应的登录流程的最后ChatServer对于Redis的写能够与对应的Client初始登录中的StatusServer对于Redis中的读产生竞态，而不是位于一段完全的窗口范围内，或者说，更加严格一点，对应的一个<code>StatusServer-&gt;GateServer，GateServer-&gt;Client，Client-&gt;ChatServer，ChatServer-&gt;Redis</code>这个链条的RTT比起<code>Client-&gt;GateServer,GateServer-&gt;StatusServer,StatusServer-&gt;Redis</code>的RTT要短，或者说，壁布对应的RTT长。在我看来，在这种假设下，对应的后续的登录总归不至于产生前文中产生的难以解决的竞态，即使这种假设在目前看来不甚合理，但是可待后续机制补充来解决。</p>
<blockquote>
<p>由于个人能力以及为了遵守KISS，个人不考虑在一开始就引入考虑过分复杂的场景，目前的想法是先通过假设来约定对应的时间窗口的重合情况，使得对应的并发可控，实际上这只是理论上的分析，实际中不会给我如此的宽容。就比如，这里的上文中考虑到的一个新登录请求在某一个请求还位于其写入Redis的整个窗口是在高并发下并发发生的，但是我在当前阶段并不考虑解决，从小的做起，后续如果积累足够，我再考虑回过头来将这里的逻辑给补全。</p>
</blockquote>
<p>实际上，我当前要实现的负载均衡若想要能够实现其的统计，其必须依托于一个假设。即，一个登录请求对于Redis的影响的可见性必须位于另外一个在时序上落后于它的登录请求之前。什么意思呢，就是对应的登录请求最终登录到ChatServer并改变LoginCount域中的数值必须强一致的位于一个时序上在该请求初始发起时的时序。但是，正如前文所说，这是相当难以实现的。真要实现一种强一致性，我们必须封锁相当长的一个逻辑流程，相对来说这是不太容易接受的。所以我们这里先不考虑在初期就实现一种强一致支持的负载均衡操作。</p>
<p>为了能够继续推进问题，我们需要对于当前的系统进行一些严格的假设来缩小考虑的范围。提取上文所说的俩个登录链条。</p>
<p>时间窗口1：<code>StatusServer-&gt;GateServer，GateServer-&gt;Client，Client-&gt;ChatServer，ChatServer-&gt;Redis</code></p>
<p>时间窗口2：<code>Client-&gt;GateServer,GateServer-&gt;StatusServer,StatusServer-&gt;Redis</code></p>
<ul>
<li><p>不考虑窗口2的并发情况</p>
<p>在系统中，我们考虑以实际登录到ChatServer的Session数作为一个Server的负载情况。如果我们考虑这一段的并发，我们会有一个很简单的解决方案，将对应的连接数更新直接放置到对应的StatusServer的登录逻辑中。但是，这样会存在一种问题，就是客户端在收到对应的服务器信息之后，实际上可能不会连接到对应的ChatServer服务器上，对于客户端来说，这种场景自然不会频繁发生。但是如果是通过一些程序发起的连接呢。可能存在一些恶意的请求会通过talnet等程序尝试进行登录请求但是不进行后续的流程，我们如果将这类连接也直接统计到对应的连接数中，可能会导致一种恶意的请求使得StatusServer误判，进而导致负载均衡服务根本发生不了作用。即使我们这里先不考虑对于这种攻击的解决方案，我们也先不考虑将连接数统计耦合到StatusServer-&gt;Redis这个流程中。接下来讨论为什么不考虑窗口2的并发情况，正如前面所说，对应的窗口2实际上所能做的只是获取当前快照下的连接数信息并且给出局部最优，窗口2并发的情况会导致这段窗口时间内的所有请求最终可能打到同一个服务器上。对于我个人来说，这个场景稍微可以接受，考虑对于这中并发请求发生时如果进行锁等互斥行为，其会导致最后的登录体验会有较大的延迟，与其考虑这段时间可能带来的一个服务器的突发负载，我更倾向于保证这种小峰值期的客户端登录体验。当然，我们后续可以采取一种更加优雅的方式，就比如引入一个消息队列中间件，将对应的登录请求实际上按照一定的时间区间来批次获取，并对于这些并发的请求，继续在内部进行轮转来分配服务器信息，这种能够保证服务器针对于突发请求也有一定的负载均衡的能力。</p>
</li>
<li><p>对于窗口1与窗口2之间的并发，需要约束对应的窗口重叠</p>
<p>对于窗口1，首先需要明确一点，关于窗口1所涵盖的流程，在对应的ChatServer收到对应的连接请求之前，我们是无法区分到底其是没有发起后续的连接请求还是请求正在网络传输中，与其费心费力来检测这种现象，考虑在初期直接假设这个窗口不是竞态发生处。因此，我们不进行<code>StatusServer-&gt;GateServer，GateServer-&gt;Client，Client-&gt;ChatServer</code>这段的并发分析。只进行最终<code>ChatServer-&gt;Redis</code>与<code>Client-&gt;GateServer,GateServer-&gt;StatusServer,StatusServer-&gt;Redis</code>的并发分析。</p>
</li>
</ul>
<p>上面是我们对应的假设，通过这些假设，我们能够进行一些比较简单的分析。但是，这些都是一些假设，只依赖于这些假设会导致在服务器集群的不断运行中偏差逐渐严重，如果不加以矫正，对应的负载均衡操作根本上就是一个笑话。所以，我们需要一种兜底机制来作为一种不断修改偏差的方法。在我目前的构想中，我们考虑使用一种服务器之间的心跳机制来作为这种数据的修正。考虑每个ChatServer在每一段时间后统计本机上已经连接的Session数，这个数量即是当前服务器的负载。每次统计后，将这段数据上报到Redis中。也就是说，对应的服务器的负载依赖于ChatServer的不断心跳来逐渐修正，对应的允许存在一段不一致的窗口期，这段窗口期就是ChatServer的心跳时间，在这段时间内，我们允许StatusServer使用的数据可以进行一定的偏移导致一定的负载不均衡。但是对应的每次一定需要能够在下一次心跳时上报能够收敛到一个快照。在这种设计下，对应的大用户量只要不是在短时间内突发登录，那么最终一定不会发散到特别离谱，对应的每次心跳总归能够收敛一些负载。</p>
<hr>
<h1 id="Distributed-lock（精简版）"><a href="#Distributed-lock（精简版）" class="headerlink" title="Distributed lock（精简版）"></a><strong>Distributed lock</strong>（精简版）</h1><p>紧接上文，进行跨服登录中涉及到的分布式锁分析</p>
<!--more-->

<p>首先，先来分析在当前服务中，跨服登录涉及到的分布式锁场景。</p>
<p>下面给出一个未进行分布式锁同步情况下的可能场景：</p>
<p><img src="/2025/09/07/%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/8-distributedLock2/image-20250909222513337.png" alt="image-20250909222513337"></p>
<p>在详细分析前，先明确当前场景与需求：当多个用户并发登录时，需要考虑数据流动情况。这里假设这些用户并非同一 uid，而是普通的并发登录。  </p>
<p>回顾架构设计：系统包含一个 GateServer、一个 StatusServer、多个 ChatServer。拆分多个 ChatServer 是为水平扩展和负载均衡，目前的策略仅为统计每个 ChatServer 的连接数。要保证负载均衡能起作用，就必须分析其中可能的竞态。本文借助分布式锁的视角进一步分析。  </p>
<p>负载均衡策略：当 Client 获取到 ChatServer 信息并建立长连接时，ChatServer 会更新 Redis 中的连接数。核心依赖于：  </p>
<ul>
<li>StatusServer 从 Redis 读取 LoginCount 并选择负载最小的服务器；  </li>
<li>ChatServer 在连接建立或销毁时更新 LoginCount。</li>
</ul>
<hr>
<h2 id="登录流程推导-1"><a href="#登录流程推导-1" class="headerlink" title="登录流程推导"></a>登录流程推导</h2><p>用户登录流程如下：  </p>
<ol>
<li>Client 登录请求 → GateServer  </li>
<li>GateServer → StatusServer 请求可用 ChatServer  </li>
<li>StatusServer 从 Redis 获取 LoginCount，返回最小负载服务器  </li>
<li>GateServer 将结果返回给客户端  </li>
<li>Client 与 ChatServer 建立长连接  </li>
<li>ChatServer 更新 Redis 中 LoginCount，并初始化</li>
</ol>
<p>从流程可见，负载均衡依赖 StatusServer 的读取与 ChatServer 的写入配合。但二者存在时间窗口，可能出现竞态。  </p>
<p>例如，初始连接数为 (0,0)，当 Client1 获取 ChatServer1 信息但尚未更新连接数时，Client2 请求到达 StatusServer。此时 Redis 中仍是 (0,0)，StatusServer 可能再次返回 ChatServer1，从而破坏负载均衡。  </p>
<p>要消除这种竞态较麻烦，因为涉及从获取服务器信息到真正建立连接的整个窗口：  </p>
<ul>
<li><code>StatusServer-&gt;GateServer-&gt;Client-&gt;ChatServer-&gt;Redis</code><br>而普通登录链路是：  </li>
<li><code>Client-&gt;GateServer-&gt;StatusServer-&gt;Redis</code></li>
</ul>
<p>前者窗口包含后者，不易保证时序一致。要完全解决需跨服互斥，但目前我没有实现能力，也过于复杂，所以暂不处理。  </p>
<p>为了推进分析，做以下假设：认为 ChatServer 最终写 Redis 的操作可能与 StatusServer 读 Redis 产生竞态，但忽略整个窗口的重叠问题。换言之，假设 <code>ChatServer-&gt;Redis</code> 的 RTT 短于 <code>StatusServer-&gt;Redis</code> 的 RTT，从而竞态范围仅限 Redis 的读写。虽然这一假设并不完全合理，但可以作为初期简化。  </p>
<blockquote>
<p>出于个人能力限制和 KISS 原则，暂不考虑过分复杂的情况，先基于假设控制并发范围。未来再补充更严格的机制。  </p>
</blockquote>
<hr>
<h2 id="时间窗口拆分"><a href="#时间窗口拆分" class="headerlink" title="时间窗口拆分"></a>时间窗口拆分</h2><p>提取两段窗口：  </p>
<ul>
<li>窗口1：<code>StatusServer-&gt;GateServer-&gt;Client-&gt;ChatServer-&gt;Redis</code>  </li>
<li>窗口2：<code>Client-&gt;GateServer-&gt;StatusServer-&gt;Redis</code></li>
</ul>
<h3 id="忽略窗口2并发"><a href="#忽略窗口2并发" class="headerlink" title="忽略窗口2并发"></a>忽略窗口2并发</h3><p>系统以实际连接到 ChatServer 的 Session 数作为负载。如果直接在 StatusServer 更新连接数，可能被恶意请求利用（发起请求但不建连，导致误判）。因此不耦合在 StatusServer。</p>
<p>至于窗口2内部并发，会导致短时间内多个请求打到同一服务器，但相比加锁带来的延迟，我更愿意接受小范围的负载不均衡，以保证用户体验。后续可以考虑用消息队列中间件批量分配，改善突发登录的均衡性。 </p>
<h3 id="约束窗口1与窗口2的重叠"><a href="#约束窗口1与窗口2的重叠" class="headerlink" title="约束窗口1与窗口2的重叠"></a>约束窗口1与窗口2的重叠</h3><p>在窗口1中，<code>ChatServer-&gt;Redis</code> 前的部分不可区分是“未建连”还是“在路上”，因此不考虑该并发，仅分析最终的 <code>ChatServer-&gt;Redis</code> 与 <code>StatusServer-&gt;Redis</code> 间的竞态。  </p>
<hr>
<h2 id="兜底机制"><a href="#兜底机制" class="headerlink" title="兜底机制"></a>兜底机制</h2><p>上述假设只能缩小分析范围，若长期依赖，偏差会积累，导致负载均衡失效。因此需要兜底机制：  </p>
<p>考虑通过心跳机制矫正。每个 ChatServer 定期统计自身 Session 数并上报到 Redis，作为实际负载数据。这样即使短期内存在不一致，最终也会收敛，避免负载发散。  </p>
<p>只要不是极端的突发登录场景，心跳修正能维持整体的均衡性。 </p>
<hr>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>惊群效应</title>
    <url>/2025/09/19/%E5%88%86%E5%B8%83%E5%BC%8F/0.2-memcache-fb/</url>
    <content><![CDATA[<p>本文进行对于<strong>Scaling Memcache at Facebook</strong>一文的部分内容摘取</p>
<span id="more"></span>

<h2 id="旁路缓存-look-aside-cache-的场景"><a href="#旁路缓存-look-aside-cache-的场景" class="headerlink" title="旁路缓存(look-aside cache)的场景"></a>旁路缓存(look-aside cache)的场景</h2><p>系统的架构是不断衍化的，在初期，可能通过一个服务器即能够撑住所有的静态页面，动态资源，数据等资源的提供，但是随着用户量和需求的不断变动，逐渐单机承载不下，就需要不断的扩展各个服务的性能。其中，对于储存服务的一种较好扩展，自然也就是旁路缓存(look-aside cache).</p>
<p>下面先将对应的数据规模局限在有数千个服务器组成的集群上</p>
<p>在如此大规模的集群之下，对应的应用侧的请求也具有一定的特征，其对于一个页面的拉取，通常来说并不像个人搭建的小网站一样只拉取几个资源。此时对应的一个热门页面的请求的元素拉取量甚至于能够到达500+的数量级。在这种数量级下，如果去减少对应的获取item的延迟将会是提高用户体验至关重要的一环。</p>
<p>在这种情况下，势必需要引入缓存，即MemCache层，对应的应用侧的服务器也需要不断与这些服务器之间通信来获取可能存在的缓存信息。但是可以想象，如果每个应用侧服务器都需要与MemCache服务器通信，对应的状态管理将会膨胀到<strong>N*M</strong>的程度，此时对于网络来说，如果存在一端的错误，容易导致<strong>incast congestion</strong>。同时，在这种多对多的情况下，任意一个节点的抖动，都容易导致成为整个系统的瓶颈。在这种系统中，replication不一定能够解决问题，获取其能够解决一个单点瓶颈的场景，但是同时其也会引入更为复杂的状态管理。所以我们需要一种更加合适或者说更加详细的机制来补偿当前为了提供大规模服务的缺陷。</p>
<h2 id="Reducing-Latency"><a href="#Reducing-Latency" class="headerlink" title="Reducing Latency"></a>Reducing Latency</h2><p>由于服务的本质问题，对于一个webServer与各个MemCache之间的通信，我们是无法避免的，但是这些庞杂的通信中，存在着一些无用的通信，如果能够在应用侧发起的时候就检测到，那么就不必向没有数据的服务器发起信息了，自然能够减少一些网络压力。此时就需要一种方法，来让应用侧了解到其如果想获取一个数据，其需要去往哪个MemCache服务器能够直接获取。在论文中，为了实现这一种视图，使用了多种方法协同。其中，在数据分布方面，其使用一致性哈希来保证数据的分布可追踪，但是这种机制不是其索引对应的key所在的MemCache的服务器的机制。严格来说，可能是我对于论文阅读不够深入，我没有找到对应的关于这方面的描述。</p>
<p>不过就我个人猜测而言，其可能存在一种通过一致性哈希产生的结果来形成的表，其中储存的是一个key与储存的MemCache之间的映射关系。在McRouter需要去查找一个key时，可以通过该类数据机构来直接向某个MemCache定向发送，不必再向全部的MemCache服务器广播请求。</p>
<blockquote>
<p>Items are distributed across the memcached servers through consistent hashing [22].Thus web servers have to routinely communicate with <em>many</em> memcached servers to satisfy a user request. As a result, <em>all</em> web servers communicate with every memcached server in a short period of time.This <em>all-to-all</em> communication pattern can cause incast congestion [30] or allow a single server to become the bottleneck for many web servers. Data replication often alleviates the single-server bottleneck but leads to significant memory inefficiencies in the common case.</p>
</blockquote>
<p><strong>批处理</strong></p>
<p>在减少延迟这一方面，论文中提出了使用合并请求来提高响应的做法，其思路也很清晰，就是通过在Client侧维护一个DAG图。图中储存的是哪些key可以并发的获取，Client侧可以根据这个信息来合并key请求，这种批处理的思想很常见，不过这里的这种应用场景倒是给了我们一个启发。就是对于一些零散的请求，寻找一种方式来尝试合并，更直白点，批处理的方式是一种提高资源的利用率的不错方法。</p>
<p><strong>协议选择</strong></p>
<p>如果以网络中的层次来看，上面的批处理是在应用层上的优化。接下来，论文中提出了在网络层上的优化，相对来说也很简单，就是更具重要程度，来对于各种操作所使用的协议来进行抉择。对于一些不敏感的操作，就比如get操作，其使用了UDP，对于set和delete操作，其使用了TCP。相对来说，确实引入了一定的复杂度，不过这种复杂度实现起来倒也还行，而且相对来说，其所提高的那几个百分点的性能，是非常重要的，回顾一下前文提到的系统体量和用户量，这小小几个百分点所实际上代表的数据量其实已经很大了。</p>
<p><strong>拥堵控制</strong></p>
<p>恰如计算机网络一书中的阐述流程，在前面进行了一定的分析后，系统进入了流量大小的分析。由于系统体量太大，内部的通信是否会存在拥堵的现象。为了能够缓解或者限制这种<strong>Incast congestion</strong>现象，论文中提出了与TCP中流量控制的相似机制，<strong>滑动窗口</strong>。通过对应的窗口来实现流量的控制。此处如果系统学过计网，应该能够了解这种机制以及在应用层自己来封装一层额外的滑动窗口机制的好处所在。此处不必赘诉。</p>
<p>总的来说，在<strong>Reducing Latency</strong>这里，给我所带来的最大启发为，在我们遇到一些问题时，我们可以尝试在已经了解到的领域中去查找是否存在类似问题的解决方案，对于一个CSer来说，计算机网络就是一个非常完善且存在大量可以借鉴经验的宝库。</p>
<h2 id="Reducing-Load"><a href="#Reducing-Load" class="headerlink" title="Reducing Load"></a><strong>Reducing Load</strong></h2><p>下文进入另外一个有趣的方面，论文3.1节在考虑如何减小延迟，其中涉及到一些分布式中常规的一些场景，但是其给出了更加详细的场景以及实际的解决方案。</p>
<p>对于缓存这种基础设施，其不免会存在几个常见的场景，当缓存数据失效时，当为了恢复缓存失效时。针对这些个问题，需要根据实际的场景来分析，本论文中给出了一些个针对于这些问题的解决方案。</p>
<p><strong>缓存失效</strong></p>
<p>在论文中，关于缓存失效，其可能是由于一个web server发起了set请求，但是并发存在对于该key的update请求而导致的竞态，也可能是由于一些替换策略，一些delete操作等。此时就可能由于缓存数据的丢失，而导致cache miss，此时对应的请求就会转向一些代价更加昂贵的路径(eg:数据库，分布式储存等)。此时如果存在大量的请求都走了这种路径，那么对应的端点的压力自然就会很大。此时，如何来缓解这种惊群现象就成了一种重要的优化思路。</p>
<p>一如在其他分布式系统中对于缓存失效&#x2F;缓存穿透的分析，论文中也提出了一种<strong>Lease</strong>机制。类似与其他一些系统，FB中的租约由MemCache服务器来进行生成与管理。其他方面与其他的实现中也大差不差，都是在一个key失效时，只给后续对于这些key的并发请求中的一个颁发Lease，此时获取Lease的Client将会负责重新构建缓存，而其他的Client，则会在获取Lease失败后休眠一会，减少惊群效应的影响。</p>
<p>除此之外，论文中对于一些缓存失效场景进行了一些优化。其中是当缓存失效是由<strong>delete</strong>操作引起时的操作。当Client发起一次delete操作后，该key在MemCache实际上不一定会被删除，而是会进入一种特殊的数据结构，其中储存了近期被删除的部分key。此时对于这种临界key的访问仍然正常。但是注意到的是，这其实是一种对于stale data的查找，所以其是强依赖与应用场景的。在论文中，其也说明了这是对于部分数据所进行的优化，同时这种优化对于其服务来说确实给到了一定的性能优势。</p>
<p>此时不难可以猜想这种优化可能的原因，就比如，当我对于一个FaceBook的条目点赞时，此时会触发set操作来进行更新，此时会使得MemCache中的数据失效(delete操作)。对于这种场景来说，实际上用户即使看到了一些过时的数据，也不会存在太大的疑惑，就比如你看到你朋友圈中一个人点赞或者俩个人点赞其实影响不大。所以实际上这种设计是强依赖于业务场景实现的。</p>
<blockquote>
<p>请注意，论文中此处的delete操作，是指前文中对于一个Key进行更新(set&#x2F;…)时会产生的delete请求(个人理解)</p>
</blockquote>
<blockquote>
<p>Our experience has shown that since the cached value tends to be a monotonically increasing snapshot of the database, most applications can use a stale value without any changes.</p>
</blockquote>
<p><strong>缓存池</strong></p>
<p>文中给出了一种其在实际的场景中发现的一种现象。对于MemCache不同类型的数据，其对于一个MemCache服务器的适应性和影响都不竞相同。</p>
<blockquote>
<p>Different applications’ workloads can produce negative interference resulting in decreased hit rates.</p>
</blockquote>
<p>文中给这种现象提供了一种解决方案，将具有相同性质的数据进行聚合，如下文。</p>
<blockquote>
<p>For example, we may provision a small pool for keys that are accessed frequently but for which a cache miss is inexpensive. We may also provision a large pool for infrequently accessed keys for which cache misses are prohibitively expensive.</p>
</blockquote>
<p>这种聚合管理的思路在现实中倒也比较常见，不过将这种思路运用到实际的设计中倒是很灵活。而且后续的数据提供的数据测量也不得不让人认可其的实际可行性。</p>
<p><strong>单点瓶颈</strong></p>
<p>前文从集群的MemCache的较高层视图来分析了一些场景，接下来将视角聚集到较高粒度的</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>惊群效应</title>
    <url>/2025/07/29/%E5%88%86%E5%B8%83%E5%BC%8F/0.1-%E6%83%8A%E7%BE%A4/</url>
    <content><![CDATA[<hr>
<h1 id="惊群效应（Thundering-Herds）"><a href="#惊群效应（Thundering-Herds）" class="headerlink" title="惊群效应（Thundering Herds）"></a>惊群效应（Thundering Herds）</h1><p>本文总结分布式系统中常见的“惊群效应”问题及应对方案，内容会随着实践不断补充。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>惊群效应是指在分布式系统中，当某一共享资源在短时间内同时变为可用或失效时，大量客户端或线程几乎同时发起请求，导致后端瞬时负载激增，甚至引发雪崩效应。</p>
<hr>
<h2 id="常见触发场景"><a href="#常见触发场景" class="headerlink" title="常见触发场景"></a>常见触发场景</h2><ul>
<li><p><strong>缓存击穿</strong><br>热点 Key 过期或被淘汰，大量请求同时 miss，直击数据库，造成后端压力骤增。</p>
</li>
<li><p><strong>锁竞争唤醒</strong><br>多个线程等待同一分布式锁或条件变量，持锁方释放后全部被唤醒，瞬时产生大量竞争请求。</p>
</li>
<li><p><strong>服务节点瞬时上线</strong><br>新节点启动后被路由层立即分配大量请求，但冷缓存&#x2F;初始化开销未完成，容易导致快速过载。</p>
</li>
</ul>
<hr>
<h2 id="常见缓解策略"><a href="#常见缓解策略" class="headerlink" title="常见缓解策略"></a>常见缓解策略</h2><ul>
<li><p><strong>限流</strong><br>控制单位时间请求数，防止后端瞬时过载。</p>
</li>
<li><p><strong>请求合并</strong><br>多个相同请求合并为一次后端访问，减少重复开销。</p>
</li>
<li><p><strong>提前刷新</strong><br>在热点数据失效前主动更新，避免大规模 miss。</p>
</li>
<li><p><strong>随机过期</strong><br>为不同 key 增加随机 TTL，避免同一时刻集中失效。</p>
</li>
</ul>
<hr>
<h2 id="Lease-机制"><a href="#Lease-机制" class="headerlink" title="Lease 机制"></a>Lease 机制</h2><p><strong>原理</strong><br>Lease 是一种缓存击穿防护策略，在 Memcached 等系统中常见：  </p>
<ul>
<li>当某个 key miss 时，缓存只向第一个请求方发放 lease token，授权其访问后端并回填数据；  </li>
<li>其他请求方在 lease 有效期内返回“稍后重试”或等待回填完成；  </li>
<li>在同一 lease 周期内，只有一个请求会触发后端访问。</li>
</ul>
<p><strong>优点</strong>  </p>
<ul>
<li>将瞬时高并发压力限制在缓存层，保护后端服务。  </li>
<li>可结合 TTL 随机化、热点数据提前刷新等策略，进一步降低风险。</li>
</ul>
<p><strong>局限</strong>  </p>
<ul>
<li>无法避免初次 miss 时的并发涌入。  </li>
<li>Lease 发放策略与 TTL 需结合业务特点调优。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>惊群效应的本质是<strong>瞬时高并发访问单一昂贵资源</strong>。应对的核心思路是：</p>
<ul>
<li>减少瞬时访问量（限流、随机过期）</li>
<li>减少重复访问（请求合并、Lease）</li>
<li>提前避免失效（提前刷新）</li>
</ul>
<p>在实际系统中，往往需要多种策略结合使用，才能在高并发场景下有效降低惊群带来的风险。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>6.824 lab1思考</title>
    <url>/2025/07/15/%E5%88%86%E5%B8%83%E5%BC%8F/lab1/</url>
    <content><![CDATA[<h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><p>本文进行6.824中第一个lab的分析，基于课程的要求，本文不给出对应的代码，当然，本文的主要目的是对于本个lab的实现进行自我复盘，回顾下要实现MapReduce这种框架的最小可行实现需要我们来提供什么</p>
<span id="more"></span>

<p><img src="/2025/07/15/%E5%88%86%E5%B8%83%E5%BC%8F/lab1/b809360fe8b6654b2ecf15eabbd9299.png" alt="b809360fe8b6654b2ecf15eabbd9299"></p>
<h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>​	填充当前lab中提供的<code>master.go</code>,<code>worker.go``,rpc.go</code>。为这三个文件填充基本的通信逻辑，要求能够内部自动进行对应的map和reduce任务之间的调度，实现外部传入对应的处理文件以及处理逻辑，由内部来自行进行调度处理，并在最后返回给调用层对应的操作完成的消息</p>
<p><strong>分工</strong></p>
<p>基本分工如下：</p>
<ul>
<li><strong>master.go</strong>中实现框架中调度中心的职责，要求其能够管理一定的整个系统的状态信息，实现自动监管<strong>worker</strong>，实现对于<strong>worker</strong>的任务分发和状态监控，实现对于整个<strong>MapReduce</strong>执行进度的判断</li>
<li><strong>rpc.go</strong>中实现一些结构体的定义，实际上是一些通用结构体的抽离，使得对应的逻辑更加优雅，对于<strong>master</strong>和<strong>worker</strong>都可见，理论上你可以将这个文件中的内容全放到别的文件中去，但是这样相对来说不好维护</li>
<li><strong>worker.go</strong>中实现框架中实际逻辑处理者的逻辑，实际上，该文件中的地位就对标与MR框架中的<strong>MapWorker</strong>和<strong>ReduceWorker</strong>俩者</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h2><blockquote>
<p>我们需要详细来分析一下本lab中对应的master和worker到底需要自己实现什么功能，以及我们需要什么基本结构才能够支撑我们的自动化分布式处理任务的功能</p>
</blockquote>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>​	<strong>Task</strong>的结构设计是整个框架设计中的重中之重，其需要保留一个<strong>Map</strong>任务或者<strong>Reduce</strong>任务在<strong>Master</strong>和<strong>Worker</strong>之间流通的数据，需要保证对应的<strong>worker</strong>从<strong>Master</strong>中拉取任务的这个操作能够正确进行</p>
<p>​	一个Task本身存在俩种类型，我们先来考虑Map下的Task需要的信息</p>
<ul>
<li>当前任务的路径。前面已说，本个lab中一个Map的Task的基本单位是一个文件，通过对应的路径，worker能够通过一个FileSystem去找到对应的输入文件</li>
<li>当前任务的状态，一个长久流通的任务势必需要存在能够标识当前任务的状态，就比如是pending，还是finished，还是failed等，这些字段是必须的，就比如，我们不会期望一个已经被完成的任务还会被重复处理</li>
<li>当前任务的类型。一个任务至少需要能够区分其是Map还是Reduce类型，当然也可以单独的抽离出俩个特殊实现，个人为了简单只是使用一个普通的字段进行标识。同时需要注意的是，为了后续能够进行退出以及其他的扩展操作，个人维护了一个字段用于标识当前任务到底需要<strong>worker</strong>执行什么操作</li>
<li>当前任务的部分额外状态。为了方便后续的扩展，比如一些容错处理等，我们可以考虑维护一些额外的元信息字段，最简单的，就比如一些时间信息，方便后续最直观的超时处理的预留拓展</li>
</ul>
<h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>​	对于一个调度中心，我们需要维护一系列的元信息来支持我们后续的系列维护。首先从Master所需要实现的功能入手，来逐个分析需要使用哪些结构储存元信息</p>
<ul>
<li><p>需要执行的任务。本次lab中对应的任务由外部传入，具体的为一系列的文件，每个文件即为一个任务。也就是说，本次lab中省去了关于一个大文件分割的要求，直接提供了对应的<strong>split</strong>方便我们使用，为了能够后续使用这些文件，我们需要储存这些文件的信息，具体的，在当前lab中，即是对应的路径名</p>
</li>
<li><p>需要分割的任务数量。在本次lab中，对应的<strong>Map</strong>的<strong>Task</strong>数量与传入的文件数量一致，即一个输入文件即可作为一个<strong>Task</strong>进行处理。对于<strong>Reduce</strong>的<strong>Task</strong>数量，其本身应可由上层的调用者进行指定，即需要信息来储存该外部指定的最终期望输出的系统中<strong>Reduce</strong>阶段的<strong>Task</strong>数量。因此，对于Map的Task数量，我们不需要储存，可以直接根据传入文件的数量进行判断，但是外部指定的最终输出文件数量我们需要储存</p>
</li>
<li><p>当前系统中的任务进度，在一个MR框架中，自然而然存在俩个阶段，一个Map工作阶段，一个Reduce工作阶段，其俩个阶段不存在交错，本次实现中需要对这俩个阶段是否完成进行标识。同时，lab中要求我们提供一个可以标识当前系统是否完成的方法，为了实现，我们可以使用这里的这俩个阶段标识来提供该方法</p>
</li>
<li><p>当前系统中的任务状态。系统中一个任务是交由一个worker处理的，即Task是绑定对应的Worker的。虽然在本次lab中，实际上即使Worker崩溃了对应的已经完成的Task结果其也不会丢失，因为只是保留到本地的磁盘中。但是在论文中，我们也了解到，为了提高分布式下的扩展，我们应该维护对应的Worker与Task的对应的信息，无论是Map还是Reduce类型的，这样方便之后在一个Worker崩溃时候的容错处理。当然，在我们本次lab中，我们不用实现如此深的容错机制</p>
</li>
</ul>
<h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><pre><code>  对于一个Worker，相对来说，我个人倾向于将其设想为一种无状态的模式，应该一个worker无状态才不会牵连过多的崩溃时行为，但是其本身至少需要做几件事，应该在MR框架中，对应的**Worker**任务处理完成之后是会将文件写入一个**FS**的，所以我们至少需要维护对应的Worker与对应的Task之间的部分信息，当然，这个可以直接放置在Master中去管理(个人是如此做的)。但是其本身也会引申出来一个问题，就是Master也需要了解当前的Worker到底是一个怎么样的Worker，才能够进行对应的映射建立，所以一个Worker本身需要拥有一个属于自己的元信息，但最好足够简洁
</code></pre>
<ul>
<li>唯一标识符。个人设计中，利用一个简单的UID来进行对应的worker的标识，但是由于Master启动时是不了解对应的下属的worker信息的，所以为了方便，我们考虑该信息由Master进行统一分配，具体的想法就是每次worker启动时去申请Master对应的注册信息，然后由Master本身来管理这个信息</li>
<li>当前任务元信息，无论如何，一个worker想要实现其的功能，那么其必须保留一定的任务信息，即每次拉取之后的任务信息。然后其才能够在其内部进行处理，当然，理论上你可以不保存这个任务元信息，只限制对应的内部调用的信息流转，但是你应该也能考虑到这种设计上的麻烦</li>
</ul>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>为了能够更好的理解这个lab，我个人简单的将对应的Master和Worker的流程分割为了几个状态</p>
<p>其中Master的状态很简单，就只有以下几个。</p>
<p><img src="/2025/07/15/%E5%88%86%E5%B8%83%E5%BC%8F/lab1/image-20250710152139505.png" alt="image-20250710152139505"></p>
<p>​	我个人的考虑是，对应的Master在初始化之后，其就进入<strong>Map Task</strong>的处理阶段，在该阶段，其会不断检查一个MapDone标志是否被置为true来判断是否需要进入下一阶段，对应的<strong>Reduce Task</strong>阶段同理。在俩个阶段都走完之后，其会进入结束阶段，在该阶段中其会上报对应的状态，告诉上传已经完成任务。</p>
<p>​	事实上，在我个人的设计中，对应的Hanlder Map Tasks阶段的判断是Handle Reduce Tasks阶段判断前每次都会进行的，这里的状态图没有列出对应的状态回退时的状态转移。</p>
<p>至于Worker的状态，其也很简单</p>
<img src="/2025/07/15/%E5%88%86%E5%B8%83%E5%BC%8F/lab1/image-20250710155142265.png" alt="image-20250710155142265" style="zoom:80%;">

<p>​	具体流程就是在Initialization阶段之后，开始循环的拉取任务，如果任务类型不为Exit，那么其会一直拉取，否则其会直接结束进程。整体的状态转移图并不复杂，主要在于其中的一些状态本身的实现。</p>
<p>​	无论对于Master或者Worker，其首先需要考虑的都是对应的Initialization阶段需要初始化什么数据。由于本个框架实际的启动逻辑是这样的，其先启动一个Master实例，然后再逐步启动多个Worker实例，所以我们对应的俩个的初始化之间的数据成员需要有一定的先后顺序以及对应的职责需要清晰。</p>
<p>​	下面分析一下个人实现的程序中的几个流程</p>
<ul>
<li>在Master的初始化中，我们需要去读取应用层传递过来的任务以及对应的设定的参数(ReduceTasks的数量)，并且根据这些外部的信息以及内部自己预设的信息初始化我们对应的结构体，在本次lab中，即使一个master结构体</li>
<li>在Master初始化之后，其对应的不需要主动操作，其本质上是一个服务器中的服务，等待他人调用即可</li>
<li>对应Worker初始化，其需要在启动时候去Master中注册本身，为此，需要保证Worker启动在Master启动之后，这个由lab本身保证了。因此，在Worker启动时，我们可以放心去调用对应的RPC方法。</li>
<li>Worker启动后，其主动发出一个请求到Master中，像其中请求注册，若成功，Master返回一些信息。Worker持久化到本地作为唯一标识，在之后，其开始不断向服务器发起拉取任务的请求(通过RPC)，直到收到一个类型为Exit的请求后，Worker退出</li>
</ul>
<blockquote>
<p>遵守课程的要求，本文不给出任何对应的实现代码，主要是理清对应的实现思路以及基础的实现逻辑，目前已经基本理清了本人在实现本lab中的一些逻辑。</p>
<p>⚠️ 警告：本文为本人完成 6.824 作业后的复盘笔记，未包含任何作业代码，也不建议作为作业实现参考。请严格遵守课程 Honor Code 独立完成。</p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>6.824 lab2A思考</title>
    <url>/2025/07/20/%E5%88%86%E5%B8%83%E5%BC%8F/lab2A/</url>
    <content><![CDATA[<h1 id="Raft2A"><a href="#Raft2A" class="headerlink" title="Raft2A"></a><strong>Raft2A</strong></h1><p>本文进行简短的6.824中lab2的简单实现梳理，以及对应的注意事项</p>
<span id="more"></span>

<h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p><img src="/2025/07/20/%E5%88%86%E5%B8%83%E5%BC%8F/lab2A/image-20250723155619423.png" alt="image-20250723155619423"></p>
<p>lab2A中需要实现的基础目标为以下几点:</p>
<ul>
<li>实现基础的选举行为，需要能在无网络故障下选举出一个<strong>Leader</strong>，也需要在网络不可靠环境下成功选举并且能够在Leader死亡时重新选举出一个<strong>Leader</strong></li>
<li>实现基础的心跳行为，需要Leader能够维护其的基本心跳行为，能够维护其的<strong>Leader</strong>的地位</li>
</ul>
<h2 id="Election"><a href="#Election" class="headerlink" title="Election"></a>Election</h2><p>​	选举操作是一个由基础的相互投票行为组成的，具体的RPC定义在论文的<strong>Figure2</strong>有详细的解释，如下</p>
<img src="/2025/07/20/%E5%88%86%E5%B8%83%E5%BC%8F/lab2A/image-20250723155931141.png" alt="image-20250723155931141" style="zoom:80%;">

<p>​	其中，我们本次lab2A中需要实现的是基础的投票行为，即不存在日志的投票参数，但是，为了后续的可扩展性，我们需要将对应的日志信息一并管理，否则会导致后续需要实现时会出现Review地狱。</p>
<p>​	关于election的实现，我们需要分为俩个方面来考虑，一方面是接收方，一方是发起方，更清晰的，一方是收到一个服务器的投票请求的情况，另外一方是发起投票请求的。在实际的代码实现中，抽象出来实际上就是RPC的客户端(发起方)和服务器方(接受方)的俩个处理实现。我们可以隔离出来分析实现。</p>
<h3 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h3><p>​	对于Election的投票来说，其接收方的结果只有俩种，无非是投或者不投。表现在RPC中，即是最终的<strong>Result</strong>中的<strong>voteGranted</strong>为<strong>true</strong>&#x2F;<strong>false</strong>。但是这样分析时无趣的，我们需要关注实际的场景，即论文中分析到的，来详细列出实际的什么参数的状态会导致<strong>true</strong>，什么的参数情况会导致<strong>false</strong>。在这个过程中，我们势必需要牵扯到接收端和发送方上的各自状态，该系列状态在<strong>Figure2</strong>中也存在详细的介绍，如下</p>
<p><img src="/2025/07/20/%E5%88%86%E5%B8%83%E5%BC%8F/lab2A/image-20250723161100200.png" alt="image-20250723161100200"></p>
<h4 id="投票规则"><a href="#投票规则" class="headerlink" title="投票规则"></a>投票规则</h4><p>下面给出关于投票逻辑的部分分析，其中大多是关于论文<strong>5.2 Leader election,5.4</strong>中的一些总结</p>
<ul>
<li><strong>at most one candidate in a given term</strong></li>
</ul>
<p>​	只投一票原则，在一个Term(任期)中，一个接收方至多将其的选票投给一个<strong>RequestVote RPC</strong></p>
<ul>
<li><strong>first-come-first-served basis</strong></li>
</ul>
<p>​	先到先得原则，在一个Term(任期)中，一个接收方总是会优先投给首个到来的<strong>RequestVote RPC</strong></p>
<ul>
<li><strong>returns to follower state whenever needed</strong></li>
</ul>
<p>​	在任何时候，只要需要，一个候选者接收方都应该回退为<strong>Follower</strong>，具体的，在投票阶段，如果其收到一个来自一个合法的          	<strong>Leader</strong>的<strong>AppendEntries RPC</strong>，那么无论当前选举进度如何，其需要立刻放弃选举并且更新本身的状态并跟上该Leader</p>
<ul>
<li><strong>update status whenever needed</strong></li>
</ul>
<p>​	在任何时候，只要需要，无论当前服务器处于什么状态，其都需要回退为<strong>Follower</strong></p>
<ul>
<li><strong>no Leader state globally</strong></li>
</ul>
<p>​	对于一次选举，算法不必保证其一定会选出一个Leader，系统中可以存在实际上不存在Leader的Term状态，但需要保证该种状态不	会频繁出现。具体的，通过随机化选举超时时间来实现</p>
<ul>
<li><strong>more up-to-date guide</strong></li>
</ul>
<p>​	最新者当选原则，算法需要保证系统具有一定的FT，不能在一个服务崩溃后数据丢失的过于严重，因此需要使用<strong>up-to-date</strong>判断当	前的候选者中的具有最多上次任期中的信息的当选Leader，具体的可以参考5.4的分析。至于more up-to-date的判断，其在5.4一节	中也有分析</p>
<h3 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h3><p>​	一个发送方是一个选举操作的状态起始点，一系列的选举行为都要基于一个发送方开启一轮属于其的选举周期的动作。表现在RPC中，即是一个服务器通过一系列逻辑启动一轮RPC发送请求接收方投票。我们此处需要来分析整个基础流程，即一个发送方需要什么时候触发选举，触发之后需要进行什么行为完成选举，完成一轮选举之后的行为</p>
<h4 id="选举要求"><a href="#选举要求" class="headerlink" title="选举要求"></a>选举要求</h4><ul>
<li><strong>one election one term</strong></li>
</ul>
<p>​	在<strong>Raft</strong>中，一次选举是基于一个<strong>Term</strong>(任期)的，一个服务器每发起一次选举，需要更新其的任期及一些附带的状态，其才有资格开	启一次选举</p>
<ul>
<li><strong>limited election time</strong></li>
</ul>
<p>​	为了保证系统具有一定的FT，一次选举流程不能持久存在，若一次选举使用了过多时间，Raft中要求终止这次选举，避免一些麻烦的	错误条件发送</p>
<ul>
<li><strong>call elections whenever possible</strong></li>
</ul>
<p>​	只要可能，Raft中的服务器都会发起选举，具体的，包括上一次选举初次停止，定时器到期等等，其在论文中有完整的描述</p>
<ul>
<li><strong>stop elections whenever possible</strong></li>
</ul>
<p>​	只要需要，一个服务器就会停止当前的选举，其可能是收到一个Leader的心跳或者前文提到的选举超时等</p>
<ul>
<li><strong>become a leader whenever possible</strong></li>
</ul>
<p>​	只要可能，一个服务器就会尝试成为系统中的<strong>Leader</strong>，在Raft中，只有一种情况可以成为<strong>Leader</strong>，即在一次选举流程中收到了超过	半数的投票</p>
<p>为了实现上述几个要求，在Raft中，还要求了几个额外的机制来辅助完成</p>
<ul>
<li><strong>random election timeout</strong></li>
</ul>
<p>​	随机化选举超时时间，通过随机化超时时间，使得每个Leader可以错峰开启一次Election，使得<strong>non-Leader</strong>状态不会在系统中频繁	出现</p>
<ul>
<li><p><strong>send a heartbeat immediately when first become Leader in one term</strong></p>
<p>一个服务器成为Leader之后，其需要立刻发送一次广播心跳，用来压制其他的服务器成为Leader来维护唯一Leader状态</p>
</li>
</ul>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>为了能够较好的完成本lab，我们在开始实现之前需要注意一件事，就是本次lab中我们需要如何管理我们的代码实现，全部耦合在一个raft.go中是难以接受的，后续的review是非常麻烦的，由于后续的lab2剩余部分甚至于lab3等都需要使用到该文件，所以我们必须以一种较为优雅的方法来维护本项目，把其按照一种较为优雅以及可维护的方法进行拆分。</p>
<ul>
<li><strong>small and complete</strong></li>
</ul>
<p>​	关于实现代码的拆分，我们考虑每个文件中的内容应当小而完整，一个选举操作会涉及到接收方和发送方的操作，那么关于接受方和	发起方的election，我们就需要拆开来实现。在我个人的构想中，可以使用一个文件来承接RPC的发起方的实现，一个文件来承接	RPC发送方的实现。</p>
<p>​	实际上，借用本人关于C++中使用grpc的经验来看，倾向与将客户端的逻辑和服务器端的逻辑分开实现，使得各自独立维护。同时，	存在一个额外的文件储存类似的RPC定义，就类似于grpc中的protoc文件</p>
<ul>
<li><strong>high cohesion</strong></li>
</ul>
<p>​	一个代码实现文件应该尽可能只依赖于本文件中的内容，不需要经常跳转别的文件中查找，当然，在本次lab中，关于raft.go没有办	法，势必会大量涉及到关于其他文件的使用，这个无可厚非</p>
<p>综上，个人倾向于将项目结构划分为以下几个大块</p>
<ul>
<li><strong>rpc.go</strong></li>
</ul>
<p>​	储存本项目中使用到的RPC定义</p>
<ul>
<li><strong>request_vote.go</strong></li>
</ul>
<p>​	储存本项目中投票的RPC的服务器端实现</p>
<ul>
<li><p><strong>leader_election.go</strong></p>
<p>储存本项目中投票的RPC客户端实现</p>
</li>
<li><p><strong>raft.go</strong></p>
</li>
</ul>
<p>​	整合整个lab逻辑的实现</p>
<p>后续可能存在日志推送等的逻辑实现，但是大多与此类大差不差，在这骨架之上适当补充文件即可</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>6.824 lab2B思考</title>
    <url>/2025/07/24/%E5%88%86%E5%B8%83%E5%BC%8F/lab2B/</url>
    <content><![CDATA[<h1 id="Raft2B"><a href="#Raft2B" class="headerlink" title="Raft2B"></a><strong>Raft2B</strong></h1><p>本文进行有关lab2B的实现思路的梳理</p>
<span id="more"></span>

<h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p><img src="/2025/07/24/%E5%88%86%E5%B8%83%E5%BC%8F/lab2B/image-20250724131832492.png" alt="image-20250724131832492"></p>
<p>lab2B中需要实现的目标相对简洁，但是相对来说麻烦许多。课程描述的任务十分简洁，就是使得当前的代码支持追加日志的RPC操作。但是这个需要费的心力比起2A来说复杂许多…</p>
<ul>
<li>完善Raft上一个服务器上的状态</li>
</ul>
<p>​	为了能够支持日志，我们需要引入一些额外的状态，具体的在Figure2中有描述</p>
<ul>
<li>进一步完善选举机制</li>
</ul>
<p>​	2A中实现的选举机制只是建立在基本的投票共识上，由于没有引入日志属性，所以其中的选举缺乏了一些机制，例如论文5.4中要求	的由日志来保证的选举安全性</p>
<ul>
<li>实现基本的日志收发机制</li>
</ul>
<p>​	日志本身的推送是本次lab中的核心，其需要多个环节的实现以及联调，其中涉及了收集数据，分发数据，上报状态等多个环节需要	处理</p>
<ul>
<li><p>进一步优化代码结构</p>
<p>在此次lab中，我们特别需要注意的一件事，就是一个lab的实现会是后续的lab的基础，后续的lab可能还会涉及到本lab代码的修改，不能使得代码过于难以维护</p>
</li>
</ul>
<blockquote>
<p>关于选举部分的处理都需要基于现有的本机上的<strong>Log</strong>状态，所以，本次我们优先来分析关于基础的<strong>AppendEntries</strong>需要注意什么</p>
</blockquote>
<h2 id="AppendEntries"><a href="#AppendEntries" class="headerlink" title="AppendEntries"></a><strong>AppendEntries</strong></h2><p>关于日志推送该操作，个人认为其基本只存在几个简单的状态，如下图</p>
<p><img src="/2025/07/24/%E5%88%86%E5%B8%83%E5%BC%8F/lab2B/image-20250724133314947.png" alt="image-20250724133314947"></p>
<p>简述一下流程</p>
<ul>
<li>一个Leader服务器始终处于Acceptor(监听)状态，外部通过**Start()**接口传入其所需要本cluster执行的command</li>
<li>Leader收到command之后，需要将本次请求持久化到本地，然后触发AppendEntries，将本次请求广播到本cluster中其他server</li>
<li>当且仅当超过半数cluster中的server都ACK了本次操作时，本个command会被标记为commited</li>
<li>在一个command被标记为commited之后，Leader需要向上层上报本次操作</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>上述流程描述的很清晰，但是，对应的其中存在很多的实现细节需要注意，本次个人写本文本质上也是为了理清思路</p>
<p><strong>Acceptor</strong></p>
<ul>
<li>监听到Command到来时需要进行什么动作</li>
</ul>
<p>​	一次Command到来时，由于其本身只是一段临时的指令，我们需要将其持久化到本地中。基于论文中的思路，一个Log基本需要具有term和command的属性，因此我们需要一次来进行一些基础的封装等。同时，论文中提到后续可能需要实现snapshot，如果需要，snapshot本身还需要日志的一些属性配合，需要注意一个server中的<strong>log[]</strong> (Figure2)的实现</p>
<ul>
<li>需要怎么进行由Acceptor向Deliver的状态转移</li>
</ul>
<p>​	成功持久化数据之后，我们需要广播该Log，将其持久化到cluster中的其他服务器中，我们需要考虑该操作的时机以及实现的程度，在论文中，其中说明需要使用<strong>AppendEntries</strong>这个RPC进行对应的操作。实际设计中，存在一个权衡，就是是否需要与心跳共用该RPC，还是说需要抽离出来独立。这个需要考虑实现该RPC的时机</p>
<ul>
<li>需要怎么确保一个Log已经被大多数Server给ACK</li>
</ul>
<p>​	这个的实现思路很自然，即通过一个总的调度goroutinue来管理该类操作，但是该goroutinue会相对麻烦。就比如，如果在上一条Log还没有被commited时又存在Log被推送进行需要怎么处理等等</p>
<ul>
<li>需要怎么确保一个commited的操作能够被上层感知</li>
</ul>
<p>​	该操作在tip中有提到，而且实际的lab代码中，已存一个chan作为上报的通道。同时，在对应的guide等文件中，提到，推荐使用一个cond来进行本类上报操作的管理</p>
<blockquote>
<p>上诉问题肯定并非全部，不过当前已经足够麻烦，先来实现并解决上诉问题，若存在其他问题再来补充</p>
</blockquote>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>对于当前Lab的实现，个人目前存在了一个三板斧。</p>
<ul>
<li>实现基础的RPC收发操作，即实现论文中的逻辑处理</li>
<li>封装调用逻辑，客户端调用此类RPC需要与应用端进行联调</li>
<li>整合主程序逻辑，将调用逻辑整合到现有的系统中</li>
</ul>
<p><strong>基础成员</strong></p>
<p>为了能够实现日志的成功复制以及持久化，服务器进程中势必需要储存一些信息来进行标识，其在Figure2中存在详细的介绍</p>
<ul>
<li><strong>commitIndex</strong> 	标识当前服务器上的已经提交的日志的索引</li>
<li><strong>lastApplied</strong> 	    标识当前服务器中已经提交到本地状态机上的最新日志的索引</li>
<li><strong>nextIndex[]</strong> 	    标识当前服务器所知的其他服务器上的下一个未被确认的日志的索引</li>
<li><strong>matchIndex[]</strong>          标识当前服务器已知的其他服务器上的已经确认复制成功的日志的索引</li>
<li><strong>log[]</strong>  			 储存当前服务器中留存的日志的信息</li>
</ul>
<p>分析一下当前的几个成员会在日志复制中扮演的作用</p>
<ul>
<li>服务器接收到command请求</li>
</ul>
<p>​	封装当前command请求为一个有状态的log，依照论文中的说法，一个合法的Log需要存在一个Term标识(Each log entry stores a 	state machine command along with the term number when the entry was received by the leader),以及一个index信息(Each log 	entry also has an integer index identifying its position in the log.)。在封装完成之后，Leader需要将其持久化到本地中</p>
<ul>
<li><p>服务器发起日志复制请求</p>
<p>当Leader收到一个新的请求后，其需要将该请求分发到各个Follower中，此阶段涉及到对应的Follower上的信息，依照论文中的说法，我们需要将此前未被改服务器ACK的数据也一并发送出去，因此，该阶段涉及到**nextIndex[]<strong>和</strong>matchIndex[]**的信息使用(This also commits all preceding entries in the leader’s log, including entries created by previous leaders.)</p>
</li>
<li><p>服务器完成日志复制</p>
<p>在当前Leader完成将当前日志复制到cluster集群中的大多数服务器中，此时该Log的状态成功转变为了<strong>commited</strong>的状态,此个状态会涉及到一些新的状态转移，比如，对应的本地的commitIndex等，同时，依照论文所说，Leader本身需要在此时去上报Log已经处理成功。</p>
</li>
</ul>
<blockquote>
<p>When the entry has been safely replicated (as described below), the leader applies the entry to its state machine and returns the result of that execution to the client.</p>
</blockquote>
<p><strong>RPC参数定义</strong></p>
<img src="/2025/07/24/%E5%88%86%E5%B8%83%E5%BC%8F/lab2B/image-20250725145424880.png" alt="image-20250725145424880" style="zoom: 50%;">

<p>在本次RPC中，我们只考虑使用为推送日志的情况，并不考虑心跳用途下的RPC参数场景。</p>
<ul>
<li>日志匹配</li>
</ul>
<p>​	本次RPC使用一个偏移索引以及外部约束的定义来判断当前是否存在匹配为止，规则简单如下: 如果一个<strong>Follower</strong>的Log[]中对应于	prevLogIndex下的Log的Index与prevLogTerm相同，那么视为匹配，否则视为不匹配，具体原因参照论文5.3节定义</p>
<ul>
<li>数据携带</li>
</ul>
<p>​	本次RPC中会一次性携带所有的Leader认为的冲突的日志数据，如果匹配成功，需要将该些日志数据进行拷贝，否则，需要重新匹配</p>
<p><strong>RPC服务器端实现</strong></p>
<p>在论文中，对于AppendEntries的逻辑处理行为进行了一些约束，此处来基于最简单的实现进行一些分析</p>
<ul>
<li>日志匹配</li>
</ul>
<p>​	如上文所说，该RPC的参数中的prevLogIndex和prevLogTerm字段是处理是否匹配的核心，判断逻辑也很简单，上面已经简单讲	过，这里不再赘诉。但是关于不匹配的场景，我们还是需要进行一些探讨。按照论文中所说，当一个日志不匹配时，其需要Leader	在下次发送请求时去继续往前移动一个日志尝试匹配。这种算法是简单但是不一定高效的。在论文中，其中提到了这种匹配算法的优	化，就是在服务器处理端去索引到一个匹配项，然后讲该匹配项的信息返回，减少RPC次数以及对应的网络I&#x2F;O。但是，请注意，实	际的实现并没有那么简单，这里提供一个可能的思路，以Term为粒度进行匹配的回退</p>
<ul>
<li>日志复制</li>
</ul>
<p>​	日志复制本身逻辑并不复杂，总结出来就是一个操作，找到本机上对应的匹配项，将该匹配项的后续数据全部截断，然后append上	由RPC所传输过来的数据即可</p>
<p><strong>RPC客户端实现</strong></p>
<p>在实际的实现中，该RPC的客户端的实现可以说是这个环节中最麻烦的一个，其涉及的状态很多，需要小心管理</p>
<ul>
<li><p>参数构建</p>
<p>客户端RPC中最基本，同时也最为核心的即为参数的构建。对于本次实现，其中最麻烦的就是关于precLogTerm和prevLogIndex的处理。但是，实际上，由于这俩个只是关于一个Log的属性，所以本质上，我们需要在意的是我们需要如何去找到适配一个Server的Log。</p>
<ul>
<li><p>Log地位</p>
<p>本次所需要寻找的Log是当前系统中已知的关于特定的server的最后的匹配日志项。即，若索引x上为双方匹配的最大的索引(索引从1开始就算)，那么x即为我们本次需要找的日志，但x-1索引所对应的日志信息则是实际上我们需要使用的信息。</p>
</li>
<li><p>Log定位</p>
<p>已知，nextIndex[]储存的信息为当前Leader已知的匹配项的索引，故，不难推出，关于上述Log的寻找，需要使用该信息进行定位，具体的，由于nextIndex[peer]储存的是peer上的最新匹配的索引，索引nextIndex[peer]-1自然也就是对应的匹配索引的前一位。但是，在逻辑上，这是对于对端服务器的建模，我们无法取得对端服务器上的信息。此时就需要一个匹配的定义来辅助实现，由于匹配，所以Leader和对应的Follower上的Log信息一致，我们可以直接在当前Leader上去查找对应的信息拿来使用即可</p>
<blockquote>
<p>注意，在实际实现中，一些个人的实现可能会遇到一些与定义存在冲突以及存在一些边界的情况，请依照论文为准</p>
</blockquote>
</li>
</ul>
</li>
<li><p>确认提交</p>
<p>论文中说明，当一条Log被推送到大多数的服务器上后，该日志可以被视为<strong>commited</strong>，当一个日志成为commited之后，Leader需要将该状态上报给Client。但是实际上，这个实现起来相当复杂，下面只给出几个实现中可能会遇到的问题</p>
<ul>
<li>如何去确认一个Log已经被commited，特别是在部分Server会失联的情况下(注意:使用一个全局计数器是很困难的)</li>
<li>如何去高效的提交一个Log(tips: lab instruction中有说明)</li>
<li>如何保证提交的并发安全</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库介绍</title>
    <url>/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/0-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>​	在这一个分类中，将记录我的数据库学习过程，主要是个人在学习15-445网课的思考，敬请期待吧，没什么好说的，让我们开始吧。之后有什么要补充的将会在这篇文章中进行补充(如果没忘的话)。</p>
<span id="more"></span>



<p>​	首先，我需要对自己在modernSQL中体验到的一个感觉现说一下。</p>
<p>​	在一开始时会有很多的概念，这种东西会很消耗你的激情。此时我们需要有些东西来进行补充，而我认为的最好的补充方法就是进行一些手操，最直接的，就是去使用mySQL的mySQL Workbranch去手搓一个，无论简单还是复杂。</p>
<p>​	我体验下来的一个最直接感觉是，无论是什么数据库操作软件，命令行也好，图形化也好，最重要的其实是它底下的那个数据库，只要知道了对于的数据库。那么我们接下来进行的任何对这个数据库进行的查询，插入等等操作，都是一些对我们自己技能的进一步的封装，同时也是对于该软件的一步步api的了解罢了。正如QT框架一般。</p>
<p>​	需要注意的是，在该次学习中，书籍中的中级SQL和高级SQL并没有进行学习，这俩个章节主要是提高对于SQL使用的熟悉，但是这次学习主要的侧重是对于底层原理的了解，所以在这里先跳过，在之后有机会再回来学习。</p>
<p>​	对应的是，在15445的网课之中，对于SQL语句的学习也仅仅只有一节课进行一些简单的了解而已，之后就进入到了关系代数等的学习了。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>关于CS学习的个人思考</title>
    <url>/2025/04/26/%E6%84%9F%E6%82%9F/thought/</url>
    <content><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>​	2025&#x2F;4&#x2F;26，今天，我又陷入了有关我自己一个CSer到底应该如何学习CS的思考。</p>
<p>​	在之前，我整个大一阶段都是一个摆烂的阶段，在这个阶段中，我对于整个CS的了解是相当贫乏的，甚至可以说整个一年以来都是止步不前的。所幸的是，在大一的后半段时间，我简单的进入了一点算法的学习，简单的把自己带入了算法的领域。虽然说到现在大二这个阶段我早就将算法这一块排除我接下来努力的区域了，但是所幸的是我没有将自己的CS思维僵化。</p>
<p>​	万幸的是，在大一下的最后时间中，我简单的进入了一个小游戏demo的学习，在这个过程中，我接触到了一个相当重要的朋友，一个东南大学的跟我同级的学生。不知为何，我开始有了一种不甘心的想法，我在想着为什么我会输给他，因此，我开始不想输给他。正是因为有了这一层的压力。我正式开始了我的CS入门。</p>
<p>​	可以说，一开始的我是相当磕磕绊绊的，甚至可以说是完全不知道该怎么走。所幸的是，对应的哪个985同学总是会发表一些言论，说目前在学哪本书，在学哪个领域。由于一种不甘心的情绪，我一直在跟着他的进度去搞，虽然说是一种照猫画虎，不过这倒也是给我的CS学习正式往前迈进了一步。</p>
<p>​	时间一直推到了后面的大二阶段，在这个阶段，我开启了影响最大的一个时期。还是在这个时期，那个同学去学了CSAPP，我也算是一种跟风吧，也去学了这本书。一学了这本书之后，我突然感觉惊为天人，原来CS还可以这么学，我突然对于CS的兴趣也给提了起来。我逐渐开始自己去学习一些书本，但是直到大二上学期结束这个阶段，我还是照着那个同学走过的路在跟着走，在这个学期中，我了解了CSAPP，设计模式，数据结构，还有一些零碎的东西。</p>
<p>​	接着，逐渐出现了一些分流，到了寒假，由于个人问题，我需要去进行打寒假工，而那个同学选择了去完成一个JAVA的黑马项目。我们的路途逐渐发生了改变。但回想过来，这个时间点可以说是真正推动我走向一个属于自己的CS路线的抉择。在这个令人感到无聊的寒假工中，我突然发现了这种流水线是如此的无趣，我绝对不能再之后再回到这里。到了该寒假工结束之后，我感觉我个人发送了一种全新的蜕变。我不再是将学习视作为一种应付的事，而是将其视为了一种能够摆脱自己命运的途径。</p>
<p>​	接下来，我到了大二下，也就是我现在的这个学期。可以说，这个学期一开始，我突然感觉到了一种从所未有的紧迫感，我突然发现之前已经浪费了过多的时间，我已经没时间再浪费了。我收拾心情，开始使自己进入一个学习阶段。不知道是否是压力的原因，我在这个阶段的学习相当的自律。我完成了简单的数据库的了解，当然只是简单的过了一遍。然后我突然发现，好像大二下也可以去实习，我就开始我的项目的学习，然后我又发现我的项目需要网络的基础前置，我又开始去补充网络的基础。</p>
<p>​	在网络的学习中，我突然发现了一种前所未有的通透感，我突然发觉我好像把前面CSAPP等领域学的东西都串了起来，或者说，我使用了前面学到的基础知识来支撑起了我的模块领域的快速入门学习。在这个阶段中，我越学越透彻，我感觉我好像找到了自己的学习路径。我也没有再去询问那个同学他的学习路线，而是专注与自己的学习了。我感觉我开始逐渐往一个真正独立的CSer上面走了。</p>
<p>​	再之后，我快速的过了网络的基础之后，我进入了我的项目的学习。我的项目我个人感觉其实也是过的很快。甚至于快到我现在已经忘记了前面的一些区域的内容了。这也是为什么我这一大段字会出现的原因，我开始了我自己的一个review，我开始审视自己的整个学习过程了。我回到了前面项目一开始搭建的服务器中，我突然发现我看不懂了，但是我再深入的去review了该服务器，我突然又发现，好像又通了。甚至于把之前一些模糊的地方，也给打通了。</p>
<p>​	之前网络中关于ASIO和Beast等的内容，由于过的很快，我甚至于不了解对应的关系，但是在这次的review中，我重新掌握住了对应的逻辑。我明白了对应的其实是一个应用层协议的添加所带来的特化。而，这个，又是我在空闲时补充的计算机网络基础课程中的东西，这些个基础东西又给我补充了这些个项目。</p>
<p>​	自此，我发现了属于我自己的一个简化的学习路线。由广度的初步学习，来进入深度的学习，再由深度学习中会产生的一些问题，来再次回到我们广度的学习中去，以此来实现我整个学习过程中的闭环。而且，这对于我来说是一种类似于正反馈的机制。我在构建我的基础时避免了一些漏洞，在实际的项目中学习，再在review后重新发现了我对于项目的一个不了解，这个不了解又推动我回去对应的基础广度上的学习补全。这实现了对于我来说的一个闭环。而且这种闭环不断推动着我向前去学习，至少现在对于我来说是这样的。</p>
<p>​	</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern SQL</title>
    <url>/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL/</url>
    <content><![CDATA[<h1 id="Modern-SQL"><a href="#Modern-SQL" class="headerlink" title="Modern SQL"></a>Modern SQL</h1><h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL/image-20250217233059625.png" alt="image-20250217233059625"></p>
<span id="more"></span>	

<p>​	需要注意的是，一个数据库系统中是存在着多个组件的，比较简单的理解的话。一个系统首先需要包括几个用来进行操作的语言。</p>
<p>其中包括的几种语言有:**数据操作语言(DML)，数据定义语言(DDL)，数据控制语言(DCL)**。</p>
<p>​	对于这三种语言，我们在这里进行一个相对简单的接触即可。</p>
<ul>
<li><strong>数据操作语言（DML）</strong>：用于操作数据库中的数据。常见的DML命令包括<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>，这些命令帮助我们从数据库中查询数据、插入新数据、修改现有数据或删除数据。</li>
<li><strong>数据定义语言（DDL）</strong>：用于定义和管理数据库中的结构，例如表、视图、索引等。常见的DDL命令包括<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>等，用来创建、修改或删除数据库的结构。</li>
<li><strong>数据控制语言（DCL）</strong>：用于控制数据库的访问权限。常见的DCL命令有<code>GRANT</code>（授予权限）和<code>REVOKE</code>（撤销权限），它们允许数据库管理员控制哪些用户可以访问哪些数据。</li>
</ul>
<p>​	</p>
<hr>
<p>​	粗略来看，DML就是对于数据库中存在的数据可以进行的一些查询，修改等操作。是直接作用于数据层面的。而DDL是对于数据库中数据的架构的规划语言，是作用于结构层面的。而DCL直观来看其实就是对于来自不同请求的权限控制。</p>
<blockquote>
<p>加下来将会进入一些聚合操作，查询操作等的了解</p>
</blockquote>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>​	在SQL中，存在着一些相对特殊的函数，这些函数以一系列的数据为输入，然后输出一个值。这些函数一般被称为聚合函数。</p>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL/image-20250218000909195.png" alt="image-20250218000909195"></p>
<p>​	上图中就是一些比较常用的聚合函数，函数的功能也比较简单，这里就没必要进行深入，等之后进入一些更加复杂的应用场景时可以来回顾一下。简单了解下这几个函数的功能即可。</p>
<ul>
<li>AVL(col)根据输入的值去计算平均值后返回，需要输入值能够被计算。</li>
<li>MIN(col)根据输入的值去查找最小值并返回该值</li>
<li>MAX(col)根据输入的值去查找最大值并返回该值</li>
<li>SUM(col)根据输入的值去计算总和并返回</li>
<li>COUNT(col)根据输入的值去返回这些值中非空值的个数</li>
</ul>
<blockquote>
<p>在进入下一步之前，我们默认你已经了解最基本的数据库查询操作，即一个由selete子句，from子句，where子句组成的基本查询操作，如果不知道，还是先回去看书吧。</p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote>
<p>​	聚合函数还存在一些使用上的限制，或者说，一些特性需要了解</p>
</blockquote>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL/image-20250220192249828.png" alt="image-20250220192249828"></p>
<h4 id="使用位置"><a href="#使用位置" class="headerlink" title="使用位置"></a>使用位置</h4><p>​	聚合函数只能在select子句中进行使用，并且使用聚合函数后select子句输出的内容将会是对应的聚合函数功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(1+1+1) AS cnt </span><br><span class="line">FROM student </span><br><span class="line">WHERE login LIKE &#x27;%@cs&#x27;</span><br></pre></td></tr></table></figure>

<p>​	额外注意一下，这里的as关键字起到一个名称替换的效果。这里的like关键字起到字符串匹配的一个效果，具体的等下再讲。</p>
<h4 id="去除重复项"><a href="#去除重复项" class="headerlink" title="去除重复项"></a>去除重复项</h4><p>​	部分聚合函数也可以使用关键字<strong>distinct</strong>来去除重复项</p>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL/image-20250220193434153.png" alt="image-20250220193434153"></p>
<p>​	使用方式也很简单，就是在对于的聚合函数里面加上<strong>distinct</strong>关键字，如上图中的使用。</p>
<p>​	额外需要注意的是，正如上图中指出，不是所有的函数都支持<strong>distinct</strong>关键字的，毕竟有时候distinct关键字的含义与一些聚合函数的功能之间存在一些歧义，应该是在设计上就进行了这些的摒弃。</p>
<h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><p>​	聚合函数中使用的参数也存在着一些限制。官方来说</p>
<p>​	出现在<strong>select子句</strong>中但没有被聚合的属性只能是出现在<strong>group by子句</strong>中的属性。换句话说，任何没有出现在<strong>group by子句</strong>中的属性如果出现在<strong>select子句</strong>中，那么它只能作为聚合函数的参数作为使用。</p>
<p>​	这句话应该配合实例来辅助理解。</p>
<p>​	<img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL/image-20250223174226964.png" alt="image-20250223174226964"></p>
<p>​	</p>
<p>​	首先，我们需要明白一个<strong>group by</strong>子句所能带来的作用。通过一个group子句，数据库可以吧对应的表根据子句中的元素列出为多组，其中每一组都是对应的子句中出现的元素。</p>
<p>​	然后我们来看到select子句所能带来的作用，该子句能够将对应的表中的数据进行操作来输出一个新表。那么，我们前面已经通过group by子句将这些元组分为若干个组了，此时我们如果想要加上一个没有任何限制的元素在select子句中，那会出现什么。很自然想到的是，这个将会出现一系列的元素没有一个对应的元组给它匹配到，而这个是我们所不想看到的。这也是这么一种设计的原因。</p>
<p>​	接下来我们再来看到这种设计中使用聚合函数将会出现的结果。当我们进行了group by子句进行分组后，我们如果想要正确的输出一个表，我们需要为每个分组后的新元组都提供对于的元素进行构建。也就是说，我们的select操作应该是基于分组后的各个子元组集合的。这也是为什么对于那些个没有出现在group by子句中的元素需要我们去进行聚合函数的原因，只有通过聚合，我们才能通过一组值来输出一个值用于一个元组的构建。</p>
<p>​	也就是说，还是跟前面一样，我们的select子句中就是最后的新表中的目标元素的集合。一个查询语句中如果出现了group by子句，那么对应的select子句中没有使用聚合函数的元素就是我们分组的依据，其他的使用聚合函数的则是我们目标新组中需要的元素。</p>
<p>我很喜欢GPT对于我这段话总结出来的几句话。</p>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL/image-20250223175701845.png" alt="image-20250223175701845"></p>
<hr>
<h3 id="Having子句"><a href="#Having子句" class="headerlink" title="Having子句"></a>Having子句</h3><h4 id="生效时机"><a href="#生效时机" class="headerlink" title="生效时机"></a>生效时机</h4><p>​	接下来看到一个与聚合函数具有较强关联的一个语句，having子句。这个子句与where子句有点相像。都是对于已有元组的一种条件筛选。</p>
<p>​	在之前的学习中，我们了解到where子句其实是对于整个查询操作中原始表的一个过滤。这个过滤操作是紧跟在from子句之后的。在这个过滤之后才会去进行接下来的一系列查询操作子句的进行。那么，这里就存在一个问题了，由于这个where语句的时机，所以我们其实是无法使用这个where子句去进行分组后的过滤的。毕竟，这个group by子句发生的时机是位于where子句之后的。</p>
<p>​	但是对于这种分组后过滤的操作，这种操作映射到现实生活中是非常常见的。就比如，你希望知道一个初中学校7年级中平均分最高的班级。那么此时只有where子句是无法满足我们的要求的。此时设计者就引入了一个新的子句，having子句。这个子句的功能与where子句基本相同，区分他俩的主要特征就是俩者发生的时机。正如前文所说，一个having子句能够对于分组后的结果在进行筛选。不难推测having子句的发生时机就是位于group by子句之后。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>假设你有一个销售表 <code>sales</code>，包含 <code>region</code>（地区）和 <code>sales_amount</code>（销售额）两列。如果你想按 <code>region</code> 分组并计算每个地区的总销售额，同时只返回总销售额大于 1000 的地区，查询可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT region, SUM(sales_amount) AS total_sales</span><br><span class="line">FROM sales</span><br><span class="line">GROUP BY region</span><br><span class="line">HAVING SUM(sales_amount) &gt; 1000;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>GROUP BY region</code> 将数据按地区分组。</li>
<li><code>SUM(sales_amount)</code> 计算每个地区的总销售额。</li>
<li><code>HAVING SUM(sales_amount) &gt; 1000</code> 对每个分组的总销售额进行筛选，只保留销售额大于 1000 的地区。</li>
</ul>
<h4 id="简单归纳"><a href="#简单归纳" class="headerlink" title="简单归纳"></a>简单归纳</h4><p><strong><code>HAVING</code> 子句</strong>：用来过滤 <strong>分组后的结果</strong>（在 <code>GROUP BY</code> 后），它针对分组后的数据进行筛选。换句话说，<code>HAVING</code> 过滤的是每个分组的聚合结果。</p>
<p>​	在实际应用中，我们可以看到事实上基本全部的having子句中都是聚合函数的一些条件限制，这个其实很好理解。毕竟前面我们已经说过了having子句就是用来进行分组后的条件筛选的，而分组后的分组依赖项本来就不应该被用来进行筛选，我们应该筛选的是每个分组的对应属性，体现在查询语句中的就是对应的select子句中使用聚合函数中的系列项。因此，在Having子句中看到这些个聚合函数也就不奇怪，或者说，理所应当了。</p>
<p>​	特别需要注意一点，对于having子句来说，其的执行顺序是位于select子句之后的。我们可以看到在上面的示例中我们在select子句中去对于sales_amount进行了一个as别名的替换。但是我们在having子句中没有进行使用，这个其实也很好理解。毕竟这个其实就是对于执行顺序的一个应用。此时的别名对于子句还是不可见的，因此自然无法使用。</p>
<p>​	接下来贴一个查询语句中各个语句的执行顺序图</p>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL/image-20250223203933254.png" alt="image-20250223203933254"></p>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL/image-20250223203948918.png" alt="image-20250223203948918"></p>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL/image-20250223204022012.png" alt="image-20250223204022012"></p>
<p>未完待续，由于篇幅过长，分割放送，下一部分看字符串操作。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern SQL-STRING</title>
    <url>/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>​	在SQL中，自然也存在字符串这种元素。一般来说，SQL使用单引号**’ ‘**来标识这是一个字符串，同时在SQL标准中，数据库对于字符串大小写应该是一个敏感的状态。但是，很多数据库系统中，包括但不限于MySQL和SQL Server中，对于这些个标准都是存在一些选择的。例如在MySQL中，其对于字符串的大小写就是不敏感的，当然，你可以在MySQL中去使用对于的标准设置语句去进行调整。不过种种这些，都是一些小玩意，在使用具体的数据库时去进行适当的调整即可，没必要去进行一个个的深入了解。</p>
<span id="more"></span>

<h2 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h2><p>​	SQL允许在字符串上使用多种函数。包括但不限于连接字符串(“||”),提取子串，计算字符串长度，大小写转换等函数。但是这些都只是一些实例的使用，具体的参考自己的数据库系统使用就行，不行就去问ai。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224074520213.png" alt="image-20250224074520213"></p>
<p>​	对于字符串函数，使用起来其实跟普通语言的函数之间很相似，都存在着一定的输入参数，并默认这些字符串函数都返回一个字符串提供后续的操作。例如上图中的SUBSTRING和UPPER函数。</p>
<p>​	可以注意到的是，这些函数在上图那个示例中都出现了不同的使用语句位置。不难想象，还可以存在多种使用位置。换句话说，字符串函数的使用位置与语句之间是弱耦合的，但是与它使用的数据类型是强耦合的，基本上必须存在着为字符的参数。所以理论上，所有可以出现字符串的地方，系列字符函数都能被使用。</p>
<p>​	</p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>​	在之前的几个文档中，我们其实不难看到有着like关键字的出现，这里对于这个关键字进行进一步的分析。</p>
<p>​	like关键字是用来实现模式匹配的，通过like关键字，我们能够实现对于所需要的字符串的一定程度上的一些限制。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224073610584.png" alt="image-20250224073610584"></p>
<p>​	正如上图中所说，’%’能够匹配任何子串(不限长度和内容，包括空串)，’_’只能够匹配任意一个字符，通过对于这俩个字符的排列组合，我们能够实现很大程度上的对于匹配字符串的限制。</p>
<p>​	这里需要特别注意一下like关键字的使用环境。理论上说like可以出现在任意一个子句中，毕竟它并只是与字符串绑定，可以粗略理解为like就像其他字符串函数一样，输入一个字符串并返回一个字符串以供后续的系列操作。但是在实际中，like的使用位置一般是位于where子句中的，毕竟相对来说，这个位置上的like具有更强的逻辑抽象。</p>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>​	在DBMS中，还存在着一系列的方法能够进行一些输出的重定向，就比如将输出重定向到一个新表中去生成一个新表。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224082830887.png" alt="image-20250224082830887"></p>
<p>​	上图中的demo其实就已经简单的列出了这个重定向的一些特性。</p>
<p>​	一个重定向需要使用一些输出作为输入，比如，这里的使用了select语句中的输出作为一个输入，并将这个作为输入去作为后续的INTO的输入。</p>
<p>​	一个重定向的输入存在几个特点。重定向的表必须没有被彻底的限定，必须允许能够被插入新的属性并能够被插入新的元组。在重定向后，这个输入将被插入重定向的表中。上图中其实就是将一个属性重定向到新表中的demo。接下来看一个插入新元组的方法。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224084043297.png" alt="image-20250224084043297"></p>
<p>​	额外需要注意的是，当我们重定向的输入是一系列元组时，我们这些输入元组必须与目标表的元组组成的一致，这个也能够理解。毕竟如果你的插入元组与目标元组组成不一致，那么这就违背了数据库对于数据组织的底层逻辑，这是我们所不想看到的。</p>
<h3 id="输出排序"><a href="#输出排序" class="headerlink" title="输出排序"></a>输出排序</h3><p>​	在实际应用中，很多时候我们需要将输出的数据按照一定的次序进行排列，这个排列的时机有很多，这里考虑的是DBMS输出表数据的时候。这时候我们可以通过一个新的order by子句来进行一定程度上的排序。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224085039262.png" alt="image-20250224085039262"></p>
<p>​	</p>
<p>​	很多元素都可以使用order by进行升序和降序的排序。包括但不限于整形，浮点型和部分的字符型等(字典序排序)。</p>
<p>​	在缺省情况下，order by子句是使用升序排序的。要说明order by子句中的排列顺序，可以使用des表示降序，或者使用asc使用升序。同时，在上面那个demo中没有体现的是，一个order by子句中可以存在多个用于排序的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from instructor</span><br><span class="line">order by salary desc, name asc</span><br></pre></td></tr></table></figure>

<p>​	该demo中的查询语句的含义是:从instruct表中去输出所有的元组并对于这些元组按照salary降序排列，按照name升序排列。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224092105897.png" alt="image-20250224092105897"></p>
<p>​	在一些个order by子句中，我们可以看到一些数字，这些数字其实是一种别名，对应的则是在select子句中出现的第i个元素。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>对于order by的排序，如果此间存在着多个用来排序的元素，那么在这之中存在着一定的排列顺序，就比如上面那个demo，先按照salary属性进行降序排序，再按照name进行升序排列，也就是说，order by子句是按照该子句中属性出现的次序来进行排序的。</li>
<li>对于排序的结果，还是存在那个特殊值(NULL)可能导致的问题。在一般的DBMS中，NULL值一般都被视为一个最小值，但是这个不好说，具体参考各个DBMS的使用手册。</li>
</ul>
<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>​	数据库系统还支持对于输出的一些数量和位置上的一些控制，具体是通过order by子句来实现的。相对来说跟之前的子句使用很相似，简单过一遍即可。</p>
<p>​	<img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224164339216.png" alt="image-20250224164339216"></p>
<p>​	对于这个输出控制关键字，主要存在着俩个功能，第一个是对于输出的数量上面的限制，这个通过在limit之后再加上对应的数字就能够实现对于输出元组数的控制了。</p>
<p>​	额外的，我们还可以在limit子句中去添加另外一个关键字offset来进行输出元组的偏移。通过在这个关键字之后添加上对应的数字，我们能够限定接下来的输出的其实元组位置。</p>
<h5 id="demo"><a href="#demo" class="headerlink" title="demo"></a><strong>demo</strong></h5><ol>
<li><p><strong>限制返回的记录数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">LIMIT 5;</span><br></pre></td></tr></table></figure>

<p>这个查询会返回 <code>employees</code> 表中的前 5 行数据。</p>
</li>
<li><p><strong>与 <code>OFFSET</code> 配合使用，进行分页：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">LIMIT 5 OFFSET 10;</span><br></pre></td></tr></table></figure>

<p>这个查询会跳过前 10 行，返回从第 11 行开始的 5 行记录。<code>OFFSET</code> 表示跳过多少行数据。</p>
</li>
<li><p><strong>限制查询结果，并按特定顺序返回：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">ORDER BY hire_date DESC</span><br><span class="line">LIMIT 3;</span><br></pre></td></tr></table></figure>

<p>这个查询会返回 <code>employees</code> 表中按 <code>hire_date</code> 降序排列的前 3 行记录。</p>
</li>
</ol>
<p>​	需要注意的是，在一些数据库系统中，这个limit关键字被替换为了一些新的关键字，具体参照对应的使用手册即可。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern SQL-NESTED</title>
    <url>/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.2-modernSQL(nested)/</url>
    <content><![CDATA[<h1 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h1><p>​	有一说一，modernSQL的内容是真的多，甚至于我都不想继续了，不过这些其实都还无所谓，毕竟现在也还只是停留在理论阶段，还没有开始真正的上手。</p>
<p>​	在之前我们接触到的都是一些单个查询语句的情况，但是有时候这种单层的结构不能满足我们的需求。自然而然，多层也就是嵌套查询也就出现了。这种查询方式其实很好理解。就是将一个查询语句的输出作为另外一个查询语句的一个子句的输入。在格式上表现出来的其实就是一个查询中包含着另外的查询。通常情况下，这种架构下的查询语句很难优化。而且一般来说，这种嵌套查询，可以出现在任何一个子句中，只要你这样做存在着抽象价值。</p>
<span id="more"></span>

<h2 id="where子句嵌套"><a href="#where子句嵌套" class="headerlink" title="where子句嵌套"></a>where子句嵌套</h2><p>简单来看一个小demo</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.2-modernSQL(nested)/image-20250224170141170.png" alt="image-20250224170141170"></p>
<p>​	这个并不是一个完整的嵌套查询语句。抽象来看现在这个查询语句其实存在了一个缺陷，就是你无法抽象出来你这里的父查询语句要怎么使用这个子查询语句的输出，这时就需要一些额外的关键字的使用来解决这个问题。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.2-modernSQL(nested)/image-20250224171132491.png" alt="image-20250224171132491"></p>
<p>​	你提到的这个问题非常经典，正是嵌套查询的核心挑战之一。在 SQL 中，嵌套查询的出现通常是为了处理一些复杂的需求，比如筛选符合条件的数据、关联不同的表等。但是，正如你说的，这种查询方式有时难以优化，且存在一些模糊的地方，比如如何将子查询的输出与父查询关联起来。</p>
<h3 id="如何将子查询与父查询结合"><a href="#如何将子查询与父查询结合" class="headerlink" title="如何将子查询与父查询结合"></a>如何将子查询与父查询结合</h3><p>为了将子查询的结果作为父查询的输入，确实需要一些关键字，主要有以下几种常见的方式：</p>
<h4 id="1-IN-关键字"><a href="#1-IN-关键字" class="headerlink" title="1. IN 关键字"></a>1. <strong><code>IN</code> 关键字</strong></h4><p><code>IN</code> 关键字可以将子查询的结果集作为父查询条件的一部分。</p>
<ul>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="keyword">IN</span> (<span class="keyword">SELECT</span> sid <span class="keyword">FROM</span> enrolled <span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这里，子查询 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT sid FROM enrolled WHERE cid = &#x27;15-445&#x27;</span><br></pre></td></tr></table></figure>

<p> 会返回一组 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sid</span><br></pre></td></tr></table></figure>

<p>，然后父查询 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name FROM student</span><br></pre></td></tr></table></figure>

<p> 会使用 <strong>IN</strong>关键字，筛选出 <strong>sid</strong>在这组返回结果中的学生名字。</p>
</li>
</ul>
<h4 id="2-EXISTS-关键字"><a href="#2-EXISTS-关键字" class="headerlink" title="2. EXISTS 关键字"></a>2. <strong><code>EXISTS</code> 关键字</strong></h4><p><code>EXISTS</code> 用来测试子查询是否返回任何记录。如果返回了记录，<code>EXISTS</code> 就会返回 <code>TRUE</code>，否则返回 <code>FALSE</code>。通常用在<strong>子查询存在与否的判断</strong>上。</p>
<ul>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> enrolled e <span class="keyword">WHERE</span> e.sid <span class="operator">=</span> s.sid <span class="keyword">AND</span> e.cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这里，<strong>EXISTS</strong>子查询会检查是否存在与 <strong>student</strong> 表中 <strong>sid</strong>匹配的记录，并且这些记录的 <strong>cid</strong>是 ‘15-445’。如果存在这样一行，父查询就会返回该学生的名字。</p>
</li>
</ul>
<h4 id="3-ANY-SOME-关键字"><a href="#3-ANY-SOME-关键字" class="headerlink" title="3. ANY &#x2F; SOME 关键字"></a>3. <strong><code>ANY</code> &#x2F; <code>SOME</code> 关键字</strong></h4><p><code>ANY</code> 和 <code>SOME</code> 都是用来比较父查询的某个值与子查询结果集中的任意一个值。如果与子查询的结果中的任意一个值符合条件，父查询会返回相应的记录。</p>
<ul>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="keyword">ANY</span> (<span class="keyword">SELECT</span> sid <span class="keyword">FROM</span> enrolled <span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这里，ANY检查 student表中的 sid是否与子查询 SELECT sid FROM enrolled WHERE cid &#x3D; ‘15-445’的结果集中的任意一个 sid匹配。</p>
</li>
</ul>
<h4 id="4-ALL-关键字"><a href="#4-ALL-关键字" class="headerlink" title="4. ALL 关键字"></a>4. <strong><code>ALL</code> 关键字</strong></h4><p><code>ALL</code> 用来比较父查询的某个值与子查询结果集中的所有值。如果父查询的值与子查询结果集中的所有值都符合条件，才会返回结果。</p>
<ul>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">&gt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> sid <span class="keyword">FROM</span> enrolled <span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这个查询会返回 sid 大于子查询中所有 sid的学生。</p>
</li>
</ul>
<h4 id="5-JOIN-子查询"><a href="#5-JOIN-子查询" class="headerlink" title="5. JOIN 子查询"></a>5. <strong><code>JOIN</code> 子查询</strong></h4><p>有时可以将子查询与 <code>JOIN</code> 结合，利用联接来简化查询结构，尤其是涉及到多表查询时。</p>
<ul>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.name</span><br><span class="line"><span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">JOIN</span> enrolled e <span class="keyword">ON</span> s.sid <span class="operator">=</span> e.sid</span><br><span class="line"><span class="keyword">WHERE</span> e.cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这种方式将子查询转化为一个连接操作，直接从 student和 enrolled表中联接出需要的数据。这里，e.cid &#x3D; ‘15-445’即是查询条件。</p>
</li>
</ul>
<p>​	以上几个就是GPT给出的几个关键字的小demo，由于我不想再去对这几个进行深入，所以暂时就先这样。</p>
<h2 id="from子句嵌套"><a href="#from子句嵌套" class="headerlink" title="from子句嵌套"></a>from子句嵌套</h2><p>​	简单来看几个子句的嵌套，其实可以发现一个现象，就是这种嵌套其实是基于一个接口规范来实现的。在我看来，部分子句的输入格式应该是关系，或者说元组的集合。那么，当我们查询语句的输出是一个关系时，那是否意味着我们能够使用这些个查询语句的输出作为另一个查询语句子句的输入。这里就是这样，from子句决定的是我们整个查询语句接下来所要操作的表。而一个查询语句的输出也正是一个规范格式的表。</p>
<p>​	最直观的一个，我们直接将一个查询子句放于from子句中，这在逻辑上是一个成立的，就比如：我从xx中找出了一些人，我再在这些人当中筛选出一些人之类的。</p>
<p>​	来看一个小demo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT d.department_name, e.employee_count</span><br><span class="line">FROM departments d</span><br><span class="line">JOIN (</span><br><span class="line">    SELECT department_id, COUNT(*) AS employee_count</span><br><span class="line">    FROM employees</span><br><span class="line">    GROUP BY department_id</span><br><span class="line">) e ON d.department_id = e.department_id;</span><br></pre></td></tr></table></figure>

<p>​	这里需要注意下join关键字，在这里先不考虑join关键字的深入用法。简单来说一下，join关键字就是将俩侧的表合并为一个表，至于更多的规则和限制，之后有遇到再说吧。</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select max(tot_salary)</span><br><span class="line">from (select dept_name, sum(salary)</span><br><span class="line">	  from instructor</span><br><span class="line">	  group by dept_name) as depe_total(dept_name,tot_salary);</span><br></pre></td></tr></table></figure>

<p>​	可以看到这里的demo相对于上面那个存在了一个最大的区别，就是在子查询语句之后加上了一个更名关键字as，通过这个更名关键字，我们能够对于这个子查询产生的关系进行命名。这是一种规定，也很好理解，毕竟单纯的查询语句出来的关系其实是匿名的，通过这种更名操作，能够给后续的一些操作提供便利，毕竟在一些复杂的架构中是可能使用到这种子查询产生的表的。</p>
<p>​	需要注意的是，在一些SQL实现(MySQL等)要求这种子查询都必须使用as关键字来进行子查询产生的关系的更名，即使这个关系没有被引用。还有一些实现(Oracle等)允许进行更名，但是不允许在这种更名语句中进行再更名，即对于select中的属性进行隐式的更名，就比如上面那个demo一般。因此，如果实在Oracle中，需要将select子句替换为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select dept_name, sum(salary) as tot_salary</span><br></pre></td></tr></table></figure>

<p>并将 <code>as depe_total(dept_name,tot_salary)</code>替换为<code>as depe_total</code></p>
<h2 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h2><p>​	标量子查询的原理我们前面其实已经出现过了，就是通过输入和输出接口的统一来实现对于一个字查询语句的任意插入。</p>
<p>​	官方点来说：SQL允许子查询出现在返回单个值的表达式能够出现的任何地方，只要该子查询只放返回一个包含单个属性的元组，这种子查询就是<strong>标量子查询</strong>。</p>
<p>​	这个不难，简单看一个demo过了就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select dept_name,</span><br><span class="line">	(select count(*)</span><br><span class="line">	 from instructor</span><br><span class="line">	  where department.dept_name=instructor.dept_name)</span><br><span class="line">	 as num_instructors</span><br><span class="line">	from department;</span><br></pre></td></tr></table></figure>



<h2 id="不带from子句的标量"><a href="#不带from子句的标量" class="headerlink" title="不带from子句的标量"></a>不带from子句的标量</h2><p>​	在一些时候，我们需要对于数据库的一些数据计算后将这些数据用于一定的算数运算，有些时候，这种算数运算不需要再额外去指定from子句作为输入，就比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(select count(*)from teachers)/(select count(*)from instructor);</span><br></pre></td></tr></table></figure>

<p>​	这是使用俩个子句来组成的另一个运算语句，在部分DBMS中，这是合法的，但是更多时候这会使得DBMS系统报错无法计算，因为这个语句缺少from语句。此时数据库系统就给我们提供了一种预定义的关系来使用，这种关系时虚拟的，但是可以在from中去使用去屏蔽掉报错，但是你很少能从中去获取一些具体有效的信息，这个关系就是 dual。</p>
<p>​	此时上面那个语句可以改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(select count(*)from teachers)/(select count(*)from instructor)</span><br><span class="line">	from dual;</span><br></pre></td></tr></table></figure>

<p>​	当然，这种显式指定from语句的规则可能不是每个DBMS都要求的，具体参考对于的使用手册即可。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern SQL-Function</title>
    <url>/2025/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/1.3-Modern%20SQL(function)/</url>
    <content><![CDATA[<h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><p>​	接下来看一些DBMS中存在的一些窗口函数。</p>
<p>![image-20250225092345760](.&#x2F;1.3-Modern SQL(function)&#x2F;image-20250225092345760.png)</p>
<p>​	上面那句话其实就是说一个窗口函数是对于输出序列中的一个特定窗口范围内的数据进行操作的函数。这个函数于聚合函数相似，都是对于一系列的元组执行操作的函数，但是这个函数于聚合函数最大的不同就是窗口函数并不会对输出结果进行合并，而是每个输入元组都能获得一个窗口函数的一个输出属性。</p>
<p>​	没意思，润</p>
<span id="more"></span>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern SQL-Modify</title>
    <url>/2025/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/1.4-Modern%20SQL(modify)/</url>
    <content><![CDATA[<h1 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h1><p>​	在此前的几个文档中，我们都专注于对于数据库数据的抽取，接下来可以进入对于数据库数据的增删改了。这也基本是modernSQL的尾声了。</p>
<span id="more"></span>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>​	删除的关键字是delete关键字。这个关键字的使用与select使用的方式十分相似。需要注意的是，我们对于数据库数据的删除的基本单位是元组，我们不能对于一个元组中的一个或多个特定属性进行删除。</p>
<p>​	这样规定的原因想必也十分明显，毕竟如果只对于部分属性进行删除那么首先其在数据的管理上就增加了难度，并且这还带来一系列的麻烦。</p>
<p>​	删除语句的格式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> r</span><br><span class="line"><span class="keyword">where</span> P;</span><br></pre></td></tr></table></figure>

<p>​	这个格式的含义是对于r关系中的满足P谓词的所有元组进行删除。至于from与where子句之间的进阶使用，跟前面提到过的并无不同，这里就不再进行赘诉，接下来看一个小demo就过了。</p>
<p>删除在Waston大楼里工作的所有教师元组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="keyword">in</span>( <span class="keyword">select</span> dept_name</span><br><span class="line">					<span class="keyword">from</span> department</span><br><span class="line">					<span class="keyword">where</span> building <span class="operator">=</span> <span class="string">&#x27;Waston&#x27;</span></span><br><span class="line">					);</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入的关键字是 <code>INSERT</code> 关键字。这个关键字的使用与 <code>SELECT</code> 使用的方式十分相似。需要注意的是，插入操作的基本单位是元组，我们不能仅插入一个元组中的一个或多个特定属性（列），而必须为所有列提供对应的值。</p>
<p>这样规定的原因也十分明显，毕竟如果只插入部分属性，那么我们就无法保证数据的完整性和一致性，且这样会导致一些不必要的管理麻烦。</p>
<p><strong>插入语句的格式</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 (列<span class="number">1</span>, 列<span class="number">2</span>, ..., 列N)</span><br><span class="line"><span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ..., 值N);</span><br></pre></td></tr></table></figure>

<p>这个格式的含义是向 <code>表名</code> 表中插入一条新的记录，其中每个列的值由 <code>VALUES</code> 子句提供。列名和对应的值按顺序匹配，确保每一列都有相应的值。至于列和值的详细使用，与前面提到的 <code>SELECT</code> 子句并无不同，这里就不再赘述。接下来看一个简单的插入示例。</p>
<p><strong>插入一条新的教师记录</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> instructor (instructor_id, name, dept_name, salary)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1001</span>, <span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;Computer Science&#x27;</span>, <span class="number">85000</span>);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们向 <code>instructor</code> 表中插入一条新记录，包含了 <code>instructor_id</code>、<code>name</code>、<code>dept_name</code> 和 <code>salary</code> 四个属性的值。</p>
<hr>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>更新的关键字是 <code>UPDATE</code> 关键字。这个关键字的使用与 <code>SELECT</code> 和 <code>DELETE</code> 使用的方式十分相似。需要注意的是，更新操作的基本单位是元组，也就是说，我们对一个元组中的某些属性进行更新，而不是对单个属性进行删除或插入。</p>
<p>这样规定的原因同样十分明显，毕竟如果仅更新一个属性而不明确其它属性的状态，可能会导致数据的不一致或丢失。因此，更新操作通常涉及某些特定条件的筛选。</p>
<p><strong>更新语句的格式</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名</span><br><span class="line"><span class="keyword">SET</span> 列<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>, 列<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span>, ..., 列N <span class="operator">=</span> 值N</span><br><span class="line"><span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure>

<p>这个格式的含义是更新 <code>表名</code> 表中满足 <code>WHERE</code> 条件的所有记录，将它们的某些列的值更新为新值。<code>SET</code> 子句用于指定更新的列及其新值，<code>WHERE</code> 子句用于筛选需要更新的记录。需要注意的是，<code>WHERE</code> 子句的使用至关重要，因为如果没有指定条件，表中所有记录都会被更新。</p>
<p><strong>更新在 Waston 大楼的所有教师的薪水</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> instructor</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHERE</span> dept_name <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> dept_name</span><br><span class="line">    <span class="keyword">FROM</span> department</span><br><span class="line">    <span class="keyword">WHERE</span> building <span class="operator">=</span> <span class="string">&#x27;Waston&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们将所有在 ‘Waston’ 大楼工作的教师的薪水增加 10%。子查询 <code>(SELECT dept_name FROM department WHERE building = &#39;Waston&#39;)</code> 返回所有在 ‘Waston’ 大楼工作的系的名称，然后主查询更新这些系的所有教师薪水。</p>
<p>​	简单过一遍语法，得开始去实践一下了。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Storage_Files &amp; Pages</title>
    <url>/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/</url>
    <content><![CDATA[<h1 id="储存管理"><a href="#储存管理" class="headerlink" title="储存管理"></a>储存管理</h1><h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a><strong>前情回顾</strong></h2><p>​	接下来，我将跟着15445的进度跳过中间的中级SQL和高级SQL和其他一些对于数据库的优化操作，直接跳到书籍的第三章节中来。正如15445在课程中所说的，这门课程主要是为了让我们了解一个数据库系统到底是什么，而不是了解数据库系统怎么来进行使用。</p>
<span id="more"></span>

<p>​	如下图</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227191240783.png" alt="image-20250227191240783"></p>
<p>​	我其实在学习这个的时候遇到了一个问题，就是我学校的课程内容其实相对于15445来说存在比较大的出入，就比如，学校的课程目标在database system concepts中主要就是第一二部分的内容。但是15445的课程目标则是后面的第三部分的内容，从底层来进行分析一个DBMS。在我看来，你作为一个CSER，在这方面的选择其实不应该犹豫，毕竟相对来说，CMU已经是很多CSER所能接触到的最好的课程了，如果想要拥有一个更好的底子，跟着CMU的课程目标走无疑是更加能够提高个人的能力的，所以，拼命吧，不必要去学校偷懒。</p>
<blockquote>
<p>CSER，Database Start！</p>
</blockquote>
<p>先来看一个图，这个其实15445的课程大纲</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227195226036.png" alt="image-20250227195226036"></p>
<p>​	该图中的左侧是15445整门课程大致的学习章目，此时我们已经进入Storage储存管理部分，右侧的层次架构是整个储存部分的基础管理结构，由下至上逐渐抽象，逐渐的远离硬件结构，在15445中则是从底层逐渐学起，逐渐架构起对于硬件与软件层次的认知。</p>
<h2 id="数据储存"><a href="#数据储存" class="headerlink" title="数据储存"></a>数据储存</h2><p>​	接下来我们来进行对于一个DBMS中数据的底层管理体系进行分析。</p>
<p>​	学过了CSAPP，其实不难知道数据在底层上都应该是储存在磁盘等非易失性储存器的，数据库中最主要的就是那些数据，因此这一点又需要额外重点注意。在这种架构下，DBMS确保了一个数据库的主要储存位置都位于非易失型储存器上。在现代的数据库使用中，由于在性能与损耗之间的平衡，对于需要使用的数据库数据，还是需要从非易失型储存器转移到主存中的，正如操作系统负责部分文件从外存往内存中的加载一样，DBMS负责数据库的数据在易失型和非易失型储存器之间的移动。</p>
<p>​	因此，接下来的学习中，我们的重点将会侧重于如果将一个DB中的数据安全的转移到主存中去，话不多说，启动。</p>
<h3 id="储存架构"><a href="#储存架构" class="headerlink" title="储存架构"></a>储存架构</h3><p>​	接下来看一个老朋友</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227201731393.png" alt="image-20250227201731393"></p>
<p>​	对于这个图中的内存架构，如果学过CSAPP中的储存模型，相似能够很快的理解。</p>
<p>​	这里主要对一些东西重复一下</p>
<ul>
<li>Volatile(易失型储存器):在易失型储存器中，储存器硬件上的内容可以按照字节来进行寻址，但是这种储存器一但断电其上面储存的信息将会在很短的一段时间内小时，不难长时间储存。</li>
<li>Non-Volatile(非易失型储存器):一般来说，非易失型储存器并不能按照上面的通过字节来进行内容的读取，因为它实在是太慢了，使用按字节读取的损耗不能够弥补付出。但是这种储存器在断电后其上的信息仍然能够长时间储存。</li>
</ul>
<p>​	在数据库的内存系统中，我们主要考虑的是在各个硬件架构之后，我们需要怎么去确保在数据的传输过程更安全，更有效率，话不多说，开始。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227202547718.png" alt="image-20250227202547718"></p>
<p>​	在non-volatile中，基本所有情况下对于数据的随机访问都是慢与顺序访问的，这样其实也很好理解，毕竟相对于顺序访问，随机访问通常意味着更多的磁头的移动和读取，这种硬件的移动和读取是我们所不喜欢的，这大大影响了数据读取的效率，那么一个DBMS就必须在这一块之上去下功夫。</p>
<p>​	最简单的一点，为了优化效率，我们在设计DBMS时，我们需要去选择哪些能够使得我们最后在读取&#x2F;写入数据时能够顺序读取&#x2F;写入数据的数据结构或者算法。就比如，我们在需要将主存中的数据写回到外存中时，去选择哪些能够顺序写入外存的储存页的方法，写出同理。</p>
<p>​	例如，在MySQL中，在往磁盘写入数据时，其通常是先将需要写入的数据先给以顺序写入的方式写入到一个缓存池中去，然后通知外界你这块数据已经成功被保存。但是实际上这块数据可能还没有被写入到外存中，只有当触发了缓存池中的写入限制时才会一次性写入到外存中，这次写入可能是随机写入的，但是我们不用对这个进行管理，因为这个是在后台进行的。</p>
<p>​	接下来来看一个美图</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227205144263.png" alt="image-20250227205144263"></p>
<p>​	这个的图学过CSAPP的话，一眼过去基本就能猜测出对应的操作了，这里就不进行再分析了。</p>
<p>​	</p>
<p>​	在DBMS中，上面那个过程对于disk上的内存页的调配很多程度上都是相对于OS独立实现的，那么，为什么呢，为什么要自己造轮子呢？（其实使用C++来写东西的人应该对于这个问题会有一个初步的自己的回答）</p>
<p>​	这一块不会进行分析，时间紧任务重，先赶进度先。在课间中对于这一点进行了这一块的较大篇幅的讲解，感兴趣可以去看一看。</p>
<h3 id="文件储存"><a href="#文件储存" class="headerlink" title="文件储存"></a>文件储存</h3><p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227210340760.png" alt="image-20250227210340760"></p>
<p>​	在DBMS中，对于数据库一般都是以文件的形式储存在disk上的，OS无法解析这些文件，只是知道这些文件的存在。并且，基本上每个DBMS都有自己一套的数据库的储存方法，很多DBMS的数据库文件都是无法互相解析的。部分DBMS例外。</p>
<p>​	需要注意的是，在15445中，其进行学习的储存基础的文件系统是OS的文件系统，对于哪些少数自己实现文件系统的，并不在课程讨论之内。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227211251521.png" alt="image-20250227211251521"></p>
<p>​	一个DBMS中一般会存在一个自己的storage manager用来管理自己的数据库文件，通过对manager进行特定的优化可以看到各个数据库之间的性能差距，但我们这里要学习的是他们的基本共性。</p>
<p>​	对于一个manager，其一般会将文件视为一系列的pages的集合，在文件中，其负责跟踪每个页在该文件中的位置已经跟踪每个页中存在的空闲位置。</p>
<h2 id="PAGES"><a href="#PAGES" class="headerlink" title="PAGES"></a>PAGES</h2><p>​	接下来我们来看到数据库文件的基本储存单位:<strong>pages</strong>。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227212103999.png" alt="image-20250227212103999"></p>
<p>​	对于一个<strong>pages</strong>来说，其内部一般是一系列的block的集合，在每个页中，其中包含了关于这个页中的一些信息，这个就像我们二进制文件中的那些前置信息一样，这些信息一般都是位于页的起始部分的，规定了页的一些基础属性，已经系列页的跳转位置，页内的块索引等等，碰到再说。</p>
<p>​	额外的，每个页拥有，也需要一个唯一且特殊的标识符来进行标识，这个由DBMS来设定和提供。</p>
<p>​	一般来说，在一个页中，该页只会储存一种类型的数据，就比如当储存一个表时，一般只会储存这个表的数据而不会混杂多个表的数据，当是索引页的时候，就不会去储存数据页。这种设计其实在CSAPP中也有一定的出现，优势页很明显，就是这样的设计能够减少页的切换，使得你要读取数据时，一般只需要再一个页内去读取就行，对应与磁头等的物理操作就会减少一些，提高了效率，对应的只是一些越来越廉价的外存的损耗，这是完全可以接受的。</p>
<p>​	同时，这种设计也使得在硬盘在遭受一些极端的外界因素而损毁时，我们能够尽可能的去读取剩余的数据(如果表头数据还在的话)。</p>
<p>有时我们会在页中去储存多余的元数据，这在一定程度上也是为了数据的恢复。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227215004495.png" alt="image-20250227215004495"></p>
<p>​	在计算机层面上，存在着多种pages，最底层的是Hardware Page,这种是最基本的硬件层面上的页，接着是OS Page，这种是OS定义的基本页，通常都是与Hardware Page相挂钩的，以前一般是与其一样的大小，在现在内存廉价后变大了许多，但在本门课中假设OS Pages跟Hardware Page的大小一致为4KB。再之后就是我们的Database Page，这个是建立在OS Pages上的，虽然DBMS不使用OS的文件系统，但是DBMS的文件读取读入，还是通过OS实现的，至于Database Pages的大小，这个每个DBMS一般都有自己的规定，如上右图。  </p>
<p>​	我们这里需要对页的大小的选择进行一下分析，为什么不直接选择最大的页面而是有些选择较小的页面。这里需要考虑一个页的写回，当我们一个页的大小是16KB时，我们对其修改了一些数据后需要对其进行写回，那么此时OS需要做什么，OS需要把整个16KB大小的页面都给写回到disk中，假设我们只对于这个页面修改了1条数据，其在写回时仍需要把这个16KB大小的页面写回，这是十分浪费的，当然，较大的页面大小使得我们在这个页中去查询大量相同的数据时拥有更高的效率，所以我们需要平衡页面大小与查询性能之间的关系。</p>
<p>​	举例，当我们对于数据库操作是读密集型的时候，大页面会具有更大的优势，毕竟你可以在一个页面内去读取更多的数据，再需要时再丢弃这个页读取新页。而对于写密集型的时候，小页面具有更大的优势，因为写回时会浪费的页面大小空间会相对大页来说更少。</p>
<h3 id="储存形式"><a href="#储存形式" class="headerlink" title="储存形式"></a>储存形式</h3><p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227221435425.png" alt="image-20250227221435425"></p>
<p>​	在不同的DBMS中，其对于其自己的数据库文件中的页管理可能是不同的形式的。这里先来对于Heap File Organization来进行讨论，这是最常见的一种DBMS对于数据库文件中的页面管理方法。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227222236459.png" alt="image-20250227222236459"></p>
<p>​	对于堆文件架构的数据库文件来说，其中储存的页是无序的，或者说，其中的数据时按照插入顺序排序的，每个页面都有着自己独立的一个编号，通过这个编号，在需要查找某块数据时，通过数据对于的页编号能够索引到对应的块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Offset = Page# x PageSize;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227225125034.png" alt="image-20250227225125034"></p>
<p>​	在一个DBMS当中，通常会存在一个特殊的索引页来进行对应数据库文件中的特定页的索引，通过这个索引页，可以索引到对应的页，但是需要注意的是，也只能索引到特定的页，至于对于也里面的数据内容，这不是索引页中需要了解的，是在索引到特定的页之后需要对其进行的解析等的操作。</p>
<p>​	在课程中，还对堆文件中的空闲页空间管理进行了一次demo的演示，在DBMS中，存在着一种能够跟踪储存一个表的系列页的空闲空间的方法。在演示的demo中，我们看到有时候我们往数据库中去插入对于的数据然后去查看插入后的对应的表的空闲空间，可能是与插入前一致的(猜测其实是被缓存了还没有插入，因此，没有触发对应的空闲空间的检测)，但是如果此时使用DBMS自带的更新语句更新再查询，就会发现对应的页空闲空间产生了变化。接着还有当我们从表中去删除数据再去查看对应的空闲空间时，可以看到删除后的空闲空间发生了实时的变化。通过这个可以看到对于的DBMS的空闲页的更新机制。</p>
<p>​	需要注意的是，这里的空闲空间查询机制在一些程度上是相对独立的机制，或者这么说，只要你去查看了对应的表所使用的页的空闲空间，那么它所输出的结果就确实是现在在disk上的空闲空间大小，只是我们空闲空间管理器锁需要具备的基本功能。至于为什么我们插入数据后还是没有变化，想必你也有点头绪，就是因为此时这些插入的数据还是被缓存了，并没有被实时的写入到对应的disk中的文件中，因此此时查看磁盘中的文件空闲空间才会是插入之前的情况。至于删除这种操作后会有区别，想必就是进行了实时的更新了吧，这个应该取决于你DBMS的设计，如果设计的删除和插入一样会被缓存，那么这里的查询也应该会延后更新。不过这都不重要，因为我们已经理解了缓存会带来的空闲查询延后更新的这种影响。</p>
<p>​	</p>
<h3 id="PAGE格式"><a href="#PAGE格式" class="headerlink" title="PAGE格式"></a>PAGE格式</h3><p>​	接下来看到PAGE的格式。众所周知啊，对于底层数据的文件，页，块等的组织，一般都会在对应区域的其实位置附上一些信息用于识别该块内存所有的一些信息。也就是所谓的头部。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250228103902474.png" alt="image-20250228103902474"></p>
<p>​	在页的头部中，包含了这个页的大小和一些杂七杂八的信息，这里就不进行一个个深入了。</p>
<p>​	我们主要的是接下来的内容，一个页中是如何对其中的数据进行组织的，换句话说，一个页中是如何储存其的信息，对应的元组是怎么进行排列的。在接下来的讨论中，可以考虑十分友好的遵守了单一职责原则，在这里面我们暂时只需要考虑文件内部如何组织数据而不必去考虑外部给其带来的影响。</p>
<p>​	</p>
<p>​	接下来看到一个问题:当我们要储存一个元组时，我们应该如何将这些元组放入到这些页面中，当我们想要从一个页中去查找一个元组，我们需要怎么去查找。</p>
<p>​	接下来看一种元组的储存形式</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250228110856551.png" alt="image-20250228110856551"></p>
<p>​	这是一个顺序储存，当我们需要插入元组的时候，分配器会为其分配一个特定的ID并查找空闲区域并进行插入，在只存在插入时这种架构不会存在什么问题，但是想想也是不可能的，最明显的，当你需要进行删除时，会发生什么呢。首先，你需要去将页内的元组的存在有效性被抹除，对应的内存块对于外界来说会是一个空闲的状态。那么，当此时我们需要插入时，由于顺序插入，查询到空闲且合理的位置就进行插入，那么这里就可能导致类似于 <strong>Tuple #1 Tuple #4 Tuple #3</strong>之类的元组顺序，这样的话对于外界来说，索引起来是非常麻烦的。</p>
<p>​	还存在一个问题，在这种内存架构下，如果你的元组大小的长度是一个可变的呢，就比如不同的邮箱通常存在着不同的长度，如果你想要去规定元组的大小为最大的长度，那么这里就会存在一个十分常见且不讨喜的问题。在一定时间的使用后，内存空间将会被严重碎片化，这是我们所不想看到的。</p>
<p>​	在种种这种顺序储存结构存在的缺陷的基础上，出现了另外的一种储存格式：槽页面</p>
<p><strong><code>slotted pages</code></strong></p>
<p>​	接下来看一下一种顺序存储的优化页面，槽页面。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250228115641837.png" alt="image-20250228115641837"></p>
<p>​	在槽页面中，出现了额外的一种结构（槽数组）来对页内的元组进行管理。在这种架构下，元组的储存位置与数据进一步的分离了。可以说，这种架构下的槽数组的每个元素与每个元组之间，类似于一种映射的关系。通过槽数组中的数据，可以直接去定位到对应的元组位置，这种分离使得在元组的管理上更加的灵活。</p>
<p>​	需要注意的是，但我们进行元组的插入时，同时会有元组数据的生长和槽数组的生长，当俩个不同属性的内存块触碰到一起时，这个页会被视为满并且不再允许插入。当然可能碰到一种情况，就是你要插入一个元组。但是表中的剩余空间不够插入，这种情况我们会在下一节课程中进行分析。</p>
<p>​	对于元组来说，其的添加删除其实还是跟之前很相似，都是查询到一块空闲区域时进行插入，但是这种架构下的元组相较于顺序存储具有更强的变长能力。当插入不同长度的元组时的操作并无不同，猜测在槽数组中，每个元素都包含了一系列元组的信息，其中就包括了对应元组的长度。同时，删除时的操作其实也跟之前很相似，这里是将元组对于的槽数组元素的可用标志位给置否(类似于语言中内存分配器的实现)。其实这种结构下的内存分配，与各个语言中的内存分配器很相似，所以其实没有什么新奇的地方。</p>
<p>​	与内存分配器相同的是，在这种架构下的页结构对于碎片化的空闲空间在一定的时机中也可能触发合并操作，比如可能挪动部分的元组位置来进行合并碎片小块来提供一个大块的操作。总总这些，其实跟内存分配器的思路很相似，这里不再进行赘诉。</p>
<p>​	</p>
<p>让我们来对于这种架构下的几个我比较在意优势做几点分析：</p>
<ul>
<li>在这种架构下，一个页对于外界来说是未知的，换句话说，外界无法知道一个页内到底发生了什么，但是，外界可以通过对页提出一定的请求来获取对应的数据。即进行了外界与页内部的解耦，是数据的查找不必要依赖于外界的实现</li>
<li>在页内，内存管理方面也更加灵活，当需要进行一些元组的移动时，需要更改的地方不会像之前的顺序储存一样牵一发而动全身，只需要修改对应元组的槽数组的对应元素属性即可，大大减少了内存管理方面的麻烦。</li>
<li>同时使得各个模块可以专注于自己的功能，就比如内部的元组的移动，其所需要负责的只有对应的数组元素的修改更新通知，不会需要再往上层去查询去修改对应的代码。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>槽页面架构通过引入槽数组，成功地将元组的管理与数据的实际存储位置分离，使得插入、删除操作更加高效，并且具备了更强的可变长度支持。同时，槽数组的设计与内存分配器非常相似，通过标记、合并等方式有效管理内存碎片化问题，提升了存储空间的利用率和系统的整体性能。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Storage_Logs-Structure Merge Trees &amp; Tuples</title>
    <url>/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/</url>
    <content><![CDATA[<h1 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h1><h1 id="Tuple-Oriented-Storage"><a href="#Tuple-Oriented-Storage" class="headerlink" title="Tuple-Oriented Storage"></a>Tuple-Oriented Storage</h1><p>​	在前面，我们初步了解了一种数据在底层的组织形式，在这里我们考虑一个问题，即使我们知道了一个数据的存在，我们需要怎么去找到这个数据呢？</p>
<span id="more"></span>

<p>​	第一想到的肯定得是构建数据的物理实际储存地址，在DBMS中，一个元组的物理位置被称为<strong>record ID</strong>，用于记录索引一个元组所必备的一些信息。<img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250228162320809.png" alt="image-20250228162320809"></p>
<p><strong>Record ID</strong></p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250228162750328.png" alt="image-20250228162750328"></p>
<p>​	这里需要注意的是，我们这里了解物理地址并不是为了去使用它，毕竟你也应该知道直接去使用一个东西的绝对地址是一个多么愚蠢的事情，我们需要的只是了解它，并在之后可能的应用场景中不至于犯下一些愚蠢的错误。</p>
<ul>
<li><p>对于一个Record ID，其中会储存很多的信息，包括但不限于一些文件id,页的id,对应的槽的id。通过这样去逐层的索引到目标元素。</p>
</li>
<li><p>绝大多数的DBMS并不会在元组中去储存对于的id信息，毕竟这是没有意义的，你储存它对于你的外部使用来说没有什么意义，这东西应该有底层自动管理，暴露给外界的话还可能导致一些违法的操作而导致错误。(指的是显式储存)</p>
</li>
<li><p>从储存上来讲，假设确实有这些id信息的元组存在，那么你如果要去获取这些信息，你需要提前知道这些信息，那么你已经知道了你还要去用已知的再去寻找一遍，多少有点脱裤子放屁的意思了。我们完全可以通过DBMS的一些设置来给我们放回一些数据的物理位置而不是在元组中去额外添加属性进行标识。当然，这些只是一般情况，对于哪些实际情况，当我没说。</p>
</li>
</ul>
<p>​	在一些DBMS中，提供了一些能够返回Record ID的方法，在postgres中可以对于输出的属性去读取其的隐藏属性ctid去读取对于的id信息。对应的是一个二元组(x,x)第一个是对应的页编号，第二个是对应的槽编号。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250228164007408.png" alt="image-20250228164007408"></p>
<p>​	在这上面的demo中可以看到在删除后另外俩个的ctid并没有发生变化，因此可以猜测这里的数据库实现应该是没有一个简单删除后进行一个自动合并的，或者说，这种简单的更改不会触发对应的合并程序(如果有的话)。</p>
<p>​	至于在各个系统中到底是一个怎么样的，可以自己搓一个表丢些数据进去再查查对于的地址看看嘛。</p>
<p>​	</p>
<p><strong>猜想</strong></p>
<p>​	对于一个DBMS来说，我们通常可以通过系统内的方法去对于一个元组的record ID去进行获取，我猜测，这里的record ID只是在输出是由底层的一些数据整合出来的，实际上并没有这个属性在元组中。</p>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250228174535031.png" alt="image-20250228174535031"></p>
<p>​	接下来我们来看到元组的操作(插入和删除)到底是一个什么个情况。</p>
<p>​	当我们需要插入一个新元组的时候。首先去查询页的词典去寻找一个带有空闲槽的页面(这个槽应该能够容纳带插入的数据)，接下来看写入磁盘的部分。</p>
<p>​	首先其会通过record ID去知道对应的页信息，然后通过我们的页索引表去找到对应的页，这里可能会出现页不再主存中的问题，此时会像程序执行时遇到段错误一样，先去吧对应的页调到主存中。接着再从元组的索引(之后会遇到的)中去提取对应的槽的位置，然后通过页内的槽的详细信息去找到页的具体偏移位置去进行操作，如果此时该位置的大小允许我们的操作，那么它将会直接在该位置上进行操作。</p>
<p>​	</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>​	接下来我们来看到这种面向元组储存的方式所存在的问题</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250302085724797.png" alt="image-20250302085724797"></p>
<ul>
<li><strong>fragmentation</strong>（碎片化）对于使用槽页面和元组直接储存的结构来说，在不断的插入删除操作之后，页内的空白碎片可能越来越多且大小可能不一，当进行压缩后这种问题才能得到缓解，但是这种压缩操作又是非常耗时的。这种无法充分利用空间的缺点很令人恼火。而且，即使我进行了压缩，我们前面提到了页内是当槽数组与元组接触到之后被判定为满的，但是当我们剩余的空间无法储存接下来的数据时也会被判定为满，这种会导致在一个页在充满时总还是存在着一些空余的空间。</li>
<li><strong>Useless Disk I&#x2F;O</strong> (无效的磁盘I&#x2F;O) 这个问题前面讲到过，当我们需要去读取一个元组数据时，由于对于数据库来说，读取数据的基本单位是页，因此无论是读取多少个数据，都需要读取对应的整张页。这就意味着每次读取一个数据可能会导致大量的性能损失，就跟CPU所使用的缓存发生缓存未命中时的情况一样。</li>
<li><strong>Random Disk I&#x2F;O</strong>(随机访问导致的磁盘I&#x2F;O) 当我们更新数据时，由于元组数据在插入时遇到的情况不同，我们的一个更新语句可能会涉及到一个表中的多个页，这会导致在更新完一个元组后需要去到另外的页中进行更新，这将导致一个简单的更新操作都需要读取多个页，简单来看这就是比上面更加严重的缓存未命中情况。</li>
</ul>
<blockquote>
<p>扩展(我也不知道也不应该这么说)</p>
</blockquote>
<p>​	在一些DBMS中，对于底层中的数据，其并不允许对于已有的数据进行修改，允许对于页进行插入操作，但是不允许修改已经存在于页中的数据。这种想法其实很简单，或者说之前也见到过，就是<strong>不要去动已经能够运行的代码</strong>。对于已经存在的数据进行修改的话，首先可能由于变长域的存在，这种修改可能会犹豫内存不足而失败，如果成功，那可能导致更为严重的问题，类似于语言中内存访问导致修改意料之外的数据的问题。因此，有些DBMS是不允许对于已有的数据进行修改的，当我们想要进行修改时，其可能对于整个内存页都会进行一个拷贝，并在这个页的拷贝中去更新对应的数据，在之后更新对应的索引和删除原来的页来实现。</p>
<p>​	有了这种情况对于上面提到的第三点其实也更能理解其所带来的性能损耗能有多么严重。</p>
<p>​	总的来说，这种架构的问题很简单也很严重，其一就是由数据插入本质导致的内存浪费问题，其二就是读取数据操作本质导致的缓存未命中而导致的性能损失问题。这种对于I&#x2F;O的严重浪费是我们不想看到的，接下来看到DBMS的应对策略（有一说一，CMU中对于这些的引入真的是一种水到渠成的感受啊）。</p>
<hr>
<p>​	</p>
<h1 id="Log-Structured-Storage"><a href="#Log-Structured-Storage" class="headerlink" title="Log-Structured Storage"></a>Log-Structured Storage</h1><p>​	在日志结构储存着部分中，我们将会致力于前面提到的三个问题。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250302103027220.png" alt="image-20250302103027220"></p>
<p>​	首先，对于一个日志结构的储存，其调到主存中的内容还是于之前一致的，都是最近一次，也就是最新的table，在这个表中，元组数据可能被组织为一些特殊的逻辑结构，就假设是最简单的树形结构。当我们需要对其进行插入删除等操作的时候，这个表所做的可能是插入一个对应的节点，这个节点中储存了最新的操作之后的数据。</p>
<p>​	在之后的一定时机（一般就是在主存中的这个表满后），DBMS将会根据这个MenTable中的数据去构建该次操作中的SSTable表，需要注意的是，这个表中储存了所有的原先的表中的数据以及这次进行的操作以及各自对应的操作时机。但是对于SSTable来说，其只会使用这个表中最新的数据去进行构建最新版本的数据。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250302124929039.png" alt="image-20250302124929039"></p>
<p>​	在产生一个SSTable后，OS会将其送回磁盘中去完成持久化储存。一般来说，在硬盘的储存结构上，新产生的SSTable会像栈被压入到对应表结构的level中，该类结构中一般为较新的结构越靠近压入口。在对应的一个层级level被压满时，此时会触发一种合并机制，将该层级的多个子表合并为多个大表并压入更深一层level进行储存，一次递归。层级越深，单个SSTable的大小越大，同时储存的信息所存在的时候举例现在越久。</p>
<p>​	同时，在单个层级中，SSTable的储存也存在着一定的时间次序，如果单单以上面的那种结构来看，从左到右的数据更新的时间举例现在越短，这种时间的有限顺序与物理储存顺序间的关联是有意义的。通过这种简单的映射，在进行合并时，我们能够选择有限合并更新时间相差不大的几个SSTable，只需要通过他们的相邻次序即可做到了。</p>
<p>我们来看一下在这种架构下存在着什么优点。对于数据库的操作，其中的读取操作其实还是没有什么较大的区别，主要在于写回的时候</p>
<ul>
<li>在写回时，其中的操作并不会实时的写回，而是一种异步的状态，当主存中的表达到写回的接线是，对应的记录会被顺序的写入到一个新表中。这种顺序的操作比起之前那种随机读取的操作将要更加省时。</li>
<li>在disk的分层架构下，各个层级间的数据具有相对严谨的结构关系，这种层级架构可能使用某种特定的数据结构来实现（B+树）在索引这块也具有一定的加速作用。</li>
</ul>
<p>​	</p>
<hr>
<p>当然，这种架构也存在着一定的问题，最明显的其实是在需要读取时它的性能消耗。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250304110437519.png" alt="image-20250304110437519"></p>
<p>​	当我们查询一个操作时。首先，它会从当前磁盘中存在的表中去进行查找，如果存在，自然最好，如果不存在，那么就需要去在disk中去进行查找，对于每个SSTable进行二分搜索，最严重的情况是，它需要遍历所有的SSTable。</p>
<p>​	为了避免这种扫描全部的情况，添加了一种新的结构来进行优化</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250304110804291.png" alt="image-20250304110804291"></p>
<p>​	在添加了这种结构后，当需要执行一条查询语句时，首先去查询内存中的表是否存在数据，当不存在时，不会直接去磁盘中进行查找，而是先通过一个<strong>SummaryTable</strong>来进行一次过滤。</p>
<p>​	在这个表中，集合了每个层级中的键值索引来加速索引层级，储存了每个SSTable的最大最小码来索引哪个SSTable。</p>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>​	在前面我们已经知道了当一个层级在容纳了一定量的SStable时，其会触发合并，我们接下来来看这个合并操作会是一个什么情况。</p>
<h2 id><a href="#" class="headerlink" title></a><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250304123421002.png" alt="image-20250304123421002"></h2><p>​	首先，需要知道的是，SSTable内部的记录是以一种有序的方式排列的，每条记录存在着其的键值。当我们需要进行合并时，对应的记录会根据所属的键值来进行合并，规则其实很简单，一个键值只要出现了，那么它就一定会被储存到新表中，如果一个键值在多个表中都存在数据，那么只保留最新的一条记录。</p>
<p><strong>缺点</strong></p>
<p>​	在这种架构下，由于表的合并操作，会导致DBMS出现一种写放大的缺点。</p>
<p>​	当一个SSTable被生成后，其会被送回到disk中，在disk中，其会检测现在是否需要去进行表的合并，并一次递归去检查所有的层级。在这种情况下，一个简单的表可能会导致多个层级都触发了合并操作，而且由于这些表都是位于disk中的，所以效率会相对较慢。相对来说，使用面向元组的普通结构就不会出现这种情况，那种每次写操作都有且只有一次进行了磁盘的覆写操作。</p>
<p>​	其实可以窥见，这之间就有这一定的利润可图，就比如网上的哪些提供远程数据库服务的平台，通常都是付费的，这是你给写操作，给硬盘损耗的一种必要付出，当然，这里说的还是很浅显，感兴趣就自己了解嘛。</p>
<p>接下来看到另外一种存储格式</p>
<h1 id="Index-Origanized-Storage"><a href="#Index-Origanized-Storage" class="headerlink" title="Index-Origanized Storage"></a>Index-Origanized Storage</h1><p>​	顾名思义，这是一种依托于索引的储存结构。所谓的索引，如果只在使用的角度上来看的话，其实可以看做是一种用于映射的结构，当一个输入通过一个索引的映射之后，我们将能够找到该块输入所需要的数据所在的位置，不同的DBMS存在着不同的索引实现。其中，可能是通过索引去找到数据所有的record ID进而去找到对应的储存结构去找到对应的数据的。当然，一种更优秀的方法时将每个数据组织为一种数据结构，就比如一颗树，每个节点具有一个特定的标识符，也就是所谓的索引，通过数据结构内的比较，实现对于一个数据的快速索引来加速查找。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250304170212040.png" alt="image-20250304170212040"></p>
<p>​	简单来看上图中存在的树。在这种树结构的索引组织储存中。我们通常将树的节点划分为俩类，分别是<strong>Inner Nodes</strong>和<strong>Leaf Nodes</strong>,在<strong>Inner Nodes</strong>中，其只负责对应的输入索引接下来的路径，也就是说，当一个索引遍历运行到树上的某个节点时，节点上的某些信息回决定接下来遍历的节点的位置。一直遍历到叶子节点后停止继续深入查询。通常在树结构的储存中，叶子节点储存的是实际的数据（元组的集合，其可能是一个类似于槽页面的页面）。</p>
<blockquote>
<p>​	这一个简单过了，等之后遇到B+树时再来进行分析。</p>
</blockquote>
<p><strong>小结</strong></p>
<p>​	对于前面三种，我们来进行一下小结。首先需要明确的是，前面这三种结构本质上都是一个数据库对于其底层的数据的组织形式。</p>
<ul>
<li><strong>Tuple-Oriented Storage</strong>（面向元组的储存）这种储存结构是指在储存数据时其的基本单位是一个元组，正如前面的槽页面。当使用这种储存结构时，我们需要储存的数据的基本单位是元组。</li>
<li><strong>Log-Structured Storage</strong>（面向日志的储存）这种储存结构相对来说每次进行查删改查的对象有了很大的变化，其不再像是之前按照元组储存的对于一个页来进行操作。其通过使用MemTable和SSTable来实现对于数据的读取和写入。</li>
<li><strong>Index-Origanized Storage</strong>（面向索引的储存）这种储存结构使用索引来构建出一种特殊的数据结构。这种数据结构上的每个节点通常都具有一定的信息，对于数据的操作可以等效为对于节点上的操作。</li>
</ul>
<p>​	上面这三种数据组织结构的实用场景和优缺点在这里并没有列出，自己补充吧，接下来我们进入下一小节。</p>
<p>在前面，我们已经接触了三种数据的组织形式，接下来我们深入另一部分，元组的组织形式。</p>
<h1 id="Tuple-Storage"><a href="#Tuple-Storage" class="headerlink" title="Tuple Storage"></a>Tuple Storage</h1><p>​	一个元组就是一段数据，其在底层上的表示就是一段01串，这并不难理解，但是也没什么意义，我们需要知道的是这一段01串内部的组织形式以及所具备的含义。</p>
<p>​	一个元组是一个字节序列，这一段字节序列上面通常带有一个头部来告诉你该段字节序列中的信息，一般为一个属性相对于该个字节序列的偏移量和该子字段的长度。如下图。</p>
<p>​	额外说明一下，对于一个字节序列，其一般会将一些定长字段放于该字段的前面，将变长字段分配与字段后部分。而且字段中的子字段的属性排序一般是与声明时的字段排序相一致的。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250304184817396.png" alt="image-20250304184817396"></p>
<p>​	</p>
<p><strong>字节对齐</strong></p>
<p>​	对于这些数据，正如C++中类的设计一样，为了方便CPU对于内存页的读取，这些数据通常存在着一定的格式上的限制，或者说，位上的限制。简单来说，如果允许一些乱七八糟的位排序，那可能会涉及到一些数据的跨页读取和处理，这是我们不想看到的，使用空间来换取一些时间是可以接受的。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250304185806219.png" alt="image-20250304185806219"></p>
<p>​	正如之前CSAPP中看到过的情况一样，这种不符合64bit的格式布局其实很令人恼火，因为这会导致在读取时CPU需要去对于cdate进行一次跨字段的读取，而这通常需要俩次读取操作。当这种设计很频繁时，对于一个元组数据的读取，最差情况可能会恶化到优美排列的2倍。</p>
<p>​	要解决这种问题自然很简单，就像之前遇到过的一致，对于字节段进行一定的重排以及补充，使得其能够更加符合64位上的结构，就比如如果还是现在这种情况去填充字节，那么需要填充的字段可能需要多次，但是如果我们能够去进行一定的重排，使得各个小的字段去尽可能的凑成一个接近于64位的字段，我们就不必要去为每个字段都进行补齐，这在CSAPP中已经见过，简单了解即可。就比如下面这个demo</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250304190504359.png" alt="image-20250304190504359"></p>
<h1 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h1><p>​	接下来讨论下对于NULL的处理。在数据库中，对于所有的域，都有着NULL值的存在，就设计上来看，我们一般不会像将这种空值设置为一种相对于其实值特殊的存在。虽然它特殊，但是特殊的只有它，为了这种值去额外设计一种麻烦的结构是我们不想看到的。运用设计模式的知识，我们会考虑通过一层缓冲来进行这种NULL值与其他类型的值的同化，这里有几种选择。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/3-databaseStorage_Log/image-20250304192920988.png" alt="image-20250304192920988"></p>
<p>​	这块部分简单过一下即可。</p>
<ul>
<li>使用一个空的位图头来进行标识，简单点说，就是设计出一个额外的结构来进行标识该元组的属性是否为空值，即课本中的空位图设计，这个看课本很容易看懂，略过。位于P311页处。</li>
<li>使用一个特殊值来进行标识，这种也很好理解，略过</li>
<li>为每个空值额外添加一个位来进行标识，但是这种事不推荐的一种做法，毕竟首先你就无法想象这种特殊化的操作会给后续的维护带来多大的麻烦，这种额外加了一位的操作会导致对齐以及解析方面的问题，很令人反感。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>文本摘抄</title>
    <url>/2025/08/26/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/1-abstract/</url>
    <content><![CDATA[<p>本专栏用于部分书中优质内容的摘抄，请注意，只是那部分相对来说对于我个人感触较大的，不是对于全部内容，叠个盾()</p>
<span id="more"></span>

<h2 id="问题空间和解决方案空间"><a href="#问题空间和解决方案空间" class="headerlink" title="问题空间和解决方案空间"></a>问题空间和解决方案空间</h2><p>对于一个软件开发，从本质上来说，其就是问题空间（Problem Space）到解决方案空间（Solution Space）的一个映射转化，如下图。</p>
<p><img src="/2025/08/26/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/1-abstract/image-20250826192409645.png" alt="image-20250826192409645"></p>
<p>​	在问题空间中，对应的关注点是当前业务正面临着的问题，通过识别问题，挖掘并分析相关的场景用例，最终勾线出对应的抽象模型，将业务领域关键事务以及关系进行可视化呈现。而在解决方案空间中，关注点则是通过具体的软件技术手段来进行系统设计以及实现。</p>
<p>​	更抽象来说，所谓的问题空间所回答的是一个做什么，即，存在哪些需要解决的问题，对应的问题的背景是什么，需求是什么等等，这需要结合的是现实中的甲方的需求进行详细的分析的。对于解决方案空间，其回答的是一个怎么做的问题，即，我需要选择什么样的工具去实现当前这个业务，为什么，怎么用一个中间件等等。通过这俩个空间的结合，从做什么以及怎么做这来个理论以及实践的方面来回答一个开发实际所需要做的简略流程。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>​	架构一词难以官方定义，引用书中引用的一个定义以及对应的图。ISO&#x2F;IEC  42010:20072 中对架构的定义为：“架构是一个系统的核心组织，用于阐明模块或组件的职责，以及相应的约束设计和演化原则。”根据定义，可以概括出如图 4-1 所示  的公式。</p>
<p><img src="/2025/08/26/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/1-abstract/image-20250826194112452.png" alt="image-20250826194112452"></p>
<p>​	但是对于我来说，我存在一个考虑，就是为什么要给一个词下一个定义？对其下一个定义对于我们来说存在什么作用？使用外人给出的定义相对来说对于我们来说存在什么作用？</p>
<p>​	基本对于现在的我(2025-8-26)来说，我个人理解的，对于一个词下一个定义，首先会有一个先决条件，就是其足够复杂以及抽象，就比如架构一词，即使说平常时常使用，但是在切实的想抓住其并进行理解时却由于其过于抽象会难以理解，这是如果有别人的一个过往经验来辅助理解将是极好的。</p>
<p>​	回过头来，所谓的架构，个人感觉，实际上是对于一个开发流程中的规范，其所想描述的是到底系统中存在什么，为什么存在这些以及这些之间存在什么等等。这是由于一个软件开发流程中实际上都存在一个周期，即使是对于目前我这种没有参与过企业开发流程的来说，我对于个人项目的把握也会在一段时间淡忘很多，如果想要在淡忘后能够较为高效的重新拾起对应的内容，势必需要一层规范来约定在之前开发流程的操作。通过这一层对应的约束，其能够使得整体的开发流程稍微的可控。</p>
<p>​	依照书中所说，架构本身存在三大支柱:</p>
<ul>
<li><strong>模块&#x2F;组件 (Building Blocks)<strong>：系统由哪些</strong>核心部分</strong>构成？这是结构的静态描述。</li>
<li><strong>职责与关系 (Responsibilities &amp; Interactions)<strong>：各个部分</strong>做什么</strong>（职责）？它们之间<strong>如何协作</strong>（关系）？这是行为的动态描述。</li>
<li><strong>指导原则 (Guiding Principles)<strong>：设计和演化的</strong>规则与约束</strong>。为什么这样设计？未来变更要遵循什么原则？（例如：“所有模块间必须通过API通信，禁止直接读写数据库”、“系统必须支持水平扩展”）。<strong>这是最容易忽略但最能体现架构师价值的部分。</strong></li>
</ul>
<p>​	</p>
<p>​	这三个是上面的公式对于一个软件的高度概括，实际上，通过这三个支柱，我们能够形成其自己去窥探一个新接触的项目的路径。就比如，看到一个系统，就问自己三个问题：它的核心组件是什么？它们怎么分工协作？它遵循了什么设计原则？</p>
<p>基础了解了什么是架构之后，我们从另外一个方面来了解架构本身是怎么在一个软件开发流程中存在的</p>
<table>
<thead>
<tr>
<th align="left">架构类型</th>
<th align="left">所属空间</th>
<th align="left"><strong>核心关注点</strong>（回答什么问题）</th>
<th align="left"><strong>产出物形态</strong>（像什么）</th>
<th align="left"><strong>目的</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>业务架构</strong></td>
<td align="left"><strong>问题空间</strong></td>
<td align="left"><strong>“做什么？”</strong> 产品有哪些业务模块？ 每个模块提供什么<strong>能力</strong>？ 模块间如何<strong>业务联动</strong>？</td>
<td align="left"><strong>业务蓝图</strong> （类似于企业组织架构图）</td>
<td align="left"><strong>统一共识</strong> 让产品、研发、业务方对要构建的业务世界有一致的认知。</td>
</tr>
<tr>
<td align="left"><strong>逻辑架构</strong></td>
<td align="left"><strong>解决方案空间</strong></td>
<td align="left"><strong>“怎么做？”</strong> 系统有哪些<strong>软件模块</strong>？ 模块间<strong>接口</strong>如何定义？ <strong>关键流程</strong>如何实现？</td>
<td align="left"><strong>系统设计图</strong> （如UML组件图、时序图）</td>
<td align="left"><strong>指导开发</strong> 告诉开发人员系统的组成部分和协作方式，是编码的直接依据。</td>
</tr>
<tr>
<td align="left"><strong>物理架构</strong></td>
<td align="left"><strong>解决方案空间</strong></td>
<td align="left"><strong>“怎么运行？”</strong> 软件<strong>部署</strong>在多少台机器上？ 如何配置<strong>网络</strong>和<strong>负载均衡</strong>？ 如何满足<strong>性能、可靠性</strong>等非功能需求？</td>
<td align="left"><strong>部署架构图</strong> （标有服务器、网络、中间件的拓扑图）</td>
<td align="left"><strong>指导部署运维</strong> 告诉运维人员如何让系统高效、稳定、安全地跑起来。</td>
</tr>
</tbody></table>
<p>​	总的来说，对于架构这个概念本身的解构，实际上不要求我们本身在一开始就能够去所谓的开始架构一个本身的大型应用，实际上其是相对潜移默化的，就比如对于我来说，我能够在了解了上诉架构本身的三个支柱以及对应的架构所处的时间片以及一些信息之后，我能够在后续的review中，更好的考虑到到底为什么做这个，到底怎么与其他模块联动等，而不是局限于当前的业务的上下文。</p>
<p>​	以及存在最重要的一点，我们最快的学习方法，实际上就是去找一些比自己牛的人去沟通，但是很多时候对于人来说都是厌蠢的，对于本人也是一样，或者说，无论对于任何人都一样，你不能期望你所提出的一个抽象的问题能够得到别人的回答，你在回答之前，你需要先明确我该问题到底需要问什么，对应的我个人的实际需求是什么，以及怎么减少废话。特别是在软件这一领域，对于如何架构本身的问题实际上也是一门学问。就比如说，我从谈论架构一次开始到现在，我已经偏离了我一开始的预想结构，甚至于我当前也不知道怎么回归，你怎么看呢？</p>
<blockquote>
<p>以下为AI总结后的一个版本，选择观看</p>
</blockquote>
<hr>
<h1 id="文本摘抄（精简版）"><a href="#文本摘抄（精简版）" class="headerlink" title="文本摘抄（精简版）"></a>文本摘抄（精简版）</h1><h2 id="问题空间-解决方案空间"><a href="#问题空间-解决方案空间" class="headerlink" title="问题空间 &amp; 解决方案空间"></a>问题空间 &amp; 解决方案空间</h2><ul>
<li><strong>问题空间（Problem Space）</strong>：回答 <em>做什么</em>。<br> → 识别业务问题、场景、用例，抽象出领域模型（业务要素+关系）。</li>
<li><strong>解决方案空间（Solution Space）</strong>：回答 <em>怎么做</em>。<br> → 通过技术手段进行系统设计、模块划分、实现与部署。</li>
<li>二者结合：从「需求 → 技术方案」的转化路径。</li>
</ul>
<hr>
<h2 id="架构的定义与价值"><a href="#架构的定义与价值" class="headerlink" title="架构的定义与价值"></a>架构的定义与价值</h2><ul>
<li><strong>ISO&#x2F;IEC 42010:2007 定义</strong>：架构 &#x3D; 系统的核心组织 + 模块职责 + 约束设计与演化原则。</li>
<li><strong>个人理解</strong>：<ul>
<li>定义的价值：为复杂、抽象的事物提供理解的“抓手”。</li>
<li>架构本质：对系统的组织方式进行规范，帮助长期维护和迭代，避免遗忘和失控。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="架构三大支柱"><a href="#架构三大支柱" class="headerlink" title="架构三大支柱"></a>架构三大支柱</h2><ol>
<li><strong>模块&#x2F;组件</strong>：系统由哪些核心部分构成？（静态结构）</li>
<li><strong>职责与关系</strong>：各部分负责什么？如何协作？（动态行为）</li>
<li><strong>指导原则</strong>：设计和演化的约束与规则（如“必须 API 通信”、“支持水平扩展”）。<br> 👉 学习或观察系统时，可以反问：<strong>核心组件是什么？如何协作？遵循什么原则？</strong></li>
</ol>
<hr>
<h2 id="架构的类型"><a href="#架构的类型" class="headerlink" title="架构的类型"></a>架构的类型</h2><table>
<thead>
<tr>
<th>架构类型</th>
<th>所属空间</th>
<th>回答的问题</th>
<th>产出物</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td><strong>业务架构</strong></td>
<td>问题空间</td>
<td>做什么？</td>
<td>业务蓝图</td>
<td>统一共识</td>
</tr>
<tr>
<td><strong>逻辑架构</strong></td>
<td>方案空间</td>
<td>怎么做？</td>
<td>系统设计图</td>
<td>指导开发</td>
</tr>
<tr>
<td><strong>物理架构</strong></td>
<td>方案空间</td>
<td>怎么运行？</td>
<td>部署架构图</td>
<td>指导运维</td>
</tr>
</tbody></table>
<hr>
<h2 id="学习架构的启示"><a href="#学习架构的启示" class="headerlink" title="学习架构的启示"></a>学习架构的启示</h2><ul>
<li>不必急于“设计大而全的架构”，更重要的是在迭代和 Review 中逐步体会“为什么这样设计，如何联动”。</li>
<li>提问&#x2F;学习要具体化：先明确需求，再减少废话。</li>
<li>架构思维 &#x3D; 一种心智模型，帮助在复杂系统中抓住<strong>核心、协作、原则</strong>三个锚点。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>服务端开发</category>
      </categories>
      <tags>
        <tag>服务端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>依赖</title>
    <url>/2025/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93/8-%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="关系数据库设计"><a href="#关系数据库设计" class="headerlink" title="关系数据库设计"></a>关系数据库设计</h1><p>略去前置知识，保留一些比较重要的知识，不保证连贯性，需要自行阅读书本后再来进行串联起来</p>
<hr>
<h2 id="关系模式的分解"><a href="#关系模式的分解" class="headerlink" title="关系模式的分解"></a><strong>关系模式的分解</strong></h2><p>在数据库设计中，<strong>分解（Decomposition）</strong>是指将一个关系模式拆分为多个子模式，以减少冗余、消除数据异常，并提高数据一致性。</p>
<hr>
<span id="more"></span>

<h3 id="1-无损分解（Lossless-Decomposition）"><a href="#1-无损分解（Lossless-Decomposition）" class="headerlink" title="1. 无损分解（Lossless Decomposition）"></a><strong>1. 无损分解（Lossless Decomposition）</strong></h3><blockquote>
<p><strong>如果关系模式 RR 被分解成 R1和 R2，且通过 R1 和 R2的</strong>自然连接（Natural Join）<strong>能够</strong>无损<strong>地恢复原始关系 RR，则称该分解为</strong>无损分解<strong>（Lossless Decomposition）。</strong></p>
</blockquote>
<p><strong>数学表达：</strong></p>
<ul>
<li>设 <strong>R(A,B,C)R(A, B, C)</strong> 被分解为 **R1(A,B)**和 **R2(B,C)**。</li>
<li>如果对任意可能的数据集合，执行<strong>自然连接</strong>： <strong>R1⋈R2&#x3D; R</strong> 且不会产生<strong>额外的元组</strong>，也不会<strong>丢失信息</strong>，则该分解是<strong>无损的</strong>。</li>
</ul>
<hr>
<h3 id="2-有损分解（Lossy-Decomposition）"><a href="#2-有损分解（Lossy-Decomposition）" class="headerlink" title="2. 有损分解（Lossy Decomposition）"></a><strong>2. 有损分解（Lossy Decomposition）</strong></h3><blockquote>
<p><strong>如果关系模式的分解导致信息丢失或产生额外的错误数据，则称为有损分解（Lossy Decomposition）。</strong></p>
</blockquote>
<h4 id="示例：有损分解"><a href="#示例：有损分解" class="headerlink" title="示例：有损分解"></a><strong>示例：有损分解</strong></h4><p>考虑以下关系：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">employee(ID, name, street, city, salary)</span><br></pre></td></tr></table></figure>

<p>我们尝试将其分解为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">employee1(ID, name)</span><br><span class="line">employee2(name, street, city, salary)</span><br></pre></td></tr></table></figure>

<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a><strong>问题分析</strong></h4><ul>
<li><p>这个分解的<strong>交集</strong>属性集是 <code>&#123;name&#125;</code>，但 <code>name</code> <strong>并不是主键</strong>，因为可能存在<strong>重名的员工</strong>！</p>
</li>
<li><p>当我们进行自然连接：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee1 <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> employee2;</span><br></pre></td></tr></table></figure>

<p>可能会出现原关系中不存在的错误数据（即笛卡尔积导致的额外元组）。</p>
</li>
</ul>
<p><strong>示例数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">employee1:</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span> ID <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> 张三 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> 李四 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"></span><br><span class="line">employee2:</span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span> street  <span class="operator">|</span> city <span class="operator">|</span> salary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> 张三 <span class="operator">|</span> A街道   <span class="operator">|</span> X市  <span class="operator">|</span> <span class="number">5000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李四 <span class="operator">|</span> B街道   <span class="operator">|</span> Y市  <span class="operator">|</span> <span class="number">6000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 张三 <span class="operator">|</span> C街道   <span class="operator">|</span> Z市  <span class="operator">|</span> <span class="number">7000</span>   <span class="operator">|</span>  <span class="comment">-- 另一个张三</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+--------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>由于 <code>name</code>不是唯一的，当 <code>employee1</code>和 <code>employee2</code>进行自然连接时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee1 <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> employee2;</span><br></pre></td></tr></table></figure>

<p>可能会产生错误的组合，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1, 张三, A街道, X市, 5000)</span><br><span class="line">(1, 张三, C街道, Z市, 7000)  -- 这个组合可能不正确！</span><br></pre></td></tr></table></figure>

<p>这表示 <code>ID=1</code>的张三可能会匹配到错误的地址，导致数据不一致。</p>
</li>
</ul>
<p><strong>结论</strong>：</p>
<ul>
<li><strong>因为连接后产生了原关系中不存在的元组，该分解是有损的！</strong></li>
</ul>
<hr>
<h3 id="3-如何确保无损分解？"><a href="#3-如何确保无损分解？" class="headerlink" title="3. 如何确保无损分解？"></a><strong>3. 如何确保无损分解？</strong></h3><p>一个分解 <strong>R→R1,R2</strong> 是无损的，当且仅当：</p>
<ul>
<li><strong>R1∩R2（两个子关系的交集）至少包含一个候选码（Candidate Key）的属性</strong></li>
</ul>
<h4 id="无损分解示例"><a href="#无损分解示例" class="headerlink" title="无损分解示例"></a><strong>无损分解示例</strong></h4><p>假设 <code>employee</code> 关系：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">employee(ID, name, street, city, salary)</span><br></pre></td></tr></table></figure>

<p>我们进行如下<strong>无损分解</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">employee1(ID, name, street, city)</span><br><span class="line">employee2(ID, salary)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里 <code>ID</code> 是主键，且 <code>ID</code> 作为<strong>交集</strong>出现在 <code>employee1</code> 和 <code>employee2</code> 中。</p>
</li>
<li><p>由于 <code>ID</code> 可以唯一标识一个员工，所以自然连接：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee1 <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> employee2;</span><br></pre></td></tr></table></figure>

<p>可以正确恢复 <code>employee</code>无丢失也无多余元组</p>
</li>
</ul>
<hr>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a><strong>4. 小结</strong></h3><table>
<thead>
<tr>
<th>分解类型</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>无损分解</strong></td>
<td>通过自然连接可以完全恢复原始数据，不会丢失信息，也不会产生额外的元组。</td>
</tr>
<tr>
<td><strong>有损分解</strong></td>
<td>自然连接后可能会丢失信息或产生错误的额外元组，导致数据不一致。</td>
</tr>
</tbody></table>
<p><strong>确保无损分解的方法：</strong> ✅ <strong>交集属性</strong> 至少包含<strong>候选码的一部分</strong>，这样才能确保自然连接时不会丢失数据。</p>
<hr>
<h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在<strong>关系数据库</strong>中，函数依赖（Functional Dependency, FD）<strong>描述的是</strong>属性之间的关系，表示<strong>一个属性的值能够唯一确定另一个属性的值</strong>。</p>
<p><strong>数学定义：</strong></p>
<blockquote>
<p><strong>设 R(U) 是一个关系模式，X 和 Y 是 U 的属性集，如果对于 R 中的任意两个元组 t1 和 t2，若 t1[X] &#x3D; t2[X]，则必有 t1[Y] &#x3D; t2[Y]，则称 X 函数确定 Y，记作：</strong></p>
<p>X→Y</p>
<p><strong>读作 “X 函数确定 Y” 或 “Y 依赖于 X”</strong></p>
</blockquote>
<p>简单来说，<strong>如果知道 X 的值，就可以唯一确定 Y 的值</strong>。</p>
<p>用简单的话来解释下这个定义：假设我们现在有一个模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">department(dept_name,building,budget)</span><br></pre></td></tr></table></figure>

<p>当我们查询任意一个元组是，如果我们已经知道了其中的一个dept_name,而且我们能通过这个dept_name区推导得出一个唯一的building值的话，那我们称这俩个属性在这个模式中构成函数依赖。而且是由dept_name决定building，所以应该表达为dept_name→building。</p>
<blockquote>
<p>在E-R模型的学习中。我们应该理解到了，无论是E-R模型，还是关系数据库模型，其本质都只是一个模型。而模型的本质则是对于现实世界的一种抽象，所以很多概念都是共通的，只是一些定义上的些许差别。我们需要的是一种从已有的网状知识图谱中去找到一条能通往新学习的知识的路线。而不是从0开始再进行知识点网的构建。</p>
<p>所以所谓函数依赖其实可以视为是E-R模型中的映射基数中的一对一情况在关系模式中的体现。</p>
</blockquote>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p>有了函数依赖这个概念，我们回过头来看到我们之前碰到的关于超码的分析</p>
<p>​	我们先来重温下超码的逻辑概念。</p>
<blockquote>
<p>在一个模式中，当元组的一个或多个属性的集合能够唯一的标识出一个元组时，这个属性的集合可以视为该模式的一个超码。</p>
</blockquote>
<p>​	对于超码来说，函数依赖的逻辑定位与其十分相像，对于一个函数依赖，我们能够通过一个或多个属性来推导出另外的一个或多个属性。不难联想到，当我们函数依赖的推导方与被推导方的并集能够完美的覆盖整个模式时，这种函数依赖的推导方应该能被称之为超码。</p>
<p>​	对于一个函数依赖来推导超码的情况，有一点需要特别注意。当我们使用一个逻辑上的试图来推导函数依赖时，此时我们判断的基础是当前数据库模式的一个快照。</p>
<p>​	就比如，我们拥有如下一个模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classroom(building,room_number,capacity)</span><br></pre></td></tr></table></figure>

<p>​	我们根据该模式的一个快照来进行函数依赖的推导，此时所有的room_number都有着其一个capacity,而且所有的capacity都不相同。此时我们可能会把<strong>room_number-&gt;capacity</strong>作为一个函数依赖来进行使用。但是，这样是否存在问题呢？</p>
<p>​	我们抽象回来看到现实视图。在一个教学楼中可能存在着各种容量的教室，这没有问题。在多个教学楼中，存在着多个编号相同的教室，这也没有问题。在不同教学楼的编号相同的教室中，出现相同容量的情况，这也没有问题吧。但是问题就来了，这里如果我们的逻辑层函数依赖<strong>room_number-&gt;capacity</strong>成立，那么在之后某次可能的SQL插入中，完全有可能插入一个除了building之外完全相同的元组，此时我们的函数依赖<strong>room_number-&gt;capacity</strong>就不成立了。</p>
<p>​	基于上面那个例子，我想强调的是一句话:</p>
<blockquote>
<p>一个关系的实例可能满足的某些函数依赖并不需要再该关系的模式上成立。</p>
<p>简单来说，我们在一个数据库模式中去思考函数依赖的构建，其都是基于当前关系的一个快照推导的。此时快照推导出来的函数依赖不存在问题不代表着该模式在接下来的使用中都不会存在问题。因此，我们得看到一个模式的本质，其是对现实世界中存在的事物的抽象建模，我们对于函数依赖的思考应该是基于这层抽象建模而不应该基于当前系统的一个快照。</p>
</blockquote>
<p>​	因此，我们可以总结出来自己的一句话</p>
<blockquote>
<p>一个模式的快照实例可能满足的某些函数依赖，并不意味着这些依赖在该关系的模式上永远成立。</p>
</blockquote>
<p>下面给出一个测试demo，自行测试</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> classroom (</span><br><span class="line">    building <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    room_number <span class="type">INT</span>,</span><br><span class="line">    capacity <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 插入数据，当前快照满足 &quot;room_number → capacity&quot;</span></span><br><span class="line"><span class="comment">-- 对于 room_number 101，总是对应 capacity 为 50</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> classroom (building, room_number, capacity) <span class="keyword">VALUES</span> (<span class="string">&#x27;A&#x27;</span>, <span class="number">101</span>, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> classroom (building, room_number, capacity) <span class="keyword">VALUES</span> (<span class="string">&#x27;B&#x27;</span>, <span class="number">102</span>, <span class="number">60</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> classroom (building, room_number, capacity) <span class="keyword">VALUES</span> (<span class="string">&#x27;C&#x27;</span>, <span class="number">101</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询当前数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> classroom;</span><br><span class="line"><span class="comment">-- 结果：</span></span><br><span class="line"><span class="comment">-- | building | room_number | capacity |</span></span><br><span class="line"><span class="comment">-- |----------|-------------|----------|</span></span><br><span class="line"><span class="comment">-- | A        | 101         | 50       |</span></span><br><span class="line"><span class="comment">-- | B        | 102         | 60       |</span></span><br><span class="line"><span class="comment">-- | C        | 101         | 50       |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 插入一个新记录，打破 &quot;room_number → capacity&quot; 的依赖</span></span><br><span class="line"><span class="comment">-- 由于 room_number 101 在前面均对应 50，现在插入一个 capacity 为 100 的记录</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> classroom (building, room_number, capacity) <span class="keyword">VALUES</span> (<span class="string">&#x27;D&#x27;</span>, <span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次查询数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> classroom;</span><br><span class="line"><span class="comment">-- 结果：</span></span><br><span class="line"><span class="comment">-- | building | room_number | capacity |</span></span><br><span class="line"><span class="comment">-- |----------|-------------|----------|</span></span><br><span class="line"><span class="comment">-- | A        | 101         | 50       |</span></span><br><span class="line"><span class="comment">-- | B        | 102         | 60       |</span></span><br><span class="line"><span class="comment">-- | C        | 101         | 50       |</span></span><br><span class="line"><span class="comment">-- | D        | 101         | 100      |</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ASIO-ENDPOINT</title>
    <url>/2025/02/23/%E7%BD%91%E7%BB%9C/asio%E7%BB%88%E7%AB%AF/</url>
    <content><![CDATA[<blockquote>
<p>前情提醒，在本次学习中，我使用的代码将会是llfc大佬的代码，因为实在是懒的敲，这段博客可以视为是我个人的一个笔记。具体的可以去看llfc大佬的个人博客喵</p>
</blockquote>
<h2 id="终端节点"><a href="#终端节点" class="headerlink" title="终端节点"></a>终端节点</h2><p>​	在网络编程中，联系端对端的基础单位是一个套接字，对于asio来说，其实现了一层自己的框架，或者说规则。其对于使用其来开发的网络编程中进行了一系列的封装。在这其中，终端该概念，就是基于套接字进行的封装。但是需要注意的是，终端节点本身并不是一个套接字，只有对其进行进一步的包装，其才能成为一个合格的套接字。</p>
<p>​	我们来看到对应的创建终端节点的代码。正如在之前的tinyweb去创建一个套接字的前置工作一样，我们这里也需要对于终端节点的构造进行一些前置准备。简单来说，为了生成一个终端节点，我们需要先去包装一个ip地址以及对应的窗口。类比对应的getaddrinfo系统调用即使前俩个参数的信息。那么对于ip地址的构建，其又存在着什么规则呢，请看看下面源码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">client_end_point</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string raw_ip_address = <span class="string">&quot;127.4.8.1&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num=<span class="number">3333</span>;</span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line">    asio::ip::address ip_address = asio::ip::<span class="built_in">make_address</span>(raw_ip_address,ec);</span><br><span class="line">    <span class="keyword">if</span>(ec.<span class="built_in">value</span>()!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Failed to parse the IP adderss,Error code = &quot;</span>&lt;&lt;ec.<span class="built_in">value</span>()&lt;&lt;<span class="string">&quot;.Message is &quot;</span>&lt;&lt;ec.<span class="built_in">message</span>();</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address,port_num)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里以客户端的终端节点创建为例，在创建节点前，我们需要优先知道所需要连接的服务器端的ip地址。有了这个ip地址，再配合我们自己声明的一个用于储存错误代码的<code>boost::system::error_code</code>成员，我们可以进行<code>make_address</code>函数的调用。该函数位于<code>asio::ip</code>域下，使用一个ip地址和一个错误储存码来构建一个在asio中合格意义的ip地址。</p>
<blockquote>
<p>​	前面的传入ip地址只是一个字符串，直接使用其来进行通信具有太多的风险，使用类来对其进行包装能使得程序更加健壮。</p>
</blockquote>
<p>​	对于第二个参数，顾名思义，其是一个错误储存码，储存着在该次创建过程中的状态信息，当且仅当在函数正常返回时返回0.对于这种简单的错误处理，之后将不再进行赘述。</p>
<p>​	在创建完一个封装完毕的ip地址之后，我们可以使用其来构建我们的ip地址。在asio中，相对于之前直接使用c系统调用来进行创建的最大不同点是，我们在这里不必再对其进行一些属性信息在传递参数上的设置。更简单的。C++实现的asio通过类作用域来进行一个区分，这样既显式的指出了我们在创建一个终端节点时的繁琐，而且大大提高了使用的连接的可读性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address,port_num)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	在该类对象创建中，通过传入一个ip地址和对应的端口号，我们可以对其进行一个绑定，由于这是一个客户端，所以这里指定的其实就是对应的服务器端的服务提供位置。除此之外，还可以看到，在该类成员构造之前，我们使用了一系列的类作用域限定符。通过<code>ip::tcp::endpoint</code>这种层次上的逻辑，我们不难推断出在该终端节点中我们使用的协议以及该成员变量的用处。</p>
<p>​	接下来来看到对应与客户端节点的服务器端节点的创建，正如一般的网络编程的服务器端设置比客户端设置简单一样。对应的服务器端由于使用的端口地址被固定为了本地地址，所以这里的终端节点的创建也更加简单。但是，这是基于简单的实现的。在asio或者更加现代的网络库中，对于机器监听的设置更加灵活。对于一个进程所请求的监听设置，其可能不再局限于一个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">server_end_point</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Step 1. Here we assume that the server application has</span></span><br><span class="line">    <span class="comment">//already obtained the protocol port number.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">3333</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 2. Create special object of asio::ip::address class</span></span><br><span class="line">    <span class="comment">// that specifies all IP-addresses available on the host. Note</span></span><br><span class="line">    <span class="comment">// that here we assume that server works over IPv6 protocol.</span></span><br><span class="line">    asio::ip::address ip_address = asio::ip::address_v6::<span class="built_in">any</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 3.</span></span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address, port_num)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 4. The endpoint is created and can be used to </span></span><br><span class="line">    <span class="comment">// specify the IP addresses and a port number on which </span></span><br><span class="line">    <span class="comment">// the server application wants to listen for incoming </span></span><br><span class="line">    <span class="comment">// connections.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在这里，我们需要对于一个计算机上的ip地址再进行一下分析。在很多情况下，我们其实都认为一个计算机存在一个自己唯一的ip地址。事实上也确实如此，但是！这是相对于整个互联网网络来说的。对于一个计算机本身，其还存在着一系列的用于本身的测试等作用的地址，就比如我们很熟悉的本地回环地址<code>localhost</code>。这个回环地址与计算机在公网上的地址是不一样的。</p>
<p>​	回到我们这里的服务器端的地址的构建，这里其实本质上是将所有的本地使用的地址都绑定到了对应的类结构上了。这个可以去查看对应的<code>asio::ip::address</code>源码去了解。对应的，一但使用any进行对应的服务器ip地址的构建，其将能够接受来自本机上所有不同属性的请求。就比如，来自本地的IPV6协议网络请求，来自局域网和公网的网络请求等。但是，这并不意味着使用any绑定后该进程能够拦截所有来自外部的请求。对应的请求还是只能传输给对应的端口。这里也就是不必关心出现问题的原因。</p>
<p>​	在创建出对应的IP地址之后，接下来的终端节点创建工作与客户端无异，这里就直接跳过了。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>ASYNC</title>
    <url>/2025/04/04/%E7%BD%91%E7%BB%9C/async/</url>
    <content><![CDATA[<h1 id="异步读写"><a href="#异步读写" class="headerlink" title="异步读写"></a>异步读写</h1><blockquote>
<p>​	接下来主要了解一下对于ASIO中关于异步读写的模型，前情提醒，由于我是跟着另外一个博客学习的，所以自己的理解上面可能存在着一些错误的地方，如果知道，请斧正。</p>
</blockquote>
<span id="more"></span>

<h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h2><p>​	只要你学过OS，你就应该知道，对于一个同步操作来说，其存在的隐藏缺陷是什么，虽然说同步操作可以由用户自己来控制调用的顺序，但是同步操作是一个阻塞形的调用。其在发出I&#x2F;O之后是会阻塞当前CPU的，而I&#x2F;O操作往往会消耗上几毫秒甚至于更长的时间，这是不可接受的。所以自然就出现了一种不会使得I&#x2F;O操作阻塞当前CPU的思想，那自然就是异步。</p>
<p>​	对于异步操作来说，其的本质逻辑其实很简单，就是通过将一系列的程序行为封装为一系列的对象，或者更实际点，任务。通过一个任务调度器，来管理这些任务的执行过程，但是在这里还是没有完成一种阻塞的转移，因为对于I&#x2F;O操作来说，其本身无论如何都是会阻塞当前线程的。所以需要一种机制，能够使得这种阻塞不会反应到当前执行的主线程中，而这种通过开辟一个线程可以简单的实现。同时，我们要求在主线程中需要持有该调度机制的一种引用，使得在完成一定的工作后调度程序能够直接通知主线程完成了工作，但那个不是本次的内容范围了(当然，这通过线程共享空间的性质可以简单实现就是了)。</p>
<h2 id="ASIO异步"><a href="#ASIO异步" class="headerlink" title="ASIO异步"></a>ASIO异步</h2><p>​	对于ASIO的读写来说，为了避免同步读写时阻塞对于程序性能带来的损失，很多时候对于I&#x2F;O操作都是基于异步读写的模式的。当然，ASIO中封装了一个自己的异步读写模型，可以直接使用，但是这里先不进行了解。</p>
<p>​	先回到刚才，我们知道，对于异步模型来说，其最重要的一点是基本的事务定义，由于我们使用的是别人ASIO的框架，所以我们这里需要进行的了解对应的接口需要怎么使用。</p>
<blockquote>
<p>​	当然，想要熟悉的使用这个机制，必须了解底层的异步，也就是刚才的前情回顾这一块。当然，了解这些并不是为了让你能够真正的去手搓出一个自己的异步模型出来，或者说，对我来说并不是为了这个。对我来说，了解这种底层的思想，本质上其实是为了在接触这种高度完成的框架中去快速熟悉各种知识点。我十分推荐阅读本文的各位都去试一下先去简单的了解底层再来学习高层框架，那么会回来感谢我的(doge)。</p>
</blockquote>
<p>​	对于ASIO的异步操作模型来说，其的使用很简单，由于模型本身已经给我们提供了一套相对完整的框架，即一系列的<code>async_*</code>异步读写函数。我们在这里可以先把其分割为底层api和高层api来进行了解。我们现在先来了解对应的底层apia，<code>async_*_some</code>系列函数。</p>
<blockquote>
<p>我们在这里只介绍一套读的async函数，读写的使用之间是基本一致的，不必多说</p>
</blockquote>
<h2 id="状态保持"><a href="#状态保持" class="headerlink" title="状态保持"></a>状态保持</h2><p>​	我们在前面已经知道，对于一个读写函数来说，其本身是可能不会完成对于数据的完整读取的，就比如我们前面的同步读系列_some函数。那么，我们需要一个结构来进行对于读写期间操作数据的状态的保持。想象一下，如果这个结构不存在，关于读写数据的信息是松散的，那么其在编码和使用层面将会是一个地狱。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最大报文接收大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> RECVSIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">MsgNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">MsgNode</span>(<span class="type">const</span> <span class="type">char</span>* msg,  <span class="type">int</span> total_len): _total_len(total_len), _cur_len(<span class="number">0</span>)&#123;</span><br><span class="line">        _msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];</span><br><span class="line">        <span class="built_in">memcpy</span>(_msg, msg, total_len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MsgNode</span>(<span class="type">int</span> total_len) :_total_len(total_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">        _msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MsgNode</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[]_msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消息首地址</span></span><br><span class="line">    <span class="type">char</span>* _msg;</span><br><span class="line">    <span class="comment">//总长度</span></span><br><span class="line">    <span class="type">int</span> _total_len;</span><br><span class="line">    <span class="comment">//当前长度</span></span><br><span class="line">    <span class="type">int</span> _cur_len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	在一个信息结构中，其实最主要的是它的信息，而不是它的功能，所以需要的是其对于信息的提供能力，如上图，当然，你可以采用你认为的更美观合理的办法，这里不再对其进行赘诉。</p>
<h2 id="异步读"><a href="#异步读" class="headerlink" title="异步读"></a>异步读</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteCallBackErr</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp; ec, std::<span class="type">size_t</span> bytes_transferred,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::shared_ptr&lt;MsgNode&gt;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteToSocketErr</span><span class="params">(<span class="type">const</span> std::string&amp; buf)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;MsgNode&gt; _send_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这里其实没什么好说的，我们直接进入一个合格的读写操作的基础要素。需要注意的是，在本文中，很多东西的假设都是很不现实的，在之后会逐渐进行扩展，就像OSTEP一书中线提出一系列的约束再一步步解开一样。不过这里，诶，我不说哪里的问题。</p>
<p>​	首先我们来看一下我们这里创建的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteCallBackErr</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp; ec, std::<span class="type">size_t</span> bytes_transferred,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::shared_ptr&lt;MsgNode&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteToSocketErr</span><span class="params">(<span class="type">const</span> std::string&amp; buf)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	我们需要先了解一下该函数的地位，这俩个函数是为了来实现我们一个相对完整的读操作的，<code>void WriteToSocketErr(const std::string&amp; buf);</code>函数是我们提供给外界的能够完成一个正确操作的入口，只需要传入一个缓冲区数据的地址。我们来看一下这里面的实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteToSocketErr</span><span class="params">(<span class="type">const</span> std::string&amp; buf)</span> </span>&#123;</span><br><span class="line">    _send_node = <span class="built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>());</span><br><span class="line">    <span class="comment">//异步发送数据，因为异步所以不会一下发送完</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">async_write_some</span>(asio::<span class="built_in">buffer</span>(_send_node-&gt;_msg, </span><br><span class="line">        _send_node-&gt;_total_len),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;Session::WriteCallBackErr,</span><br><span class="line">            <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	对于函数的内部，其将对应的缓冲区地址封装成了一个我们实际使用的一个缓冲区地址，接下来的所有操作都是基于该缓冲区的操作。注意看该函数内的行为，其实就是一层对于外部参数往内部异步async_write_some的操作的调用参数转换与传递。</p>
<p>​	注意来看<code>async_write_some</code>函数。该函数需要三个函数，其中第一个是一个缓冲区地址，用于指定该次读写中的操作数据，在该例中即是由外部的缓冲区转换而来的node结构。其第二个参数是该次读取中所应该读取的全部的数据的长度。由于这里的是第一次传入，可以看到其实是一个_total_len成员长度。对于第三个长度，这是一个异步 _some 读写所能实现完整的读写的核心，在该函数中封装了对应的回调逻辑。</p>
<p>​	我们在前面已经了解过同步读写，在同步读写中，对应的读写操作并不一定会完成我们指定的缓冲区中的数据的全部读写，需要一些额外的操作来进行确保，这里也是如此。</p>
<p>​	你应该也能够大致猜测该回调函数的作用。就是在一次读写操作之后，检测当前是否完成了对应的全部的读写，如果未完成，这个回调函数会去执行接下来的读写。对于这里的函数的格式，由于我们是使用的人家ASIO的框架，所以我们要遵守对应的回调函数的约束。对于回调函数来说，其只需要俩个参数，或者说，只能存在俩个由框架来进行自动发送的参数，其分别占用前俩个参数。其中起一个参数是一个对应的错误码，其而是当前已经传递的字节数。至于为什么是这俩个，可以自行去阅读源码。</p>
<blockquote>
<p>你也许已经看到了，这里使用了bind函数来进行我们第三个可调用对象的构建以及传递，想一想，能不能使用该函数去进行我们该回调函数的额外个性化扩展呢？能否使用一种更好的格式来进行这里的参数的传递呢……</p>
</blockquote>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteCallBackErr</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, </span></span></span><br><span class="line"><span class="params"><span class="function">    std::<span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;MsgNode&gt; msg_node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bytes_transferred + msg_node-&gt;_cur_len </span><br><span class="line">        &lt; msg_node-&gt;_total_len) &#123;</span><br><span class="line">        _send_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">async_write_some</span>(asio::<span class="built_in">buffer</span>(_send_node-&gt;_msg+_send_node-&gt;_cur_len,</span><br><span class="line">            _send_node-&gt;_total_len-_send_node-&gt;_cur_len),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;Session::WriteCallBackErr,</span><br><span class="line">                <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	先停下来阅读一下上面的源码，分析一下为什么其为什么能够存在三个参数，我们前面不是说为什么只能有俩个参数由框架自动传递码，这里是怎么实现的，我怎么来实现它，怎么来扩展他</p>
</blockquote>
<p>​	在该回调函数中，对应的逻辑其实也很简单，就是简单的更新我们当前对应的缓冲区结构体的已传输数据的长度大小，然后根据未传输的数据进行下一次传输设置，可以看到，这里存在了又一次的<code>async_write_some</code>。想象一下在该种调用中存在的函数调用链。</p>
<p>​	总的来说，回调函数其实应该相当简单，毕竟为了效率，你不能在一个I&#x2F;O操作中封装过多的逻辑，这是非常令人厌恶的。</p>
<p>​	到了这里，你会发现，你已经基本了解了实现对应的读写操作所需要进行的步骤，虽然说还是很粗糙，但是我这里并不准备深入，感兴趣的可以去llfc大佬的博客中进行了解。在我这里，我将梳理一遍在这种设计中的基本逻辑来辅助你我的理解</p>
<h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><p>​	对于一个异步读写来说，我们最好为其封装一个内聚的结构来进行后续的操作的基础组件提供。理论上，你完全可以通过松散的结构去实现功能。但是，这在OOP的编程中是非常令人厌恶的，首先是不美观，再者其十分的难以维护，而且在系统的开发中，各种变量满天飞是非常令人绝望的。所以，在设计一个完整的异步读写操作时，我们需要的是优先设计一个美观的结构来支持我们后续的使用。</p>
<p>​	在设计了对应的数据结构之后，我们可以进入对应的服务中的异步读写操作的设计。对于一个异步读写来说，其一般都是调用由ASIO提供的异步读写函数来实现功能。但是一般的读写函数其内部并不会保证对于数据的全部读写，至少对于_some后缀来说，你可以去自己了解额外的更高层封装的读写函数，但是你得知道，它们底层的实现都是基于 _some方法的。</p>
<p>​	对于想要实现使用_some函数来实现对应的完整读写，我们需要进行对应的回调函数的设计来实现一个函数调用链的构建来实现数据的完整链式读取。一般来说，这都是通过对于数据结构体中已读取数据与总数据的更新，维护与使用来实现的。你可以回过头去看对应的回调函数，其内部是否是通过对应的地址偏移来实现的。</p>
<p>​	对我来说，整个异步读写的精髓就是这上面的三段话，当然，由于个人精力问题，我并没有对于全部内容都进行编写，你可以将其视为一种敝帚自珍。你要是想知道更多，就来盒我吧。</p>
<blockquote>
<p>包括但不限于，对于高层api如何使用底层api，为什么对应的回调函数的调用次数会不同等问题，这都是在异步读写函数中需要了解的，在这里给你列出了几条可能的方向，在你看完llfc大佬的课程后，你可以去自己想一想在这方面存在的问题已经到底怎么解决的，这会帮助你思维的建立的，如果当你能够真正看懂我这段话想讲什么，请联系我，我非常想找到一个人来交流CS的学习心得</p>
</blockquote>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑杂谈(1.0.1)</title>
    <url>/2025/04/06/%E7%BD%91%E7%BB%9C/event.1/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>本文中进行了对于另外一篇文章的简单总结和简化，可以在阅读完这篇文章之后去进行另外一篇文章的阅读，即逻辑杂谈（1）</p>
</blockquote>
<span id="more"></span>

<h1 id="Boost-Asio-的异步机制初探：启动时机与传输时机"><a href="#Boost-Asio-的异步机制初探：启动时机与传输时机" class="headerlink" title="Boost.Asio 的异步机制初探：启动时机与传输时机"></a>Boost.Asio 的异步机制初探：启动时机与传输时机</h1><h2 id="启动时机"><a href="#启动时机" class="headerlink" title="启动时机"></a>启动时机</h2><p>在最近的异步读写实例中，我注意到一些值得深入理解的点。其中最重要的一点，就是“异步驱动的执行者是谁”。</p>
<h3 id="框架的本质"><a href="#框架的本质" class="headerlink" title="框架的本质"></a>框架的本质</h3><p>学过 Qt 的人应该清楚，<strong>框架和库的区别</strong>非常关键：</p>
<ul>
<li><strong>库（Library）</strong>：由开发者主动调用函数完成任务。</li>
<li><strong>框架（Framework）</strong>：由框架主动调用你写的逻辑，开发者只需补充局部的业务处理。</li>
</ul>
<p>ASIO 也是一种典型的框架思维。在同步逻辑中，我们仍然主动调用 API，而异步逻辑中，我们仅仅<strong>注册想要的行为</strong>，执行权则交由 ASIO 来驱动。</p>
<h3 id="框架的执行逻辑"><a href="#框架的执行逻辑" class="headerlink" title="框架的执行逻辑"></a>框架的执行逻辑</h3><p>ASIO 内部维护了一个事件循环（<code>io_context</code>），它类似线程池的轮询机制，框架通过它来调度各类 I&#x2F;O 事件。而对于使用者来说，最重要的，是<strong>明确事件循环的启动与执行时机</strong>。</p>
<p>来看下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;boost/asio.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context _ioc;</span><br><span class="line">        <span class="function">Server <span class="title">s</span><span class="params">(_ioc, <span class="number">10086</span>)</span></span>;</span><br><span class="line">        _ioc.<span class="built_in">run</span>();  <span class="comment">// 真正启动服务器的时机</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>_ioc.run()</code> 才是服务器的真正启动点，而不是 <code>Server</code> 构造函数。我们不建议将 <code>run</code> 封装进构造函数中——那样会违反<strong>单一职责原则</strong>，造成耦合。</p>
<h3 id="异步状态机的思想"><a href="#异步状态机的思想" class="headerlink" title="异步状态机的思想"></a>异步状态机的思想</h3><p>理解 ASIO 的异步机制，本质上就是理解<strong>状态转移</strong>的过程。</p>
<p>状态机的抽象：函数执行流的每一个位置，视为程序的一个状态；当执行跳转到下一个函数，就发生了一次“状态转移”。</p>
<p>我们来看实际代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">short</span> port)</span><br><span class="line">    : _ioc(ioc), _acceptor(_ioc, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server start success on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl; </span><br><span class="line">    <span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start_accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session* new_session = <span class="keyword">new</span> <span class="built_in">Session</span>(_ioc);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">getSocket</span>(), </span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> new_session;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">start_accept</span>(); <span class="comment">// 注册下一次接收逻辑，实现循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态转移过程推演"><a href="#状态转移过程推演" class="headerlink" title="状态转移过程推演"></a>状态转移过程推演</h3><ol>
<li><strong>构造函数中</strong>调用 <code>start_accept()</code>，首次注册异步接收。</li>
<li><strong>异步函数 <code>async_accept</code> 不会阻塞</strong>，而是向 <code>io_context</code> 注册一个状态转移：<ul>
<li>触发点：客户端发起连接。</li>
<li>转移点：执行 <code>handle_accept</code>。</li>
</ul>
</li>
<li><strong>一旦客户端连接建立</strong>，<code>handle_accept</code> 被框架调用，状态转移发生。</li>
<li>在 <code>handle_accept</code> 结束时再次调用 <code>start_accept()</code>，重新注册下一次接收逻辑。</li>
</ol>
<p>这就构成了一个<strong>回环式状态转移</strong>的循环。</p>
<hr>
<h2 id="传输时机"><a href="#传输时机" class="headerlink" title="传输时机"></a>传输时机</h2><p>当客户端发起连接请求之后，服务器将进入下一阶段的处理——数据的接收与处理。</p>
<h3 id="套接字的创建与替换"><a href="#套接字的创建与替换" class="headerlink" title="套接字的创建与替换"></a>套接字的创建与替换</h3><p>你需要知道：<strong>服务器并不会直接使用监听套接字来接收数据</strong>，而是由操作系统生成新的连接套接字来处理数据。监听套接字的职责仅是监听并接收连接请求。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">getSocket</span>(), </span><br><span class="line">    std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br></pre></td></tr></table></figure>

<p>在一次状态转移中：</p>
<ul>
<li>操作系统在监听套接字接收请求后，会创建新的连接套接字。</li>
<li><code>async_accept</code> 中的 <code>new_session-&gt;getSocket()</code> 会成为数据传输的新载体。</li>
<li>此时，程序注册的 <code>handle_accept()</code> 就绑定到了这条连接上。</li>
</ul>
<h3 id="数据如何传输？"><a href="#数据如何传输？" class="headerlink" title="数据如何传输？"></a>数据如何传输？</h3><p>操作系统接收到数据后：</p>
<ol>
<li>数据首先到达 TCP 的内核缓冲区。</li>
<li>然后通过 OS 的内部机制，映射到与该连接对应的套接字缓冲区。</li>
<li>如果程序注册了对应的读取逻辑（比如 <code>async_read_some</code>），那么就会触发下一步的状态转移。</li>
</ol>
<p>但如果<strong>没有注册任何读取逻辑</strong>，则这些数据将被视为无用并被丢弃，造成资源浪费。</p>
<h3 id="状态转移链的维护"><a href="#状态转移链的维护" class="headerlink" title="状态转移链的维护"></a>状态转移链的维护</h3><p>在一次状态处理后，我们常常会再次注册下一次状态转移，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">start_accept</span>();</span><br></pre></td></tr></table></figure>

<p>这一点非常重要，因为 <strong>每一个异步操作只会注册一次状态转移</strong>。触发一次后就失效，如果不再注册，则程序不会再响应新的事件。</p>
<hr>
<h2 id="错误处理与双重析构风险"><a href="#错误处理与双重析构风险" class="headerlink" title="错误处理与双重析构风险"></a>错误处理与双重析构风险</h2><p>在复杂的网络逻辑中，存在如下风险：</p>
<ol>
<li>客户端断开连接。</li>
<li>程序逻辑触发某个会话的销毁，同时又注册了新的状态处理。</li>
<li>客户端发送 <code>FIN</code> 包，ASIO 响应后再次触发状态处理逻辑。</li>
<li>如果新状态中尝试访问已销毁的会话对象，会造成 <strong>双重析构</strong> 或 <strong>悬空指针</strong>，进而可能导致服务器崩溃。</li>
</ol>
<p>因此，<strong>生命周期管理</strong> 是异步编程中最难也最重要的部分。需要确保每一个异步回调的对象都在有效生命周期内。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>异步机制的核心是“<strong>状态转移</strong>”。</li>
<li>每一个异步函数注册的其实是一次触发式的状态变换。</li>
<li><code>io_context.run()</code> 是整个框架执行的起点。</li>
<li>状态转移必须在每次处理后主动注册下一次，以实现循环。</li>
<li>错误处理需要特别注意对象生命周期，避免析构冲突。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>字节序</title>
    <url>/2025/04/08/%E7%BD%91%E7%BB%9C/bytesOrder/</url>
    <content><![CDATA[<h1 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h1><p>​	在这里，我们对于机器的字节序进行一次简短的总结归纳，主要的是了解所谓的大小端字节序到底意味着什么。</p>
<span id="more"></span>

<p>​	对于大小端，你可以先将其简单的理解为一个机器中属于自己的一种对于字节的解析顺序。先从抽象的层面入手。我们先假设存在一个地址空间，如下。</p>
<p><img src="/2025/04/08/%E7%BD%91%E7%BB%9C/bytesOrder/image-20250409082426130.png" alt="字节序"></p>
<p>​	在外面的日常使用中，对于一个数字，我们有着自己的一个逻辑视图，即从左往右位数逐渐降低。或者说，我们默认相邻的俩侧左边高于右边。即逻辑视图中的情况。</p>
<p>​	那么对于大小端的数据排列呢？在此之前，我们需要先进行一下约束，我们约定抽象一个地址空间的地址为条带状的，并且从左往右对应的地址逐渐增加，或者说，代表的位置逐渐增加。即所谓的0x1001-&gt;0x1004的变化过程。通过这样，我们抽象出了一个地址空间的高低位，接下来我们将会使用这个相对位置的概念进行一些分析。可以看到，我们这里的小端序的数据排列中，我们将对应于1的数据放在了0x1001这个地址空间的低位处，而在大端中，我们则是放在了高位处。</p>
<p>​	我们先不去关心所谓的使用情况，我们先来分析一下这里的俩种字节序有着什么不同的抽象视图。我们先来抽象我们的逻辑视图中的数据摆放。众所周知，我们在写一个数据的时候会将所谓的个位十位百位从右往左逐个摆放，对应的数值也是逐渐增加。在这里我们可以抽象出:<strong>在逻辑视图中，我们将数据中代表的值比较小的放于低位中，将代表的数值比较大的数据，放于相对大的位置中。</strong></p>
<p>​	那么，我们迁移这种抽象到对应的大小端的视图中。我们可以看到，在小端序的字节序中，我们将数据中代表的值比较小的数据字节块，放到了我们的低位地址处，而将数据中象征数值比较高的数据，放到了高位地址中，这里抽象出来的逻辑与逻辑视图是一致的。</p>
<p>​	但是，由于我们抽象中的地址空间是从左往右增加的，所以在这里看来我们的小端视图会与逻辑视图相反。但是如果我们将对应的增长顺序套到另外一方中，我们就能够获得一个完全相同的逻辑表示了。</p>
<p>​	同理，这里也能够清晰的看到，我们大端序中的代表低位的数据是被放置到了地址的高位中去，这种对于数据的组织形式是与逻辑视图截然相反的。</p>
<p>​	总的来说，我们总结一下对于一个字节序的判断思路。我们可以先将一块数据抽象开来，去获悉它底层的数据组织形式与我们所已知的是否相同。就比如，我们可以创建一个<code>unsigned int</code>符号，其中储存数值为1，请注意这里使用<code>unsigned</code>的原因。接着我们可以去尝试获取一个该符号的首地址，并进行解析操作，此时如果是小端序，那么其会输出的是1，否则输出的会是0。</p>
<p>​	那么，这里，如果你足够聪明，你应该注意到了一点在这种判断逻辑中需要注意的？停下来想一想……</p>
<p>​	那就是对于一个数据的地址，在大端序或者小端序的机器中，我们机器对应的寻址是否会存在不同？答案是不会的，简单来说，无论对于什么端的机器，其在内部对于一个变量的定位都是其所占据的地址片段中的低位地址，对于这块地址需要怎么进行解析，这一块会是在这之上的封装的操作所需要关注的事情。</p>
<p>​	接下来贴出一个检测的代码，有兴趣可以去写一下，不难。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(&amp;x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="number">1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Little-endian\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Big-endian\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑杂谈(1)</title>
    <url>/2025/04/06/%E7%BD%91%E7%BB%9C/event/</url>
    <content><![CDATA[<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>​	在本文中，不会对于一个时间进行详细的深入，而是对于一些我了解到的一些机制进行一些简单的分析。</p>
<span id="more"></span>

<h2 id="启动时机"><a href="#启动时机" class="headerlink" title="启动时机"></a>启动时机</h2><p>​	在最近下一个异步读写的实例中，我看到了几点有点意思的需要我在学习中注意的点，其中一个，就是对应的异步驱动到底是由谁来进行实现的。</p>
<p>​	只要你学过QT，你应该知道一件事，对于所有的框架，其本身最重要的就是其底层的执行机制。不同于库这种由编写者来实现各种方法代码的调用，对于框架来说，你是内部的代码执行逻辑的编写者，由框架本身来执行你的代码，我们在框架中进行编写的过程只是对于一个个代码执行逻辑的补充罢了。</p>
<p>​	对于ASIO中的异步执行逻辑也是如此。如果说，前面的同步逻辑还是大部分是由我们来调用对应的库函数；那么这里的异步读写，则是我们根据框架的代码规范来提供我们想要的执行逻辑，由框架内部来自动调用我们的代码进行执行。所以，在使用框架的时候，我们非常需要注意，或者说了解的东西，一马当先的应该是对应的框架的执行逻辑，即使不进行深入的了解，也应该粗浅的有个认识。</p>
<p>​	对于asio的异步读写来说，其内部维护了一个事件循环队列。就类似于线程池中的那种轮训机制，由框架本身来提供对应的事件调度等操作。那么，对于一个框架的使用者来说，其需要注意的是什么。其需要知道的是框架本身的启动时机已经对应的执行时机。而对于ASIO的异步逻辑来说，粗浅来看，其执行对应的逻辑可以视为一个io_context在进行维护，这也就是为什么我们在一些地方会看到对应的主程序上存在对应的创建对应的服务器类后再执行对应的run操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;boost/asio.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//特别需要注意的是，_ioc才是各种读写操作的执行者</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context _ioc;</span><br><span class="line">        <span class="function">Server <span class="title">s</span><span class="params">(_ioc,<span class="number">10086</span>)</span></span>;</span><br><span class="line">        _ioc.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	对于一个服务器来说，其本质上的启动时机，并不是其在本对象创建时启动的，当然，你可以在类内去进行对应的封装，但是并不建议那么干，因为这样就不符合单一职责原则了，存在了对应的耦合。好了，回过头来，为什么说这里的io_context类的run操作才是一个服务器的真正启动时机呢。</p>
<p>​	因为对于服务器的事务来说，其本身其实是一系列的程序处理逻辑与I&#x2F;O操作构成的。其中最主要的是对应的程序处理逻辑，I&#x2F;O操作是在程序处理逻辑中派生出来的操作。而ASIO就侧重到了这一点。那么我们的程序处理逻辑到底是什么呢，其实这里就可以使用到我们的状态机的概念了。在我的理解中，对于一个程序来说，其执行一个函数方法时的程序执行流的快照，此时就可以被视为一个程序的状态，当程序开始执行另一个函数方法时，此时可以视为其由一个状态转向了另外一个状态，即状态的转移。</p>
<p>​	在我的理解中，对应的上下文中的事件注册就是这样的思想。在初始时，其规定了一系列会被外部事件触发的状态，这些外部事件是相对于本身的类对象来说的，而对于类来说，来自库函数的一系列异步函数就可以是这些外部事件，用户通过自己的设计为这些函数设置了自己的一些状态转移的方式，或者说，对应的状态转移后会到达的另外一个状态。每个状态只专注于离他最近的状态，在·这种设计中，通过一些编写者的设计，可以实现一种回环式的状态转移。</p>
<p>​	</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">short</span> port):_ioc(ioc),</span><br><span class="line">_acceptor(_ioc,tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(),port))</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Server start success on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl; </span><br><span class="line">	<span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start_accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Session* new_session = <span class="keyword">new</span> <span class="built_in">Session</span>(_ioc);</span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">getSocket</span>(), std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session,</span><br><span class="line">		std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">delete</span> new_session;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如上，我们来推导一下对应的状态转移方式。首先在外部，我们调用了对应的类的构造函数，此时构造函数中产生了一次显式的状态转移，由构造函数转向了对应的start_accept();执行流。在该执行流中，我们调用了对应的外部异步函数<code>async_accept</code>。需要注意的是，由于这里是异步的，所以这里也就不会阻塞。换句话说，这里的函数调用并不会导致一种状态转移。而是会在对应的上下文也就是io_context中去注册一种状态转移方式。这种状态转移的触发点是<code>async_accept</code>，而对应的转移点是<code>Server::handle_accept</code>执行流。</p>
<p>​	接下来我们来模拟下触发的情况，假设这里的<code>async_accept</code>函数被触发了。由于这里是由外部框架调用的，所以我们可以不太关心这里的触发逻辑，但我们需要知道的是什么时候会触发，简单来说，当计算机接受到来自外部的连接数据包时，其会解析并且触发对应的函数方法。这里简单假设，我们这里的async_accept被触发了，那么对应的接下来的执行逻辑会是什么呢？自然是执行我们绑定在该函数的下一个状态，即对应的<code>handle_accept</code>方法。</p>
<p>​	额外需要注意一点的是，在由ASIO框架管理的上下文中，每一个状态的触发只会触发一次，在触发之后对应的状态会过期，想要再次出发需要提前添加对应的处理逻辑。回来到我们这里的<code>handle_accept</code>函数。可以看到，在该函数里面，我们又进行了一次状态的转移，至于这里的内部实现，我们先不进行了解，只需要知道的是，这里的方法不存在额外的状态转移以及状态注册，只是单纯的处理逻辑，当然，我们并不关心这里面的关于完成这个处理逻辑所必须的状态转移。</p>
<p>​	接下来注意到一个特别注意的一点，这里的start_accept函数的作用。我们前面已经说过，对应的状态转移每注册一次才能触发一次，这里的作用就是如此，在每次结束完对应的处理逻辑之后，在最后再次进行对应的状态转移逻辑的注册。以此来实现对应的逻辑循环调度。而这种状态转移的思想，就是对应的整个服务器逻辑的基础。</p>
<p>​	简单的自己去模拟一下对应的程序执行流的转移吧，这能够让你很好的理解我到底在说什么。</p>
<h2 id="传输时机"><a href="#传输时机" class="headerlink" title="传输时机"></a>传输时机</h2><p>​	接下来我将对在客户端发送过来请求后进行一些分析。</p>
<p>​	我们先来重复一些东西，在服务器端启动之后，其一般存在着一个监听行为，对于程序代码来说，其只是添加了一个对应的<code>async_accept</code>函数已经对应的状态转移式。在接下来由程序员编写的代码的执行其实就被托管到了io_context上。我们来分析一下再客户端发送请求并且服务器端收到后的行为。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">getSocket</span>(), std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session,</span><br><span class="line">std::placeholders::_1));</span><br></pre></td></tr></table></figure>

<p>​	当服务器端成功识别到对应的客户端请求时，其会触发对应的状态转移中的下一位，在这里即是对应的处理函数。但是，只要你了解一点网络基础，你就应该知道这里的不会直接使用对应的监听套接字进行处理，而是创建一个新的连接套接字进行处理。这里也脱离不开OS中的底层逻辑。所以你可以大致推测一下这里的执行逻辑。停下来想一下……</p>
<p>​	在这一次的状态转移触发中，其使用了预分配的一个套接字，然后，其为该套接字绑定了一定的行为，或者说，状态转移式。即，当数据包到达时，其会触发对应的handle_accept函数。那么，这里的函数是怎么被触发的呢？</p>
<p>​	想象一下，当你触发一个连接并且成功创建对应的套接字之后，你需要将接受到的数据给套接字进行读取，该套接字才会进行对应的处理。这里也是如此，所以我们这里需要考虑的一点是，该创建的新套接字时如何接受对应的数据的……这一块其实我也不是很理解，但简单来说，这是通过OS的配合来实现的，毕竟当你计算机接受到来自外部的一个数据包之后，其会先位于其TCP的缓冲区之后，接下来才会从缓冲区往特定套接字的缓冲区去进行映射，这里也是如此，由于我本人对于这块还不是很了解，为了避免误人子弟，这里不再深入。</p>
<p>​	在这里只需简单记住一点，在接收到外部发来的数据包之后，会由ASIO来创建对应的新的连接套接字初始化。接着为其绑定一个基础的状态转移式，一般是对应的处理数据方法。需要特别注意的是，如果没有绑定数据处理的方法，那么这里将会导致数据包的舍弃，换句话说，就相当于你客户端连接上来了，但是服务器端没有进行对应的解析处理，就比如你做你的，我做我的情况，这是绝对不允许的，因为这样没有意义的同时还浪费了资源。</p>
<p>​	接下来，我们来简单看一下在连接建立之后之后的数据处理。一般来说，服务器与客户端之间的回话并不会简单的结束，其可能会持续一段时间。那么在接下来的处理过程中，关于数据包的转发会是一个什么情况呢？就我目前粗浅的理解来说，此时会由OS来进行俩段连接的确保，毕竟对于一个连接，实际上是由一个唯一的四元组来进行维持。当网卡接受到对应的数据之后，其会进行对应的解析，找到对应的元组另一端来进行对应的数据的转发。也就是说，对于建立连接后的数据转发，其是一个独立的操作。</p>
<p>​	我们最后再来考虑一点，就是对于来自客户端的数据的处理。首先，我们已经明白一件事，在目前的框架中，所有的执行逻辑其实是一个状态转移的过程。在一次状态转移的过程中，其会再次添加一次对应的状态转移来进行一种类似于轮询的实现。那么，问题来了，假设我们现在客户端存在一个处理逻辑，其存在着一个会删除当前客户端会话的行为。而当前由于客户端的一些误操作等，此时在接受到对应的数据包之后进入了对应的删除回话逻辑，而且在删除回话之前其又添加了一次对应的状态转移逻辑。但是在此时，由客户端一方结束了进程，此时由于底层设计，服务器端会接受到一个来自于客户端的fin包，此时又触发了对应的状态转移逻辑。如果此时原先的哪个逻辑已经执行完了对应回话的删除，但是(你应该简单的了解一些程序的执行流)，此时的fin包处理又执行到了对应的回话销毁程序。但是由于本会话已经被销毁，此时程序想要再次销毁的话，此时是有可能发生的。那么其会导致一种双重析构的严重错误，甚至于导致服务器崩溃。那么，我们该如何来避免这种情况呢。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>粘包</title>
    <url>/2025/04/06/%E7%BD%91%E7%BB%9C/stickyBag/</url>
    <content><![CDATA[<h1 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h1><blockquote>
<p>​	在本节中，我将会针对于服务器粘包已经对应的处理进行一次解析，这根本上是我针对于粘包该现象进行的自我的分析，如有错误，请告诉我，谢谢。</p>
</blockquote>
<p>​	针对于粘包该现象，其本质就是由于在客户端和服务器端的数据调度不一致导致的，对于客户端来说，由于TCP内部的对于数据包的特殊处理，其内部需要发送出去的数据包是可能会先被积压到一起，等到积攒到一定程序时才进行发送的。对应的TCP发送并不会保证数据包单独的发送。对于底层来说，无论你是要发送什么，在其看来都是一段字节流，所谓的发送，就是将积攒的字节流进行一次整体的发送。而由于该段字节流在实际上可能蕴含了多个子数据包，所以如果服务器端不对其进行对应的解析，其会导致收到的数据失去了其的对应意义。我们这里就是需要处理这一种现象。具体关于粘包出现的解析，可以自己寻找材料了解。</p>
<p>​	</p>
<h2 id="粘包原因"><a href="#粘包原因" class="headerlink" title="粘包原因"></a>粘包原因</h2><p>​	对于粘包，我们需要看到其出现的本质是什么，其本质就是服务器端对于来自客户端的数据包的内部组成没有一种敏感度，或者说，对于客户端发送过来的数据包总是默认识别为一个大数据包，且会从头开始解析到尾。那么这里我们可以猜测一种解决方案，就是在我们的双端通信中去添加一种协议，规定由用户端发送的数据包上需要添加上对应的其发送的数据包的数据信息长度。对于服务器端来说，其在接收解析对应的数据包时其会先对其进行一次解析。其先解析出对应的数据包长度信息，然后根据该信息去进行对应的数据读取以及处理。而这里的这种思想，其实就是对应的TLV青春版，有兴趣可以去了解下。</p>
<p>​	简单来说，我们在接下来会规定一种协议，在每个数据包的起始位置，都附上在该次发送的数据包的长度。因此，我们需要来重新设计一下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MsgNode</span>(<span class="type">char</span> * msg, <span class="type">short</span> max_len):_total_len(max_len + HEAD_LENGTH),_cur_len(<span class="number">0</span>)&#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_total_len<span class="number">+1</span>]();</span><br><span class="line">        <span class="built_in">memcpy</span>(_data, &amp;max_len, HEAD_LENGTH);</span><br><span class="line">        <span class="built_in">memcpy</span>(_data+ HEAD_LENGTH, msg, max_len);</span><br><span class="line">        _data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MsgNode</span>(<span class="type">short</span> max_len):_total_len(max_len),_cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_total_len <span class="number">+1</span>]();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] _data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, _total_len);</span><br><span class="line">        _cur_len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">short</span> _cur_len;</span><br><span class="line">    <span class="type">short</span> _total_len;</span><br><span class="line">    <span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	如上，这里不会进行分析，我们直接来进入我们对应的服务器端在接收到一段来自底层的数据包是需要进行的处理逻辑吧。</p>
<p>​	首先对于服务器的结构，我们需要对其接受对应的数据包的逻辑进行一些优化。首先可以先来添加几个独立的结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//收到的消息结构</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;</span><br><span class="line"><span class="type">bool</span> _b_head_parse;</span><br><span class="line"><span class="comment">//收到的头部结构</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br></pre></td></tr></table></figure>

<p>​	在上述代码中，创建了一个智能指针管理对应的接受头部的节点，另一个智能指针管理对应的信息的节点，还有一个用来标识当前是否已经解析完对应的头部信息。同时需要一个对于客户端和服务器端双端都进行约束的条件，这里设置了对应的数据包的长度和数据头的长度，单位长度为1字节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH  1024*2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_LENGTH 2</span></span><br></pre></td></tr></table></figure>

<p>​	接下来是一段大长段代码，一点点进行分析吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span></span><br></pre></td></tr></table></figure>

<p>​	首先我们需要知道该函数的调用时机，对于该函数来说，我们在外部注册其为在ASIO框架接受到外部的数据包并进行读取时的回调函数，请注意，我们这里使用的外部注册函数是<code>async_read_some</code>函数，即在每次调用到对应的读取函数后都会进行一次回调函数，这里正是对应的回调逻辑。</p>
<p>​	再明确一下这里的参数意义。第一个<code>const boost::system::error_code&amp; error</code>代表由框架自行处理时会返回的错误码，无需太过在意，主要是第二个参数<code>size_t  bytes_transferred</code>，这个参数是在本次读取中框架在缓冲区中读取到的数据的长度，第三个参数不必在意，是为了解决我们前面的生命周期的问题的。</p>
<p>​	首先来进入到我们这里面的逻辑，首先就是一个简单的错误检测，略过。接下来是一个循环判断，由其来进行对应的当前剩余未处理的字节长的表示判断。这里为什么会有这个我们之后再说。先进入我们的处理逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!_b_head_parse) &#123;</span><br><span class="line">	//收到的数据不足头部大小</span><br><span class="line">	if (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH) &#123;</span><br><span class="line">		memcpy(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data+ copy_len, bytes_transferred);</span><br><span class="line">		_recv_head_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">		::memset(_data, 0, MAX_LENGTH);</span><br><span class="line">		_socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), </span><br><span class="line">			std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	//收到的数据比头部多</span><br><span class="line">	//头部剩余未复制的长度</span><br><span class="line">	int head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;</span><br><span class="line">	memcpy(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data+copy_len, head_remain);</span><br><span class="line">	//更新已处理的data长度和剩余未处理的长度</span><br><span class="line">	copy_len += head_remain;</span><br><span class="line">	bytes_transferred -= head_remain;</span><br><span class="line">	//获取头部数据</span><br><span class="line">	short data_len = 0;</span><br><span class="line">	memcpy(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);</span><br><span class="line">	cout &lt;&lt; &quot;data_len is &quot; &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line">	//头部长度非法</span><br><span class="line">	if (data_len &gt; MAX_LENGTH) &#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;invalid data length is &quot; &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line">		_server-&gt;ClearSession(_uuid);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	_recv_msg_node = make_shared&lt;MsgNode&gt;(data_len);</span><br><span class="line"></span><br><span class="line">	//消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span><br><span class="line">	if (bytes_transferred &lt; data_len) &#123;</span><br><span class="line">		memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">		_recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">		::memset(_data, 0, MAX_LENGTH);</span><br><span class="line">		_socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), </span><br><span class="line">			std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">		//头部处理完成</span><br><span class="line">		_b_head_parse = true;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);</span><br><span class="line">	_recv_msg_node-&gt;_cur_len += data_len;</span><br><span class="line">	copy_len += data_len;</span><br><span class="line">	bytes_transferred -= data_len;</span><br><span class="line">	_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = &#x27;\0&#x27;;</span><br><span class="line">	cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span><br><span class="line">	//此处可以调用Send发送测试</span><br><span class="line">	Send(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line">	//继续轮询剩余未处理数据</span><br><span class="line">	_b_head_parse = false;</span><br><span class="line">	_recv_head_node-&gt;Clear();</span><br><span class="line">	if (bytes_transferred &lt;= 0) &#123;</span><br><span class="line">		::memset(_data, 0, MAX_LENGTH);</span><br><span class="line">		_socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), </span><br><span class="line">			std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该段函数是我在对应的头数据包未完成对应的头部解析时会进行的逻辑处理，而这个是通过我们前面的头部处理标识量进行控制的。在进入该处理块之后。我们需要做的就是去读取数据包中的数据去进行更多的我们头部数据的读取构建。首先，我们需要去判断当前的本次读取中的数据包中是否能够支持我们本次的头部数据包的构建以此来进行进一步的数据包的分流。</p>
<p>​	这里只需要一个简单的判断，即判断当前头部数据包中的数据长度以及该次读取中的数据长度总和是否大于规定的头部数据包的长度，这里即通过<code>if (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH)</code>来进行控制的。当程序满足当前条件时，意味着当前收到的数据以及已有的数据头不足以构建我们的头部信息，此时我们需要做什么呢？停下来想一想……首先，即使当前数据包不够信息，我们也不能够丢弃，我们需要把当前读取到的所有剩余数据拷贝到对应的头部数据结构中。需要注意的是，在这里我们添加了对应的copy_len偏移，在此时我们看不出其有什么作用，接下来我们会看到的。</p>
<p>​	在进行对应的数据往头部数据包中的拷贝之后，我们需要进行对应的头部数据结构体的一些信息的更新，在这里即是对应的结构的头部信息的已有长度的更新。接下来想一想处理逻辑应该是什么。既然我们当前的数据包以及被读取处理完毕，那么本次读取就应该作废了，我们接下来应该做的是关闭这次读取并且再次开启一次读取事件的注册(需要注意的是，虽然在这里没有给出，但是在对应的读取时间绑定的回调函数中，还是我们现在的这个HandleRead执行流)。有了前面的基础，你应该也能理解这里的操作会出现怎么样的行为。</p>
<p>​	简单模拟一下，在这种情况下，在程序成功执行完本次读取的解析以及对应的头部结构体的数据更新之后，该程序会重新注册一个写函数以及对应的回调函数，接着，再次触发写时间，由框架调度再次进入这个HandleRead的执行流当中。此时由于我们前面没有更新对应的头部处理标志，所以这里还是会进入对应的处理逻辑中。</p>
<p>​	但是在这一次中，我们去假设，<code>if (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH)</code>在本次的逻辑处理中不再满足，换句话说，在本次中，读取的字节长度至少能够满足我们接下来的头部信息的构建，也就是所谓的<code>&gt;=HEAD_LENGTH</code>。那么我们先来猜测一下之类的处理逻辑，显然是应该先把我们的头部信息给构建完毕，然后去处理我们接下来可能存在的未处理的数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;</span><br><span class="line"><span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data+copy_len, head_remain);</span><br><span class="line"><span class="comment">//更新已处理的data长度和剩余未处理的长度</span></span><br><span class="line">copy_len += head_remain;</span><br><span class="line">bytes_transferred -= head_remain;</span><br><span class="line"><span class="comment">//获取头部数据</span></span><br><span class="line"><span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line"><span class="comment">//头部长度非法</span></span><br><span class="line"><span class="keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line">                _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">_recv_msg_node = <span class="built_in">make_shared</span>&lt;MsgNode&gt;(data_len);</span><br></pre></td></tr></table></figure>

<p>​	首先，我们先去判断在当前的情况下对应的头部构建的所需字节，这个可以通过简单的约定头部长度减去对应的已有信息长度去进行处理。接下就是一个简单的偏移地址复制和部分信息的更新。这里你可能会疑惑一点，既然这里已经完成了对应的头部信息的构建，为什么这里不直接对于标志进行更新？别急，再等一会。</p>
<p>​	接下来就到了我们的下一个处理环节，在我们构建完对应的头部节点之后，我们需要对其中蕴含的信息进行处理，这里的由于我们基础的设计就只是在头部中附上对应的数据块的大小，所以我们这里只需要将对应的数据进行读取然后进行解析即可。我们来看一下这里的处理方式。我们这里考虑直接将其拷贝到一个地址中，该地址所代表的是一个short变量，由于我们的头部长度只有2字节，所以我们的short长度是完全可以容纳的。在这里拷贝之后，我们需要了解的一点只是这里的数据读取其实就是对应的数据解析形式的不同，当我们完成拷贝之后，我们就已经完成了一个变量的构造，可以对其进行一个正常的使用。</p>
<p>​	接下来我们对其进行了一个简单的错误检测，判断当前的数据包长度是否超出了我们约定的长度，如果非法，直接删除回话。否则我们就可以继续进行我们接下来的网络数据包的处理了。</p>
<p>​	</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_recv_msg_node = <span class="built_in">make_shared</span>&lt;MsgNode&gt;(data_len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span></span><br><span class="line"><span class="keyword">if</span> (bytes_transferred &lt; data_len) &#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">	_recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">	<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">	_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), </span><br><span class="line">	std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">	<span class="comment">//头部处理完成</span></span><br><span class="line">	_b_head_parse = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在成功确定我们需要对数据包中的剩余数据进行处理之后，我们首先要创建一个根据我们前面的头部长度中储存的大小来储存的消息结构，即这里的<code>_recv_msg_node = make_shared&lt;MsgNode&gt;(data_len);</code>再接下来的处理逻辑其实就跟我们一开始的整个读取逻辑的进入没有什么区别了，这里就简单自己了解一下即可。不再进行说明。</p>
<p>​	接下来跟头部处理一样，如果此时剩余的数据能够完全构建我们的数据包结构，那么我们还需要对于剩余的数据进行一次再次的HandleRead对调处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);</span><br><span class="line">_recv_msg_node-&gt;_cur_len += data_len;</span><br><span class="line">copy_len += data_len;</span><br><span class="line">bytes_transferred -= data_len;</span><br><span class="line">_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span><br><span class="line"><span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line"><span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line"><span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">_b_head_parse = <span class="literal">false</span>;</span><br><span class="line">_recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line"><span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">	::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">	_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), </span><br><span class="line">	std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>​	在这里有一点你可能在初次看到时会感到疑惑的点，就是这里的拷贝<code>memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);</code>为什么会按照固定的长度data_len进行拷贝。停下来想一想……</p>
<p>​	原因在于这个执行流所在的外部一层执行流中，回想一下此时处在哪里，是处在对应的if判断成立，也就是说当前已经处理了对应的头部文件并且执行到这里的<code>bytes_transferred</code>已经被更新为了当前剩余的未读取数据长度了。此时还能进入这里的执行流意味着剩余的长度一定能够支持我们的整段的数据段的读取，而且由于我们这里是位于头部信息为完成构造的大前提下的，这个前提的隐藏信息就是我们当前的数据段是一个为空的情况。这也是为什么我们这里的拷贝直接使用这种构造的原因。当然，这里保留了对应的</p>
<p> <code>+ _recv_msg_node-&gt;_cur_len</code>操作，从我个人观点来看其是可以删去的，但是为了一种可读性可以进行保留，至于删除该操作是否会导致一些问题，我在之后再确认一下。</p>
<p>​	在这里，我们进行了对应的内存信息的数据块拷贝之后，我们需要进行一些额外的处理，还记得现在应该是一个什么状态吗。此时对应的数据包已经被读取了对应的头部信息。同时，其剩余的信息能够支撑起对应的数据包的构建，在这里就同时支撑起了对应的数据包的构建。那么在此时我们来考虑一下当前剩余的缓存区的数据的状态。其只会存在俩种情况，剩余未读取数据为空，或者在构建完我们此次的数据块之后还留存着一些数据未进行处理。但是本质上，这俩种情况都应该导致一种状态的转移，就是此时应该转移成一个头数据块和内容数据块均未构建的情况，即我们在一开始进入该HandleRead函数的情况。我们这里的节点清理以及对应的回调函数绑定可以提现该行为。</p>
<p>​	接下来注意另一种情况，即这里会进入continue执行流的情况。当进入该执行流时，就意味着当前剩余的缓存区数据还不为空，换句话说，就是在处理完一个完整的数据头的构建以及对应的数据包的处理之后，还存在未处理的数据，此时在逻辑上该段数据是一个新数据包的数据头信息。那么此时的状态就像什么呢，没错，就像我们在一个数据包刚进行对应的HandleRead处理一致，所以我们这里直接使用了对应的<code>continue</code>使得程序直接跳回到了程序入口处的处理逻辑省去了退出去重新注册以及对应的调度开销。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>线程模型</title>
    <url>/2025/04/10/%E7%BD%91%E7%BB%9C/multiThread/</url>
    <content><![CDATA[<h1 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h1><p>​	简单接触一下对应与ASIO的俩种多线程模型。或者说，其实是俩种多线程设计上的思路。</p>
<span id="more"></span>

<h2 id="IOServicePool"><a href="#IOServicePool" class="headerlink" title="IOServicePool"></a>IOServicePool</h2><p><img src="/2025/04/10/%E7%BD%91%E7%BB%9C/multiThread/IOServicePool.png" alt="IOServicePool"></p>
<p>​	首先看到第一种模型。简单的说明一下这里的这种设计思路。对于一个服务器进程，我们将创建对应于机器的CPU核数的io_context数，每一个io_context都会被放在一个线程这种。每一个线程都独立的跑在一个CPU上，这样能够减少多个上下文之间的资源竞争。</p>
<p>​	对于每一个io_context，由于ASIO底层的设计，所以每个线程会存在一个任务调度队列，由于在高并发的情况下，对应的多个套接字可能会被绑定到一个上下文之中。此时就意味着将有一个上下文来进行这些线程的管理，对于运行在这个上下文中的所有套接字，其都是使用的本上下文中的事件队列。也就是说，对于所有的连接套接字中产生的请求，其都会注册到一个事件队列中。而在我们的该种多线程模式中，对应的事件处理线程是运行在同一个线程上的，此时会出现一个什么情况呢。</p>
<p>​	其实就类似于一种多生产者单消费者的模型。在这里，我们的每一个连接产生的套接字就是一个生成者，其生产的就是事件处理队列中需要处理的事件，我们的事件处理逻辑就是我们的消费者，负责进行我们的事件处理。那么这是你应该考虑到这种模型下的性能瓶颈，就是我们一个线程的运行速度是取决于我们的事件处理逻辑的，在事件处理的逻辑当中，我们可以将其视为一种耗时的操作，因为其是可能涉及到I&#x2F;O操作的。而这时对应的接受请求则会不断的堆积。如果我们的事件处理逻辑十分的负责，那么我们一个线程对于全部的连接套接字的回复性能将会出现严重的性能劣化。		</p>
<p>​	因此你应该也能想到这种多线程架构下的应用场景，其更适合对于那种事件处理逻辑相对简单的服务器架构，每个处理逻辑将不会导致过长的阻塞，来自客户端的请求可以由OS内核进行堆积。</p>
<p>​	模拟一下服务器的动作(抽离出一个线程)。假设现在该线程处于我们的任务逻辑中，而且每次的任务处理服务器都会一次性的清空当前的任务队列才进行退出。那么，在处理完我们当前的任务处理逻辑之后，对应的内核缓冲区将会堆积一些来自客户端的包，在处理完在之后我们服务器又可以转向对应的包的解析，由于我们假设对应的逻辑不会过于的复杂。所以这里的处理将会相对高效，服务器又可以在解析完这些包之后转向对应的事件处理逻辑。</p>
<p>​	接下来我们考虑一下在一种情况下的劣化。我们假设服务器存在一些处理相当耗时的逻辑，那么其在处理对应的事件时，整个线程由于是同步将会被阻塞，而如果这种事件过于的频繁，那么其会导致服务器的一个线程会浪费大量的事件在处理一些耗时的任务之上，其他的任务可能会出现饥饿的情况。</p>
<p>因此，这种模型<strong>非常适合</strong>下面场景：</p>
<ul>
<li>请求处理逻辑较轻；</li>
<li>不涉及或尽量少涉及阻塞操作；</li>
<li>使用内核堆积数据能力（比如 TCP 接收缓冲区）；</li>
</ul>
<p>而对于复杂逻辑场景，则更推荐引入：</p>
<ul>
<li><strong>线程池执行复杂逻辑</strong>；</li>
<li>或采用 <strong>主线程处理 I&#x2F;O，子线程执行任务处理逻辑</strong> 的模型(如下)；</li>
<li>或者采用 Boost.Asio 支持的 <strong>协程&#x2F;协作式多任务（如 <code>awaitable</code>）模型</strong>。</li>
</ul>
<p>接下来看到第二种线程模型的图，自行进行对应的性能分析和瓶颈分析吧</p>
<p><img src="/2025/04/10/%E7%BD%91%E7%BB%9C/multiThread/IOTreadPool.png" alt="IOTreadPool"></p>
<p>​	简单来说，这里是<strong>单个iocontext和多个线程之间的配合</strong>。</p>
<p>​	对于这种模型，我们的服务器的主逻辑运行在同一个线程中，该线程管理着所有的连接，其会处理所有的来自客户端的请求并压入到对应的任务队列中。在任务队列的处理中，会存在着多个处理线程从该队列中取出数据进行处理。那么你自然也能想到这种模型的应用场景，自然是在接受较轻松，任务处理较繁忙的场景上其会具有更好的性能。</p>
<p>本文中的一些逻辑比较混乱，不必太过在意，给出下面该表格请自行理解。</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>每线程一个 <code>io_context</code></th>
<th align="left">单个 <code>io_context</code> 多线程</th>
</tr>
</thead>
<tbody><tr>
<td><strong>线程与上下文</strong></td>
<td>每个线程绑定一个独立的 <code>io_context</code></td>
<td align="left">所有线程共享一个 <code>io_context</code></td>
</tr>
<tr>
<td><strong>线程间竞争</strong></td>
<td>无竞争，每个 <code>io_context</code> 独立运行</td>
<td align="left">存在竞争，线程争抢任务队列</td>
</tr>
<tr>
<td><strong>负载分配</strong></td>
<td>手动分配连接至不同 <code>io_context</code></td>
<td align="left">所有连接都挂在同一个上下文</td>
</tr>
<tr>
<td><strong>任务调度</strong></td>
<td>每个线程单独调度自己上下文的任务</td>
<td align="left">所有线程协作调度公共任务</td>
</tr>
<tr>
<td><strong>事件处理逻辑复杂度</strong></td>
<td>要求轻量、快速完成</td>
<td align="left">可容忍复杂、耗时操作</td>
</tr>
<tr>
<td><strong>饥饿问题</strong></td>
<td>处理线程阻塞可能导致其上下文内连接饥饿</td>
<td align="left">多线程可平衡负载，不易饥饿</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>扩展线程需添加额外 <code>io_context</code> 与调度逻辑</td>
<td align="left">扩展线程仅需绑定到同一个 <code>io_context</code></td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>高：需管理多个上下文和连接调度策略</td>
<td align="left">低：逻辑清晰，易于维护</td>
</tr>
<tr>
<td><strong>线程安全要求</strong></td>
<td>相对较低（上下文隔离）</td>
<td align="left">高（共享资源需加锁）</td>
</tr>
<tr>
<td><strong>适合场景</strong></td>
<td>I&#x2F;O密集，处理逻辑简单（如代理服务）</td>
<td align="left">业务逻辑复杂、重计算型服务（如 API 处理、数据库交互）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Tiny-Web</title>
    <url>/2025/04/01/%E7%BD%91%E7%BB%9C/tiny/</url>
    <content><![CDATA[<h1 id="TINY-WEB"><a href="#TINY-WEB" class="headerlink" title="TINY WEB"></a>TINY WEB</h1><p>​	基于CSAPP的课本教程，我实现了一个简单的服务器demo。该demo仅仅只有250行，但是存在着一个服务器所必须的简单的提供服务的功能，在这里对其进行一个简单的复盘。</p>
<span id="more"></span>

<p><img src="/2025/04/01/%E7%BD%91%E7%BB%9C/tiny/412ce31628442ff184998478c3c57008.jpg" alt="服务器"></p>
<p><img src="/2025/04/01/%E7%BD%91%E7%BB%9C/tiny/4b9f12bd738e8068b37267643c37a831.jpg" alt="单连接测试"></p>
<p><img src="/2025/04/01/%E7%BD%91%E7%BB%9C/tiny/8dc03b8039515d8d7a5a2d66db5d67d1.jpg" alt="多连接测试"></p>
<p>接下来一步步对这段代码进行简单的分析，重温下我的tiny web开发过程</p>
<h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd,connfd;</span><br><span class="line">    <span class="type">char</span> hostName[MAXLINE],port[MAXLINE];       <span class="comment">//the storge of client information</span></span><br><span class="line">    <span class="type">socklen_t</span> clientlen;                        <span class="comment">//the length of client socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span>         <span class="comment">//the address of client</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="number">0</span>]);       <span class="comment">//did`t used port num</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd=open_listenfd(argv[<span class="number">1</span>]);            <span class="comment">//used port to create listen fd</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);</span><br><span class="line">        Getnameinfo((SA*)&amp;clientaddr,clientlen,hostName,MAXLINE,port,MAXLINE,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>,hostName,port);</span><br><span class="line">        <span class="comment">//doit(connfd);</span></span><br><span class="line">        optDoit(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	对于目前的服务器，启动的实现是一个单线程迭代阻塞服务器，每次只能处理一个来自服务器端的连接，在启动连接后，之后所有的连接都会被阻塞。</p>
<p>​	回顾一个服务器简单的开发流程。</p>
<ul>
<li>创建服务器本地的套接字节点，实际上是一个监听节点，该节点是为了提供外部客户端的连接处理的。</li>
<li>为了创建一个监听节点，我们需要先创建一个套接字节点，然后再将其转换为一个监听节点，也就是说，监听节点本质上也还是一个套接字节点，只是通过系统调用为其赋予了不同的属性使其成为了一个专门用于监听客户端请求的节点。</li>
<li>在监听节点被创建完之后，本地的监听节点将会阻塞当前的服务器线程，知道收到来自客户端的请求，此时，其会在服务器这个接受处理的线程中去请求和创建一个新的文件描述符并返回，这个描述符会被关联到对应的对应的客户端连接中</li>
<li>此时，本地的对应的监听文件套接字创建的子文件就会被与某个网络上的文件关联起来，这一块我还不是很了解这种不可见的信息传输，所以，这里可以假设对应的文件会储存每一次来自用户端的请求，我们只需要对这个文件进行处理即可。</li>
</ul>
<p>​	对于我们上面给出的main函数代码，其实可以看到一个对应的开发流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> listenfd,connfd;</span><br><span class="line">   <span class="type">char</span> hostName[MAXLINE],port[MAXLINE];       <span class="comment">//the storge of client information</span></span><br><span class="line">   <span class="type">socklen_t</span> clientlen;                        <span class="comment">//the length of client socket</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span>         <span class="comment">//the address of client</span></span><br></pre></td></tr></table></figure>

<p>​	这一段都是对应的需求内存设计。可以看到，这里的设计其实相当简单，一个服务器上只有一个connfd，所以你应该也可以推断对应的，服务器每次只能创建出一个连接文件来进行客户端的处理，一但其他客户端同时请求，其会被阻塞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="number">0</span>]);       <span class="comment">//did`t used port num</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	这一段是命令行参数检测这一块，对于该服务器，我们要求在启动时指定对应的本机上要使用的端口号。毕竟对于服务器来说，其使用的就是本地的域名，套接字这块的地址直接使用本地地址，只需要指定对应的端口号即可。</p>
<p>​	接下来看到这一行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">listenfd=open_listenfd(argv[<span class="number">1</span>]);            <span class="comment">//used port to create listen fd</span></span><br></pre></td></tr></table></figure>

<p>​	这一行中去创建对应的监听操作符，<code>open_listenfd</code>是一个封装好的函数，直接使用本地地址和传进的端口号来创建一个监听套接字，我们来看一下它的源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* $begin open_listenfd */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open_listenfd</span><span class="params">(<span class="type">char</span> *port)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> listenfd, rc, optval=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get a list of potential server addresses */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;             <span class="comment">/* Accept connections */</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="comment">/* ... on any IP address */</span></span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;            <span class="comment">/* ... using port number */</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo failed (port %s): %s\n&quot;</span>, port, gai_strerror(rc));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Walk the list for one that we can bind to */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">/* Create a socket descriptor */</span></span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">/* Socket failed, try the next */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Eliminates &quot;Address already in use&quot; error from bind */</span></span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,    <span class="comment">//line:netp:csapp:setsockopt</span></span><br><span class="line">                   (<span class="type">const</span> <span class="type">void</span> *)&amp;optval , <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Bind the descriptor to the address */</span></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* Success */</span></span><br><span class="line">        <span class="keyword">if</span> (close(listenfd) &lt; <span class="number">0</span>) &#123; <span class="comment">/* Bind failed, try the next */</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;open_listenfd close failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up */</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* No address worked */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make it a listening socket ready to accept connection requests */</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end open_listenfd */</span></span><br></pre></td></tr></table></figure>

<p>​	这个源码的功能其实很简单，就是使用默认的配置去调用UNIX环境下的一些系统调用来生成一个监听套接字</p>
<p>​	</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line"><span class="type">int</span> listenfd, rc, optval=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>​	在这段声明中，addrinfo结构的几个变量都是会被提供给getaddrinfo系统调用的，这里不知道的还需要回去补一下CSAPP的网络编程基础。其中，由于hints是对于最终结果的属性约束，为了避免机器上莫名其妙的内存残留影响，在每次使用前最好对其进行一次刷新</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hints.ai_socktype = SOCK_STREAM;             <span class="comment">/* Accept connections */</span></span><br><span class="line">hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="comment">/* ... on any IP address */</span></span><br><span class="line">hints.ai_flags |= AI_NUMERICSERV;            <span class="comment">/* ... using port number */</span></span><br></pre></td></tr></table></figure>

<p>​	这一段就是对应的我们对于getaddrinfo解析地址的参数，在这其中</p>
<ul>
<li><code>SOCK_STREAM</code>：指定 <strong>TCP</strong> 连接。</li>
<li><code>AI_PASSIVE</code>：用于监听套接字，指示 <code>getaddrinfo</code> 返回的 IP 地址应可用于 <code>bind</code>。</li>
<li><code>AI_ADDRCONFIG</code>：启用地址配置，仅返回当前系统有可用 IP 地址的协议族（IPv4&#x2F;IPv6）。例如，如果机器只分配了 IPv4 地址，则不会返回 IPv6 地址。</li>
<li><code>AI_NUMERICSERV</code>：端口号直接使用数字，而不是服务名。</li>
</ul>
<p>​	这些字段的内容其实很多，没必要去记，在需要的时候再去查一下即可，只需要了解，通过设置hints结构能够对于我们最终生成的addrinfo进行一次属性上的控制即可。</p>
<p>​	在设置完基本的本地服务器要求的addrinfo属性后，我们就可以进行对应的getaddrinfo系统调用查询了。对于这个系统调用，只简单说明一下它的功能。其的功能是：通过使用该系统调用参数，去生成一个结构体addrinfo链表，在这个链表中，储存了一些节点的重要信息。<code>getaddrinfo</code> 的前两个参数分别是域名（或者 IP 地址）和端口号。它们都是必填项，但可以传 <code>NULL</code> 作为默认值。  如果 <code>hostname</code> 传 <code>NULL</code>，则表示使用本地地址。 如果 <code>servname</code> 传 <code>NULL</code>，则表示调用者需要手动绑定端口，通常不推荐这样做，因为系统自动分配的端口号需要额外查询才能得知。</p>
<p>​	除此之外，该函数还返回一个状态码，当且仅当函数正常运行时会返回0，以此来进行了一次简单的错误处理。接下来是这里的重头戏，当该函数正常处理需求时，其会使用前三个参数去进行查询和构建对应的addrinfo链表，这个链表的储存位置是我们第四个参数的位置。这种参数位置设置是不是很熟悉。</p>
<p>​	<code>getaddrinfo</code> 生成的是一个 <code>addrinfo</code> 结构体的链表，每个节点都包含了一个可用的 IP 地址及其相关的配置信息。在这里需要注意的，对于传进来的域名(第一个参数)，如果不是本地地址，那么其会去先本地的DNS缓存去查找，再然后，去连接到外部的DNS服务器去进行对应的ip的查找。总的来说，这里的函数会将在当前时刻可以查找到的对应的域名的所有的ip地址都进行储存，每个ip地址都对应着一个结构体，一个结构体中又包含着一些配置信息，目前了解这些即可。</p>
<p>​	</p>
<p>​	总之，目前在了解完这个函数之后，我们知道了上面调用getaddrinfo方法是为了去生成一些与传进去的域名和端口号相关联的信息方便后面的套接字创建。接下来就看懂我们的套接字创建吧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Walk the list for one that we can bind to */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">/* Create a socket descriptor */</span></span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">/* Socket failed, try the next */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Eliminates &quot;Address already in use&quot; error from bind */</span></span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,    <span class="comment">//line:netp:csapp:setsockopt</span></span><br><span class="line">                   (<span class="type">const</span> <span class="type">void</span> *)&amp;optval , <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Bind the descriptor to the address */</span></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* Success */</span></span><br><span class="line">        <span class="keyword">if</span> (close(listenfd) &lt; <span class="number">0</span>) &#123; <span class="comment">/* Bind failed, try the next */</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;open_listenfd close failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	可以看到，这该循环中，我们去遍历了生成的addrinfo链表，因为这里可能会生成多个ip地址，但是不保证哪个可以被我们本地连接，所以这里需要循环测试直至成功创建出对于的套接字</p>
<p>​	接下来主要看一个<code>socket</code>函数，在该函数中，我们看到了几个熟悉的字段，前面设置过的<code>ai_family</code>字段，<code>ai_socktype</code>字段，<code>ai_socktype</code>字段，再来对其对应关系其重复一下</p>
<ul>
<li><p><code>socket(int domain, int type, int protocol)</code> 用于创建套接字：</p>
</li>
<li><p><code>p-&gt;ai_family</code>：地址族（<code>AF_INET</code> 表示 IPv4，<code>AF_INET6</code> 表示 IPv6）。</p>
</li>
<li><p><code>p-&gt;ai_socktype</code>：套接字类型（<code>SOCK_STREAM</code> 表示 TCP，<code>SOCK_DGRAM</code> 表示 UDP）。</p>
</li>
<li><p><code>p-&gt;ai_protocol</code>：通常为 <code>0</code>，表示使用默认协议（TCP&#x2F;UDP）。</p>
</li>
</ul>
<p>​	接下来的setsockopt用于设置一些socket的属性，这里可以先不对其进行了解。</p>
<p>​	一般在创建完套接字之后，即可以进行该套接字与端口的绑定了。这里再对套接字进行一下解释，所谓的套接字，本质上就还是一个文件，可以将其视作在网络中的文件单位，我们现在所谓的穿件套接字，只是创建出一个稍微普通点的文件而已，如果不对其进行使用，那么其没有什么实际的意义。而我们这里，就要将其与某一个本地的端口进行绑定。这样才能够使得该套接字工作起来。而这种赋予<code>工作</code></p>
<p>的方法，就是使用bind系统调用。</p>
<p>​	<code>bind</code>顾名思义，就是建立起连接，而这里的俩段则是套接字与某一个特定的端口，在链接完之后，简单的可以理解为，所有想要传输进这个端口的数据都会被储存到这个套接字中，这里的套接字就类似于一个大麻袋，将所有的来自客户端的信息都进行一个接受，当然，其也只负责接受。而对于<code>bind</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>​	其中第一个参数就是我们将要绑定的监听套接字，第二个参数是一个sockaddr结构体指针，也就是我们前面得到的addrinfo结构体，在这个函数内其会对其进行自动的解析，无需关系，第三个参数是第二个指针指向的结构体的大小，而这个信息也被储存到了对应的结构体中，所以可以看到，这里是直接传递一个对应与结构体的属性的。</p>
<p>​	最后是一个简单的连接失败处理，你可能会疑惑为什么在这里会进行一个<code>close</code>，但是在仔细看一看，什么时候才会进入到这里的close呢？</p>
<p>​	在这个函数的最后，我们不能忘记对于我们getaddrinfo函数产生的结构体链表进行清理，毕竟只要稍微了解下内存系统就知道这里是一个什么风险。</p>
<p>​	最后的最后，在离开函数前，我们调用了listen方法让监听套接字进行了工作。其实可以这么简单的理解。创建出一个套接字，其实就是一个人想要通过高考考上大学的过程；套接字转换为监听套接字，就是一个大学学习技能特化自己的过程；监听套接字被绑定到对应的端口，就是对应的找工作收offer的过程；最后的listen方法，就是去公司上工的过程。通过这个小例子你应该能够更轻松的了解这个创建过程。</p>
<p>​	</p>
<hr>
<blockquote>
<p>接下来我们跳出这里的方法，回到我们的主函数</p>
</blockquote>
<p>​	在创建完监听操作符之后，我们进入了一个程序死循环，并且可以看到，该程序循环没有一个出口(你在之后可以看到，循环内部的方法不会导致循环退出)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);</span><br><span class="line">        Getnameinfo((SA*)&amp;clientaddr,clientlen,hostName,MAXLINE,port,MAXLINE,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>,hostName,port);</span><br><span class="line">        <span class="comment">//doit(connfd);</span></span><br><span class="line">        optDoit(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	对于这个循环，流程其实很简单，我们前面已经让监听套接字进行工作了，而在这里，我们则是指定对应的监听套接字所需要执行的工作。即不断监听这里服务器的对应端口(前面已绑定)。对于Accep函数，其本身其实是对于accept函数的一个错误处理的包装，包括接下来的结果一大写开头的系统调用函数，其只是一个错误处理包装，由于没什么好讲的，所以这一类的源码不进行分析，请自行阅读。</p>
<p>​	主要来了解一个<code>accept</code>函数，该函数原型如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>​	其接受一个监听套接字，需要注意的是，这个监听套接字必须已经处于监听状态，否则会出现错误，这也是前面给监听套接字调用<code>listen</code>方法的原因，第二个参数是一个结构体指针，指向的是在监听到底的客户端时要储存的位置，第三个则是对应的第二个结构体的内存大小，对于后俩个参数，都可以传进NULL使用系统自动判断的结构体大小。</p>
<p>​	需要注意的是，accept是一个阻塞型的函数，一但进入该函数体，除非存在来自客户端的连接来解除阻塞，否则当前进程会一直阻塞下去。</p>
<p>​	之后的几行代码也很轻松，就是调用我们的getnameinfo函数去解析当前接受到的客户端信息，并在服务端进行一次访问打印而已。</p>
<p>对于 <code>optDoit(connfd); Close(connfd);</code>俩行代码，其中optDoit是对应的服务器对于接受到的信息的解析和回应，这里我们将不会使用optDoit进行分析，而是使用doit进行分析，该optDoit涉及到了对应与CSAPP中关于服务器的作业的一个实现，感兴趣可以自己去实现一个自己的optDoit函数。</p>
<p>​	在处理完对应的逻辑之后，我们服务器端将会将对应的创建出的connfd函数进行一次回送，自此，一个来自客户端的处理结束，服务器一个循环迭代结束，重新进行循环，重新开始我们之前的流程，知道关闭服务器进程之前运行不止…</p>
<p>​	</p>
<hr>
<p>​	这也就是我为什么将该服务器视为一个循环迭代服务器的原因，该服务器每次能且只能处理一个客户端连接。接下来我们就要进入对应的doit方法的处理了。歇一会开始吧。</p>
<blockquote>
<p>在接下来的分析中，我将不会对于源码进行像之前一样复杂的分析，毕竟在源码中我已经加了相当多的注释，快速过一遍，你需要做的是自己去跟着敲一遍，但不只是敲一遍，在敲的过程中需要去熟悉这一门技术和对应的思想。</p>
</blockquote>
<h2 id="doit方法"><a href="#doit方法" class="headerlink" title="doit方法"></a>doit方法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> is_static;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE],method[MAXLINE],uri[MAXLINE],version[MAXLINE];</span><br><span class="line">    <span class="type">char</span> filename[MAXLINE],cgiargs[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*read request line and headers*/</span></span><br><span class="line">    Rio_readinitb(&amp;rio,fd);         <span class="comment">//read informations from client fd</span></span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;rio, buf, MAXLINE))  <span class="comment">//line:netp:doit:readrequest</span></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//read informations from rio to locla buf</span></span><br><span class="line">    <span class="built_in">sscanf</span>(buf , <span class="string">&quot;%s %s %s&quot;</span>,method,uri,version);    <span class="comment">//parse the header of client input</span></span><br><span class="line"></span><br><span class="line">    Rio_writen(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(strcasecmp(method,<span class="string">&quot;GET&quot;</span>))    <span class="comment">//compare two strings ignore case only return 0 when equal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//block non-get request</span></span><br><span class="line">        clienterror(fd,method,<span class="string">&quot;501&quot;</span>,<span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Tiny could not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    read_requesthdrs(&amp;rio);         <span class="comment">//read informations from client fd,ignore the header</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for a parse_uri function</span></span><br><span class="line"><span class="comment">    *   translate a uri and the next two parameter to store the result of parsing</span></span><br><span class="line"><span class="comment">    *   the function return 1 when the request is static</span></span><br><span class="line"><span class="comment">    *   return 0 when the request is dynamic</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    is_static = parse_uri(uri,filename,cgiargs);    <span class="comment">//parse the uri</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//uri referance to a file on server,to detection if it exist</span></span><br><span class="line">    <span class="comment">/* the stat return 0 only exact find the file</span></span><br><span class="line"><span class="comment">     * when success if finding the file, system will write content to second argument</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(stat(filename,&amp;uri)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clienterror(fd,filename,<span class="string">&quot;404&quot;</span>,<span class="string">&quot;Not found&quot;</span>,<span class="string">&quot;Tiny could not find this file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//struct stat sbuf;</span></span><br><span class="line">    <span class="keyword">if</span>(is_static)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//S_ISREG is a Macro ,used to dected whether the file is a regular file</span></span><br><span class="line">        <span class="comment">//st_mode is a field symbol the file type and permissions</span></span><br><span class="line">        <span class="comment">//S_IRUSR&amp;sbuf.st_mode dected whether the server has the permission to visit the file</span></span><br><span class="line">        <span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(sbuf.st_mode &amp; S_IRUSR))</span><br><span class="line">        &#123;</span><br><span class="line">            clienterror(fd,filename,<span class="string">&quot;403&quot;</span>,<span class="string">&quot;Forbidden&quot;</span>,<span class="string">&quot;tiny could not read the file&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        server_static(fd,filename,sbuf.st_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>        <span class="comment">//a dynamic request , want to request a progress</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//S_IXUSR &amp; sbuf.st_mode will used &amp; to detect if the file is valid for this server</span></span><br><span class="line">        <span class="keyword">if</span>(!(S_ISREG(sbuf.st_mode))||!(S_IXUSR &amp; sbuf.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            clienterror(fd,filename,<span class="string">&quot;403&quot;</span>,<span class="string">&quot;Forbidden&quot;</span>,<span class="string">&quot;tiny could not run the CGI program&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        server_dynamic(fd,filename,cgiargs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在该方法中，参数fd指向的是客户端连接上的服务器端fd，对于服务器来说，其可以将其抽象为一个文件，不过这个文件时刻有可能有外部的输入流入(实际上，该输入是通过外部网络来传输的)。</p>
<p>​	在该函数中，可以看到一系列的Rio函数，这些是在csapp.h中包含的函数，这些函数本质上其实就是一些包装的网络安全的读写函数，毕竟你应该知道，在网络中使用一般的printf和scanf函数是不安全的。</p>
<p>​	我们简单来分析下这个函数的功能，具体代码留给你自己去看。</p>
<ul>
<li><p>首先，你需要知道一个服务器接受到的监听文件中储存的信息格式，或者说，你需要知道对应的客户端发送过来的信息格式。在对应的信息文本中，第一行是一个HTTP请求，格式为 <code>method uri version</code>,这正是该段代码中前几行进行解析的原因，在该请求中包含了一些相对重要的信息，具体可以自行查阅资料。</p>
</li>
<li><p>由于当前服务器小demo只支持GET请求，所以你可以看到在代码中存在一些关于读取头非GET的错误处理</p>
</li>
<li><p>在确认由客户端送来的HTTP请求格式正确之后，程序开始解析接下来的<code>uri</code>字段，对于<code>uri</code>字段，你可以看到存在俩种不同执行流的处理，这里又涉及到了服务器端提供的服务，即静态资源和动态资源。当然，这一块还是交给你自己去进行了解</p>
</li>
<li><p>如果你稍微了解所谓的动静态资源，你应该能够读到对应的<code>if (!(S_ISREG(sbuf.st_mode)) || !(sbuf.st_mode &amp; S_IRUSR))</code></p>
<p>判断，这里的权限判断是每个服务器都必须的，毕竟你也不想你的服务器主机被渗透的千疮百孔吧，当然，这里的语句含义，还是留给你去阅读源码，我在其中已经写了一定的解析。</p>
</li>
<li><p>在对应权限判断之后，服务器将会进一步的开始处理对应的请求，对<code>uri</code>进行进一步的解析以及产生进一步的动作</p>
<blockquote>
<p>其实在该函数这里，你应该相对来说会在逻辑上感觉到得心应手。你应该可以明显感觉的是，在该函数中，好像就脱离了所谓的网络结构，对于该函数来说，所谓的运行环境只是一个普通的本机环境，其所需要关心的，其实只是对于所谓的监听文件的内容的解析和处理，其他内容不用其进行处理。这里，正是解耦合的魅力啊。</p>
</blockquote>
</li>
</ul>
<hr>
<p>​	至此，我们完成了对于源码中的函数入口以及对应的简单处理分流函数的了解。对于剩下的代码，这一块将不会进行解释，毕竟存在着更详细的教材 <code>CSAPP</code> 。该小demo是参照该书中的tiny web进行制作的，在这之后的每一个函数，都在书中有着详细的解释，为了不误导各位，我在合理不再对源码进行分析，请各位自行阅读源码并参照CSAPP中的内容进行学习。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>吐槽</title>
    <url>/2025/04/08/%E7%BD%91%E7%BB%9C/%E5%90%90%E6%A7%BD/</url>
    <content><![CDATA[<p>《狂人日记》节选</p>
<p>己亥年冬月，夜色如泼墨，我枯坐在电屏前。这西洋镜里尽是魑魅魍魉，偏生教我等凡人操弄些二进制符咒。忽忆起前日与Socket厮斗的光景，倒要写些疯话给后世瞧。</p>
<p>那ASIO自诩是包治百病的灵丹，说是教程序如飞蓬般自在。可这世道哪有什么逍遥？分明是教人左手画圆右手画方，稍不留神便坠进回调地狱里去。东瀛人发明的物什，终究带着剖腹自尽的狠劲，倒像是给程序员备下的切腹刀。</p>
<p>粘包更是桩奇闻。好端端的字节流，偏生像饿鬼抢食般搅作一团。本想着分个泾渭分明，倒成了麻线团里找针头。那些个分隔符、定长法，活似给乱葬岗立界碑，风一吹便歪斜了去。这网络世界原是个混沌所在，偏要强作清明，岂不可笑？</p>
<p>说到序列化，愈发教人齿冷。活生生的对象，生生教人拆作枯骨，到得彼岸再拼回人形。然则途中若错了一星半点，便成了三头六臂的怪物。这倒像极了人世间的话本，传来传去总失了本来面目，倒要怪那说书人技艺不精。</p>
<p>夜深忽听得IDE里传出桀桀怪笑，原是调试器在嘲弄我。满屏的异常堆栈层层叠叠，竟似乱坟岗的碑文。我辈写代码的，原不过是在赛博乱世里讨生活的匠人，雕些木牛流马供贵人消遣。可叹这二进制洪流中，清醒者少，疯魔者多，倒不如学那孔乙己，只管在咸亨酒店里写茴香豆的”茴”字罢。</p>
<span id="more"></span>

<p>《码农呓语》</p>
<p>壬寅霜序，IDE泛着幽幽青光。那新版的protobuf裹着彩衣，在文档里跳傩戏，说是要引我见什么”现代C++的真章”。可这鬼戏唱到三更天，链接器突然暴起，抛来几串带血的符号——“TcParser::FastUS1”悬在报错堆里晃荡，活似城隍庙檐角挂的人头灯笼。</p>
<p>前日从Github乱坟岗刨来的示例代码，此刻竟化作纸人纸马。CMakeLists.txt里埋的咒诀，原是前朝术士写的鬼画符。Stack Overflow的残碑上说要祭拜ABI神灵，我却把”ldconfig”的香灰撒进了&#x2F;etc的龙王庙。</p>
<p>忽有游魂在终端飘过：”降尔尊位，可保太平”。遂将protobuf v3.21.12的棺椁沉入忘川，改换那老朽尸骸。霎时编译通过，绿字弹出的”Success”映在屏幕上，竟比闰土手里的银项圈还要刺目三分。</p>
<p>调试器在黑暗里吃吃地笑，满屏的warning如纸钱飘洒。原来我等写码的，不过是给版本之神献祭的童男童女。今日退守旧城尚能苟全，明日又当如何？怕是要学那孔乙己，把四种写法刻在Runtime的咸亨柜台前，换半碗残酒暖这数字寒夜。</p>
<p>鸡鸣时分，镜中程序猿的鬓角已染上NaN的灰白。所谓技术革新，不过是旧鬼穿新衣，在ABI的奈何桥上收买路钱。而我辈终将沦为版本长河里的水鬼，抓着 deprecated 的浮木，笑看后来者重蹈覆辙。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>end-to-end point</title>
    <url>/2025/06/05/%E8%AE%BA%E6%96%87/end_to_end_point/</url>
    <content><![CDATA[<h1 id="系统设计中的端到端论据"><a href="#系统设计中的端到端论据" class="headerlink" title="系统设计中的端到端论据"></a>系统设计中的端到端论据</h1><p><strong>J.H. Saltzer, D.P. Reed 和 D.D. Clark*</strong><br><strong>麻省理工学院计算机科学实验室</strong></p>
<blockquote>
<p><em>作者地址：J.H. Saltzer 和 D.D. Clark，麻省理工学院计算机科学实验室，马萨诸塞州剑桥市科技广场545号，邮编02139；D.P. Reed，Software Arts, Inc.，马萨诸塞州韦尔斯利市Mica Lane 27号，邮编02181。</em><br><em>本研究部分由美国国防部高级研究计划局（ARPA）资助，海军研究办公室（ONR）根据合同号 N00014-75-C-0661 监督。</em><br><em>1981年4月8-10日法国巴黎第二届分布式计算系统国际会议论文修订版，第509-512页。© 1981 电气和电子工程师协会（IEEE）版权所有。经许可转载。</em><br><em>发表于《ACM计算机系统汇刊》第2卷第4期，1984年11月，第277-288页。</em><br><em>转载于 Craig Partridge 编辑的《互联网创新》，Artech House, Norwood, MA, 1988, 第195-206页。ISBN 0-89006-337-0。另计划转载于 Amit Bhargava 编辑的《综合宽带网络》，Artech House, Boston, 1991。ISBN 0-89006-483-0。</em><br><em>Scribe&#x2F;FinalWord 源文件：<a href="http://web.mit.edu/Saltzer/www/publications/">http://web.mit.edu/Saltzer/www/publications/</a></em></p>
</blockquote>
<hr>
<span id="more"></span>

<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文提出了一种设计原则，用于指导在分布式计算机系统的模块间分配功能。该原则称为“<strong>端到端论据</strong>”，它指出，在系统低层提供的功能，与其在低层提供的成本相比，<strong>可能是冗余的或价值甚微</strong>。文中讨论的例子包括位错误恢复、使用加密的安全性、重复消息抑制、系统崩溃恢复以及交付确认。支持这些功能的低层机制，仅能作为<strong>性能增强手段</strong>来证明其合理性。</p>
<hr>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在功能之间选择适当的边界，或许是计算机系统设计者的主要活动。为这种功能放置选择提供指导的设计原则，是系统设计者最重要的工具之一。本文讨论了一类功能放置论据，它已被使用多年，但既未被明确认识，也未被广泛信服。然而，<strong>数据通信网络作为计算机系统组件的出现</strong>，通过使其适用的情况和原因更加明显，从而突出了这条功能放置的论据。本文明确阐述了这一论据，以便审视其本质并了解其真正的普适性。该论据诉诸于<strong>应用需求</strong>，并为在分层系统中将功能向上移动、<strong>靠近使用该功能的应用程序</strong>提供了理论依据。我们首先考虑该论据在通信网络中的版本。</p>
<p>在一个包含通信的系统中，人们通常在通信子系统周围划定一个模块边界，并在它与系统其余部分之间定义一个严格的接口。这样做时，明显存在一个功能列表，其中每个功能都可以通过多种方式中的任意一种来实现：由通信子系统实现、由其客户端实现、作为联合项目实现，或者可能冗余地实现，各自执行自己的版本。在推理这种选择时，应用的需求提供了一类论据的基础，其内容如下：</p>
<blockquote>
<p><strong>端到端论据核心观点：</strong><br>所讨论的功能<strong>只有借助通信系统端点的应用程序的知识和帮助</strong>，才能完整且正确地实现。因此，将该功能作为通信系统本身的特性提供是<strong>不可能</strong>的。（有时，通信系统提供的不完整版本的功能可能作为<strong>性能增强手段</strong>是有用的。）</p>
</blockquote>
<p>我们称这种反对低层功能实现的推理为“<strong>端到端论据</strong>”。以下各节将详细探讨端到端论据，首先通过一个使用该论据的典型案例研究——所讨论的功能是<strong>可靠数据传输</strong>——然后展示该论据可适用的功能范围。对于数据通信系统的情况，这个范围包括加密、重复消息检测、消息排序、保证消息交付、检测主机崩溃以及交付回执。在更广泛的背景下，该论据似乎也适用于计算机操作系统的许多其他功能，包括其文件系统。然而，如果我们首先考虑更具体的数据通信背景，审视这个更广泛的背景将更容易。</p>
<hr>
<h2 id="端到端看护"><a href="#端到端看护" class="headerlink" title="端到端看护"></a>端到端看护</h2><p>考虑“<strong>谨慎文件传输</strong>”的问题。一个文件由文件系统存储在计算机 A 的磁盘存储器中。计算机 A 通过数据通信网络与计算机 B 相连，计算机 B 也有文件系统和磁盘存储。目标是将文件从计算机 A 的存储移动到计算机 B 的存储而<strong>不受损坏</strong>，同时意识到沿途的各个点都可能发生故障。这种情况下的应用程序是文件传输程序，其一部分在主机 A 运行，一部分在主机 B 运行。为了讨论此事务中文件完整性可能面临的威胁，我们假设涉及以下具体步骤：</p>
<ol>
<li><strong>在主机 A</strong>，文件传输程序调用文件系统从磁盘读取文件（文件驻留在多个磁道上），文件系统以固定大小的块（选择为独立于磁盘格式）将文件传递给文件传输程序。</li>
<li><strong>在主机 A</strong>，文件传输程序要求数据通信系统使用某种通信协议传输文件，该协议涉及将数据拆分成数据包。数据包大小通常不同于文件块大小和磁盘磁道大小。</li>
<li><strong>数据通信网络</strong>将数据包从计算机 A 移动到计算机 B。</li>
<li><strong>在主机 B</strong>，一个数据通信程序从数据通信协议中取出数据包，并将其包含的数据交给文件传输应用程序的第二部分，即在主机 B 内操作的部分。</li>
<li><strong>在主机 B</strong>，文件传输程序要求文件系统将接收到的数据写入主机 B 的磁盘。</li>
</ol>
<p>根据这个涉及步骤的模型，谨慎的设计者可能会关注到事务的以下一些<strong>威胁</strong>：</p>
<ol>
<li><strong>磁盘读取错误：</strong> 文件虽然最初正确地写入主机 A 的磁盘，但现在读取时可能包含不正确的数据（磁盘硬件故障）。</li>
<li><strong>软件错误：</strong> 文件系统、文件传输程序或数据通信系统的软件可能在缓冲和复制文件数据时出错（A 或 B）。</li>
<li><strong>硬件瞬态错误：</strong> 硬件处理器或其本地内存在进行缓冲和复制时可能发生瞬态错误（A 或 B）。</li>
<li><strong>通信错误：</strong> 通信系统可能会丢弃或更改数据包中的位，或丢失数据包，或多次传递同一个数据包。</li>
<li><strong>主机崩溃：</strong> 在执行了未知数量（也许是全部）的事务后，任一主机都可能在中途崩溃。</li>
</ol>
<p>那么，一个谨慎的文件传输应用程序将如何应对这个威胁列表呢？</p>
<ul>
<li><strong>方法一（强化中间步骤）：</strong> 通过使用副本、超时和重试、精心放置的用于错误检测的冗余、崩溃恢复等来强化沿途的每一步。目标是将每个单独威胁的发生概率降低到一个可接受的微小值。<strong>缺点：</strong> 应对威胁二（软件错误）需要编写绝对正确的程序，非常困难且非所有相关程序都由文件传输程序员控制。如果所有威胁概率都较低，强力对策（如三重复制）显得不经济。</li>
<li><strong>方法二（端到端检查和重试）：</strong> 每个文件存储一个具有足够冗余的<strong>校验和</strong>，将未检测到错误的机会降至可忽略水平。应用程序完成传输步骤后，<strong>主机 B 端的程序读取传输的文件，重新计算校验和，将其发送回主机 A 与原始校验和比较</strong>。只有一致才声明事务提交。失败则从头重试。<strong>优点：</strong> 如果故障罕见，通常一次成功；重试成本低；最终结果可靠。</li>
</ul>
<p><strong>关键分析：</strong> 假设通信系统内部提供了可靠数据传输保证（例如，通过数据包校验和、序号检查、内部重试）。这可以消除威胁四（通信错误），但<strong>谨慎的文件传输应用仍需应对其他威胁（1,2,3,5），因此它仍需基于文件的端到端校验和提供自己的重试</strong>。通信系统的额外努力<strong>仅减少了应用层重试的频率</strong>，对结果的必然性或正确性没有影响（因为无论通信层可靠性如何，端到端校验和与重试保证了最终正确性）。</p>
<p><strong>结论（端到端论据）：</strong> 为了实现谨慎的文件传输，执行传输的<strong>应用程序必须提供文件传输特定的、端到端的可靠性保证</strong>（校验和 + 重试&#x2F;提交计划）。让数据通信系统额外付出努力去追求异常高的可靠性，<strong>并不会减轻应用程序确保可靠性的负担</strong>。</p>
<h3 id="一个过于真实的例子"><a href="#一个过于真实的例子" class="headerlink" title="一个过于真实的例子"></a>一个过于真实的例子</h3><p>一个麻省理工学院的案例：一个由网关连接多个局域网的网络系统在每跳（网关间）使用了数据包校验和。应用程序员因此假设网络提供可靠传输，<strong>忽略了数据在网关内存中存储时不受保护</strong>。一个网关在复制数据时出现<strong>瞬态错误（字节对互换，频率约百万分之一）</strong>。一段时间内，操作系统源文件反复通过此网关传输，部分文件被损坏。最终，所有者被迫进行<strong>最终的端到端错误检查：手动对照旧列表比对和修正</strong>。</p>
<hr>
<h2 id="性能方面"><a href="#性能方面" class="headerlink" title="性能方面"></a>性能方面</h2><p>如果得出结论说低层在获得可靠性方面不应起任何作用，那就过于简单化了。考虑一个<strong>不可靠网络</strong>（例如，丢包率1%）。简单的端到端策略（传整个文件后校验）随着文件长度增加，<strong>性能急剧下降</strong>（所有包正确到达的概率指数下降，预期传输时间指数增长）。显然，在低层付出一些努力<strong>提高网络可靠性（如包级校验重传）</strong>，可以显著改善应用性能。但关键思想是：低层<strong>无需提供“完美”可靠性</strong>。</p>
<ul>
<li><strong>工程权衡：</strong> 在数据通信系统中投入多少可靠性措施的努力，是基于<strong>性能</strong>的权衡，而非<strong>正确性</strong>的要求。</li>
<li><strong>性能成本的两个方面：</strong><ol>
<li><strong>通信系统不可靠：</strong> 导致应用层频繁重试（端到端校验失败），性能差。</li>
<li><strong>通信系统加强内部可靠性：</strong> 措施本身有成本（冗余数据占用带宽，内部一致性检查引入延迟）。</li>
</ol>
</li>
<li><strong>权衡原则：</strong> 无论通信系统多可靠，应用层的端到端检查<strong>必须存在</strong>。因此，没必要追求应用层以下点的可忽略错误率。一个“恰当”的权衡：设计通信系统提供<strong>低成本、低工程代价</strong>的可靠性，评估残余错误水平，确保其与应用层可接受的重试频率一致。</li>
<li><strong>性能增强放置的复杂性：</strong> 将功能放在低层以提升性能需谨慎。有时高层能实现相同或更好的增强。低层执行可能更高效（若对现有机制扰动小），但也可能<strong>成本更高</strong>：<ul>
<li>低层子系统被多个应用共享，不需要该功能的应用也需付费。</li>
<li>低层可能缺乏高层信息，无法高效完成任务。</li>
</ul>
</li>
<li><strong>示例（文件传输于不可靠网络）：</strong> 早期重试机制（如接收方定期校验已接收部分并反馈，发送方重传出错部分）可放在通信层或应用层。<ul>
<li><strong>放应用层：</strong> 简化通信系统，但增加总体成本（每个应用需实现自己的增强）。</li>
<li><strong>放通信层：</strong> 可能更高效（网络内按跳重试，减少延迟），但强制不需要该增强的应用付费。</li>
<li><strong>端到端论据未指明放置位置：</strong> 需根据具体系统信息权衡。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="端到端论据的其他例子"><a href="#端到端论据的其他例子" class="headerlink" title="端到端论据的其他例子"></a>端到端论据的其他例子</h2><h3 id="交付保证-Delivery-Guarantees"><a href="#交付保证-Delivery-Guarantees" class="headerlink" title="交付保证 (Delivery Guarantees)"></a>交付保证 (Delivery Guarantees)</h3><ul>
<li><strong>问题：</strong> 通信网络（如ARPANET）提供消息送达目标主机的确认（如RFNM）。</li>
<li><strong>端到端观点：</strong> 知道消息送达主机<strong>不重要</strong>。应用需要知道的是<strong>目标应用是否处理了该消息</strong>（交付后、处理前仍可能出错）。真正需要的确认是<strong>端到端的</strong>（由目标应用发起 - “我做了”或“我没做”）。</li>
<li><strong>替代策略的局限性：</strong> 让目标主机承诺交付即处理，可消除某些应用的端到端确认需求，但<strong>不适用所有情况</strong>（如需要多主机协调的两阶段提交协议，或需要处理应用失败&#x2F;拒绝的情况）。</li>
</ul>
<h3 id="数据的安全传输-Secure-Transmission-of-Data"><a href="#数据的安全传输-Secure-Transmission-of-Data" class="headerlink" title="数据的安全传输 (Secure Transmission of Data)"></a>数据的安全传输 (Secure Transmission of Data)</h3><ul>
<li><strong>问题：</strong> 通信系统提供自动加密所有流量。</li>
<li><strong>端到端观点（三方面）：</strong><ol>
<li>通信系统加密需<strong>信任其安全管理密钥</strong>。</li>
<li>数据在<strong>目标节点内及分发到目标应用过程中是明文</strong>，易受攻击。</li>
<li>消息的<strong>真实性</strong>仍需由应用检查。</li>
</ol>
</li>
<li><strong>结论：</strong> 满足应用安全需求（认证、密钥管理、端到端保密），<strong>不需要</strong>通信子系统自动加密所有流量。<strong>端到端加密</strong>是解决方案。</li>
<li><strong>补充：</strong> 网络级自动加密（使用简单密钥，频繁更换）可作为<strong>防止信息泄露的防火墙</strong>，但这与<strong>应用级认证和访问控制</strong>是<strong>不同的、互补的</strong>需求。</li>
</ul>
<h3 id="重复消息抑制-Duplicate-Message-Suppression"><a href="#重复消息抑制-Duplicate-Message-Suppression" class="headerlink" title="重复消息抑制 (Duplicate Message Suppression)"></a>重复消息抑制 (Duplicate Message Suppression)</h3><ul>
<li><strong>问题：</strong> 网络可能因内部重试机制导致消息重复交付。网络可提供抑制重复功能。</li>
<li><strong>端到端观点：</strong> 即使网络抑制了内部重复，<strong>应用自身</strong>在其故障&#x2F;重试过程中也可能产生<strong>应用级重复请求</strong>（对网络是不同消息，无法抑制）。应用<strong>必须有能力检测和抑制自己的重复</strong>。因此，这个机制可以放在应用层，<strong>网络层的重复抑制功能可以省略</strong>（应用层机制也能处理网络产生的重复）。该推理同样适用于<strong>消息丢失</strong>（应用需检测并重试）。</li>
</ul>
<h3 id="保证先进先出-FIFO-消息传递-Guaranteeing-FIFO-Message-Delivery"><a href="#保证先进先出-FIFO-消息传递-Guaranteeing-FIFO-Message-Delivery" class="headerlink" title="保证先进先出 (FIFO) 消息传递 (Guaranteeing FIFO Message Delivery)"></a>保证先进先出 (FIFO) 消息传递 (Guaranteeing FIFO Message Delivery)</h3><ul>
<li><strong>问题：</strong> 通信系统通常保证同一虚电路上消息的FIFO交付。</li>
<li><strong>端到端观点：</strong> 对于<strong>跨多个独立虚电路或涉及外部进程</strong>的分布式应用（如一个节点发起需在多个站点执行动作的请求），通信系统提供的FIFO保证<strong>不足以保证动作按正确顺序发生</strong>。必须在<strong>高于通信子系统</strong>的层级（应用层或中间件层）使用独立机制控制动作的排序。</li>
</ul>
<h3 id="事务管理-Transaction-Management-SWALLOW-系统案例"><a href="#事务管理-Transaction-Management-SWALLOW-系统案例" class="headerlink" title="事务管理 (Transaction Management) - SWALLOW 系统案例"></a>事务管理 (Transaction Management) - SWALLOW 系统案例</h3><ul>
<li><strong>设计：</strong> SWALLOW 分布式数据存储系统应用端到端论据显著降低开销。</li>
<li><strong>省略网络层功能：</strong><ul>
<li><strong>重复抑制：</strong> 不提供。理由：a) 对象ID+版本信息足以检测重复写入；b) 重复读请求只产生重复响应，发起方可轻松丢弃。<strong>简化了底层通信协议</strong>。</li>
<li><strong>交付确认：</strong> 不提供。写操作需要的确认是“数据安全存储”，只能由SWALLOW高层提供。读操作的响应本身即是确认。<strong>减少了一半的消息量</strong>，降低主机和网络负载，提高性能。</li>
</ul>
</li>
<li><strong>结论：</strong> 基于应用语义，省略低层通用功能是可行且高效的。</li>
</ul>
<hr>
<h2 id="识别端点-Identifying-the-Ends"><a href="#识别端点-Identifying-the-Ends" class="headerlink" title="识别端点 (Identifying the Ends)"></a>识别端点 (Identifying the Ends)</h2><p>端到端论据的应用需要<strong>细致分析具体应用需求</strong>。</p>
<ul>
<li><strong>示例1 - 实时语音通话：</strong><ul>
<li><strong>应用需求：</strong> 恒定速率数据流，低延迟至关重要。少量数据损坏或丢失可接受（语音冗余，高层纠错如“请再说一遍”）。</li>
<li><strong>端到端论据应用：</strong> 低层追求比特完美（如重传损坏包）引入的<strong>延迟破坏性大于数据损坏本身</strong>。低层应接受轻微损坏或使用插值&#x2F;静音，<strong>避免重传</strong>。可靠性主要由高层（用户交互）处理。</li>
</ul>
</li>
<li><strong>示例2 - 语音留言系统：</strong><ul>
<li><strong>应用需求：</strong> 数据存储供日后收听。延迟不重要，但<strong>记录准确性至关重要</strong>（收听时无法请求重发）。</li>
<li><strong>端到端论据应用：</strong> 低层引入延迟以追求可靠性的措施<strong>不再被反对</strong>。端到端论据主要应用于<strong>数据包排序和重复抑制</strong>（确保存储文件正确）。</li>
</ul>
</li>
<li><strong>关键点：</strong> 端到端论据<strong>不是绝对规则</strong>，而是指导协议和应用设计的<strong>分析工具</strong>。必须<strong>谨慎识别特定应用的“端”在哪里以及其具体需求</strong>。</li>
</ul>
<hr>
<h2 id="历史以及在其他系统领域的应用"><a href="#历史以及在其他系统领域的应用" class="headerlink" title="历史以及在其他系统领域的应用"></a>历史以及在其他系统领域的应用</h2><ul>
<li><strong>起源：</strong> 文中例子非首创，是多年积累。作者首次注意到可疑中间确认是MIT CTSS系统的“wait”消息[3]。加密相关的论据由Branstad(1973)[2]首次公开讨论。</li>
<li><strong>数据库与分布式系统：</strong> 两阶段提交协议(Gray[5], Lampson &amp; Sturgis[10], Reed[13,14])是端到端协议的典范（不依赖底层通信的完美性）。</li>
<li><strong>应用系统错误控制：</strong><ul>
<li><strong>银行系统：</strong> 高层审计程序（策略和法律要求）会捕获高低层错误。消除协调错误的昂贵算法不如使错误罕见的低成本算法合适。</li>
<li><strong>航空订票：</strong> 代理会持续尝试直至确认或拒绝。低层保证未确认请求在崩溃后存活的恢复机制非必需。</li>
<li><strong>电话交换机：</strong> 导致单次呼叫丢失的故障不值得提供显式恢复（用户会重拨）[7]。</li>
</ul>
</li>
<li><strong>网络协议争论（数据报 vs. 虚电路）：</strong> 本质是关于端到端论据的辩论。虚电路提供易用的可靠流；端到端论据主张其功能对某些应用不完整，从数据报开始自建更灵活。</li>
<li><strong>磁带存储系统（1950年代）：</strong> 反复尝试构建“可靠磁带子系统”失败（磁带机不稳定、操作员不可靠、系统崩溃）。最终标准做法是<strong>每个应用提供自己的应用相关检查和恢复策略</strong>，假设低层错误检测仅减少高层检查失败的频率（如Multics备份系统[17]在强大磁带格式上仍用记录标签和文件多副本）。</li>
<li><strong>RISC架构：</strong> 类似论据。让客户端（编译器）用基本指令实现所需功能性能更好；设计师预判深奥功能需求易失准，客户端终将重实现。</li>
<li><strong>开放操作系统 (Lampson[9])：</strong> 反对将任何功能永久固化在低层；低层提供的功能应总是可被应用的特殊版本替换。理由：任何功能总有一些应用为正确满足自身需求必须自己实现。这催生了由可替换库例程构成整个OS的“开放”系统概念（近期在单应用计算机上才可行）。典型大型OS的大量固定管理程序功能可能是复用昂贵硬件经济压力的产物。近期系统“内核化”项目[16,12]旨在将功能移出低层，虽动机不同（正确性），但副作用是使OS对应用更灵活，契合端到端论据主旨。</li>
</ul>
<hr>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>端到端论据是选择通信子系统功能时的一种“<strong>奥卡姆剃刀</strong>”。通信子系统常在应用未知时被设计，易诱使设计师通过承担过多功能来“帮助”用户。了解端到端论据<strong>有助于减少此类诱惑</strong>。</li>
<li>分层通信协议是趋势，但缺乏明确的分层标准。分层利于模块化。端到端论据可视为<strong>组织此类分层系统的理性原则集的一部分</strong>。希望本文讨论有助于为关于“恰当”分层的争论增添实质内容。</li>
</ul>
<hr>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢David Cheriton, F.B. Schneider, Liba Svobodova等人对本文初稿的审阅和评论。该主题也在1980年12月加州Fallbrook举行的ACM分布式计算基础研讨会上进行了讨论。这些评论和讨论对澄清论据非常有帮助。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Bolt Beranek and Newman Inc. Specifications for the interconnection of a host and an IMP. Technical Report No. 1822, Cambridge, Mass., December, 1981.</li>
<li>Branstad, D.K. Security aspects of computer networks. AIAA Paper No. 73-427, AIAA Computer Network Systems Conference, Huntsville, Alabama, April, 1973.</li>
<li>Corbato, F.J., et al. <em>The Compatible Time-Sharing System, A Programmer’s Guide.</em> M.I.T. Press, Cambridge, Massachusetts, 1963, p.10.</li>
<li>Diffie, W., and Hellman, M.E. New directions in cryptography. <em>IEEE Trans. on Info. Theory</em>, IT-22, 6, (November, 1976), pp.644-654.</li>
<li>Gray, J.N. Notes on database operating systems. In <em>Operating System: An Advanced Course</em>. Volume 60 of <em>Lecture Notes in Computer Science</em>, Springer-Verlag, 1978, pp.393-481.</li>
<li>Greenwald, M. Remote virtual disk protocol specifications. M.I.T. Laboratory for Computer Science Technical Memorandum, in preparation. Expected publication, 1984.</li>
<li>Keister, W., Ketchledge, R.W., and Vaughan, H.E.: No. 1 ESS: System organization and objectives. <em>Bell System Technical Journal 53</em>, 5 (part 1), (September, 1964) p. 1841.</li>
<li>Kent, S.T.: Encryption-based protection protocols for interactive user-computer communication.: S.M. thesis, Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, May, 1976. Also available as M.I.T. Laboratory for Computer Science Technical Report, TR-162, May, 1976.</li>
<li>Lampson, B.W., and Sproull, R.F. An open operating system for a single-user machine. <em>Proc. Seventh Symposium on Operating Systems Principles, Operating Systems Review 13</em>, Special issue (December, 1979), pp.98-105.</li>
<li>Lampson, B., and Sturgis, H: Crash recovery in a distributed data storage system. Working paper, Xerox PARC, November, 1976 and April, 1979. Submitted to <em>CACM</em>.</li>
<li>Needham, R.M., and Schroeder, M.D.: Using encryption for authentication in large networks of computers. <em>CACM 21</em>, 12, (December, 1978), pp.993-999.</li>
<li>Popek, G.J., et al.: UCLA data secure unix. <em>Proc. 1979 NCC</em>, AFIPS Press, pp.355-364.</li>
<li>Reed, D.P.: Implementing atomic actions on decentralized data. <em>ACM Transactions on Computer Systems 1</em>, 1 (February, 1983), pp.3-23.</li>
<li>Reed, D.P.: Naming and synchronization in a decentralized computer system. Ph.D. thesis, Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, September 1978. Also available as M.I.T. Laboratory for Computer Science Technical Report, TR-205, September, 1978.</li>
<li>Reed, D.P., and Svobodova, L.: SWALLOW: A distributed data storage system for a local network. In West, A., and Janson, P., ed. <em>Local Networks for Computer Communications, Proc. IFIP Working Group 6.4 International Workshop on Local Networks.</em> North-Holland, Amsterdam, 1981, pp.355-373.</li>
<li>Schroeder, M.D., Clark, D.D., and Saltzer, J.H.: The Multics kernel design project. <em>Proc. Sixth Symposium on Operating Systems Principles, Operating Systems Review 11</em>, 5 (November, 1977), pp.43-56.</li>
<li>Stern, J.A.: Backup and recovery of on-line information in a computer utility. S.M. thesis, M.I.T. Department of Electrical Engineering and Computer Science, August 1973. Available as M.I.T. Project MAC Technical Report TR-116, January, 1974.</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>模式分类</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0-%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0-%E5%88%86%E7%B1%BB/1-1734924258079-2.jpg" alt="1"></p>
<span id="more"></span>
<p>对于设计模式可以根据其用途、特性和目标进行分类，主要分为三大类：<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。此外，还有一些并发模式和架构模式也在特定场景中使用较多。</p>
<h2 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1~创建型模式"></a><strong>1~创建型模式</strong></h2><p>创建型模式主要关注对象的创建方式，目的是隐藏对象创建的复杂性，并提高系统的灵活性和可扩展性。</p>
<h2 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2~结构型模式"></a><strong>2~结构型模式</strong></h2><p>结构型模式主要关注类与对象的组合方式，旨在提高代码的可复用性、灵活性和扩展性。</p>
<h2 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3~行为型模式"></a><strong>3~行为型模式</strong></h2><p>行为型模式关注对象之间的通信与协作，旨在简化复杂的控制流程和对象交互。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>用一个简单的示例来进行面向过程和面向对象的俩种特性之间的区分</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Aspose.Words.0ed437a4-543a-4af4-8349-d84cfd143b73.001.jpeg" alt="Aspose.Words.0ed437a4-543a-4af4-8349-d84cfd143b73.001"></p>
<span id="more"></span>
<p>这是一个经典的问题。将大象装进冰箱里分几步。不难看到，我们可以先把冰箱打开，然后我们把大象放到冰箱里面去，再之后将冰箱关上。这是一个简单的三步流程。在这三步中，我们可以观察到，执行操作的对象是谁，是<strong>我们</strong>。也就是说，这一系列的操作都是由我们去触发的。而这就跟面向过程的核心很接近了。	在面向过程的设计中，我们充当的是一个动作的执行者与一个动作的对象提供者。或者说，我们要做的就是调用一个函数并且为它提供对应的参数。这里的打开冰箱就是我们一个函数调用所需要实现的功能，而<strong>打开</strong>的这个实现是由函数封装的。冰箱这个对象是由我们提供给函数的。从此中我们可以看到，面向对象，是要求调用者明确其调用的功能，和被传递给调用的方法的对象的。</p>
<p>与此同时，我们来从另外一个视角来看这个问题。在这其中，我们如果认为没有人这个个体呢？我们可以把这个过程看做。冰箱打开了自己，大象走进了一个地方，这个地方是一个冰箱，冰箱本身容纳了一个物体，这个物体是一个大象，冰箱本身关闭了。整个过程看下来，我们发现，我们并没有用到一个额外的人物来帮我我们实现这三个步骤。而是仅仅局限于大象和冰箱这俩个对象来实现我们的功能。而这个就是面向对象的一种思想。</p>
<p>在这里我们将大象和冰箱都抽象为一个对象。冰箱拥有打开，关闭，容纳功能，大象拥有被容纳的功能。通过这样，我们实现了对一个对象的设计。在这种设计下，我们只需要知道一个对象所拥有的功能我们就可以实现对应的操作。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>看前须知</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0.0-%E7%9C%8B%E5%89%8D%E9%A1%BB%E7%9F%A5/</url>
    <content><![CDATA[<p>由于一些原因，这里0-12的所有文档的排版都很垃圾<br>实际上就是我懒得再重新排版了，这是我直接从我之前写的文档转换来的<br>重新排版太麻烦了，所以我就摆了，凑活着看吧</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>前面我们看完了最后一种创建型模式:原型模式。接下来我们要进入到设计模式的第二大类:<strong>结构性模式</strong>。</p>
<span id="more"></span>
<p>需要注意的是，在创建型模性模式中就不同了，其注重的是侧重于如何将类或对象组合在一起形成更大的结构，以实现系统的高效协作和更好的扩展性。它们主要关注如何组织和组合类或对象，处理不同类之间的关系和交互，使得系统更灵活、可维护。也就是说在这个模式中一个相对重要的原则是<strong>开放封闭原则</strong>。</p>
<p>还有一个也很重要的原则:合成复用原则</p>
<p>来看一下第一个要学的结构性模式：<strong>适配器模式</strong>。</p>
<p>首先来说一下适配器模式起的作用。人如其名，适配器存在的目的就是起到一个适配的作用。在显示生活中，如果我们离开中国大陆，我们需要使用当地的电的话，我们通常需要一个适配器，就比如香港等地，你是无法使用你现有的接口去使用当地的插口的。你需要去购买一个能够接通俩头的适配器去转换电压或者提供插口之类的。</p>
<p>适配器的作用也是如此。就比如我们的程序中有着多个独立的类，当我们想要在一个类中去使用另一个类时，我们会先去考虑我们要使用的这个类有没有接口可以提供别的类使用，有自然就简单，但如果没有呢。没有的话我们有多种做法，最直接的就是去给这个被使用的类添加一个可供目标类使用的接口。但是这违背了开放封闭原则，所以我们需要考虑一些别的方法，这时候适配器模式就出现了。</p>
<p>还是那个问题，只说还是很抽象，上代码。</p>
<p>我们重新来分析下适配器模式下需要的几个层次。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/1.jpeg" alt="1"></p>
<p>在适配器模式中，存在的一个非常核心的概念就是包装，我们期望中的一个适配器是一个能够将想要整合进现有代码的外部类包装成我们能够直接使用现有的统一接口的类。</p>
<p>就比如把，我们在设计中规定了我们所有的渲染函数都必须是draw名，无论你是渲染矩形，圆形还是什么。现在我们想要在现有代码中去引入一个外部已经实现好的类，但是这个类的接口名不是draw，如果我们不包装直接使用，那么我们就需要时刻去注意我们编写的代码，这是很麻烦的。所以，我们考虑使用一层包装将这个外部类包装成跟我们现有的类在外部看起来一样的，我们只举最简单的例子，就比如我们只是包装它的函数名。那么我们就需要在这个适配器类中去构建我们现在的外部库向我们现有代码中兼容的装换原则。在这里可以见到视作是在外部用一个统一的函数名来包装调用我们实际的函数名。</p>
<p>好了，接下来我们来看一下适配器类中我们需要了解的层次。最底层就是我们的源接口，就是我们现在想要引入程序的代码，这个接口是不符合我们用户端当前使用的接口规范的。</p>
<p>在往上就是一个适配器的层次，在这个层次中，其规定了我们的源接口项目标接口转换的方法。这里我们对前面的简单情况进行扩展，我们前面只是说了只用变换名字调用函数的情况。让我们复杂一点，在类的设计中，由于我们期望的设计都应该是遵守设计模式三原则的，所以我们引入的这个类也是一个应该遵守开放封闭原则的类，所以我们的适配方法不应该是去修改我们的源接口中的实现的。</p>
<p>而在一般情况下，我们的这个适配器接收的参数是由用户层提供的，也就是我们装换后的接口提供的，那么，我们想要实现这俩者之间的适配，我们就得考虑我们当前目标层的接口之间与源接口之间需要来进行怎么样的对接。这个其实就是我们的电压适配器中那个物理原理(那个电压转换原理)。而这个就是我们的适配器类中所要注意的核心了，通过一个适配器提供的转换方法，我们将一个用户层接口所能提供的信息给进行一系列的加工，转换成了能够调用出来源接口的一系列信息。然后我们的适配器会去调用我们的源接口，这个就是我们适配器模式的核心。</p>
<p>重新回到我们那个最简单的模式来看一下，假设我们俩段的接口调用都不用传递或处理任何参数，那么我们这里的这个适配器接口将不用处理任何的细节，只需要在现有的封装接口中去调用我们的源接口即可，无需考虑参数间的处理。</p>
<p>然后我们再往上去进行探索，再往上其实就是我们用户接触的接口了。其实这个接口一般在设计中都是有一套接口规范来定义的。就比如你的渲染模块的渲染接口应该是什么名字，应该传递什么参数等等。这个接口是用户是直接调用的接口，直接屏蔽了用户与底层的交互。</p>
<p>最上层就是我们的用户层了，这一层没什么好说的，其实就是根据接口规范去找到对应的接口并进行调用的层次。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/3.jpeg" alt="3"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/4.jpeg" alt="4"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/5.jpeg" alt="5"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/6.jpeg" alt="6"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/7.jpeg" alt="7"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/8.jpeg" alt="8"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/2.jpeg" alt="2"></p>
<p>由于截屏问题，有些代码无法看到，自行脑补</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>接下来进入<strong>桥接模式</strong></p>
<p>首先来看到给出的定义：将抽象部分与它的实现部分分离，使得它们都可以独立的进行扩展变化。</p>
<span id="more"></span>
<p>我们来看到一个简单的例子。我们电脑上常用的绘图软件，我们可以使用其绘制各种各样的图像，矩形，圆型等。如果要我们来设计的话，我们将会把这些图形抽象为一个个类，这些类的具体示例就是我们画布上的具体图形。</p>
<p>在这基础之上，我们还可以为这些个图形指定不同的颜色，就比如黄色，紫色，白色等等。那么我们如果想为我们绘制的图形也加上指定的颜色呢？在底层设计中，我们有多种做法，最简单的就是为每一个图形类都去派生出对应颜色的子类吧，这样当我们要创建一个特定颜色的矩形时，我们只需要去创建对应的对象即可了。但是吧，你应该也能感觉到这个设计上的巨大缺陷，当我们存在11个图形，11个颜色的时候，我们如果要列出所有可能的图像，我们总共需要创建121个类，这个是不可接受的。那么我们就需要一个优化的方法。</p>
<p>这个方法其实在现实生活中也有体现，就比如你在画画的时候，你一般是什么，你一般都是先考虑画什么图形，然后再考虑里面需要填充什么颜色。这个想法中，我们考虑画什么图形的这一步可以抽象为抽象部分，后面的填充颜色可以视为实现部分，毕竟这部分意味着你将会画出一个实际的图形出来。</p>
<p>接下来，我们再将这个想法建模到我们的设计中去。我们前面的做法是通过一个类去完整的标识我们需要的图像的形状，颜色等属性。但是我们这里把它们分离开来，把这些固定了组合的类给他拆分成形状类和颜色类。这就是桥接模式的核心，将一个类中可拆分的部分且不拆分会导致设计复杂的部分给他拆分出来，用前面的术语其实就是将抽象部分与实现部分给他拆分成俩个单独的类。</p>
<p>让我们来看看这样做的好处，在这种设计下，我们的形状类和颜色类都由一个独立的抽象类进行管理。那么我们需要怎么去实现一个具体颜色的矩形的创建呢。这时候就需要我们<strong>桥接模式</strong>的<strong>桥接</strong>俩字提供作用了。我们创建一个具体的实例类，就比如紫色矩形。这个类中应该至少保留着一个形状指针和一个颜色指针。我们前面已经提到，那个抽象部分和实现部分都应该被管理。在实际设计中，其实就是各自隶属于一个抽象类下。在我们的这一个实例类中，这写个部分一般都以一种聚合关系连接，毕竟你想，即使你这些个实例对象不见了，你的矩形属性，颜色属性，这些都应该是还存在的吧。</p>
<p>也就是说，桥接模式的核心，就是把一个复杂的类，甚至于不用说复杂，只要这个类中存在相对联系比较松散的属性，我们可以将这些属性给它分离开来，类中只保存这些类的一个单独实例。且这些类之间通过聚合关系联系。通过这样的设计。类间关系进行了进一步的解耦，当我们需要进行扩展时，我们不再需要对这个类进行一系列的派生。而这样在需要特定的属性类时去创建一个唯一的示例类即可，大大减少了设计的复杂度。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/1.png" alt="1"></p>
<p>上面是一个桥接模式UML类图的举例。</p>
<p>让我们来分析下桥接模式的UML类图，其实在这其中，最关键的其实是其关联关系的几个类。这些个关联关系的类定义了整个桥接模式下的类的基本性质。</p>
<p>在整个桥接模式设计中，各个职责不强关联的类都被分离开来并一般都由一个抽象类进行管理。然后这一系列的抽象类间将会通过组合关系或者聚合关系进行互相通信。这种通信定义了我们最后看到的类的属性，就比如红色的矩形之类。</p>
<p>在桥接模式要表示的一个最后的对象中，一般就是我们这些个关联关系的属性的集合即各个抽象类的单个实例。在这些个抽象类中，能够派生出一系列的子类，但是最后的对象有且只有使用了这些个类的一个。在这里其实可以联想到我们的抽象工厂模式中的一个产品的构建，很相似。不过我们的抽象工厂模式服务的对象是一个产品的构建，其实吧，这里也是一个产品的构建，但是这个产品的构建是由其他相对来说比较大的产品来构建的，也可以看做是抽象工厂模式的产品层者一层的。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-/</url>
    <content><![CDATA[<p>接下来我们进入<strong>组合模式</strong>。</p>
<p>给出<strong>定义</strong>：组合多个对象形成树形结构以表示”部分-整体”的结构层次。组合模式对单个对象(即叶子对象)和组合对象(即树这只鸟容器对象)的使用具有一致性。组合模式又可以称为”部分-整体”模式，属于对象的结构模式，将对象组织到树形结构中去，可以用来描述整体与部分间的关系。</p>
<span id="more"></span>


<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-/1.png" alt="1"></p>
<p>我们先来分析一个组合模式下的UML类图，其实都很简单。在接下来中，我们将会使用树的术语进行分析。</p>
<p>其实组合模式抽象理解起来很简单，就是将一系列具有相似属性的类使用树的数据结构给它管理起来。在这种设计下，我们的UML类图中存在一个抽象基类，这个基类其实就是我们建树中常用的节点类。在这个抽象基类中，包含了一系列类似于树的方法以及在实际中我们这个类所扩展出来的属性。</p>
<p>在这些方法中，为了实现组合模式，其中的关键就是那个自身抽象类的指针。这个指针的作用我们也很熟悉，就是我们建树中常用的那个边。这里我们一般不考虑使用左右孩子的俩个指针设计，毕竟这样更耗费空间，也可能导致我们后续在设计时出现混乱。所以我们使用父亲节点这个在多叉树中每个节点唯一的属性进行连接。</p>
<p>在这个抽象基类的简单派生中，我们可以看到它派生出了俩个子类，其中一个是一个叶子节点类，并没有什么特殊的。另一个是管理节点类。好，这里我们对整颗组合模式将要组成的树进行下分析和分类。在这一整颗树中，我们将最底层的节点(即没有子节点的节点)分类为叶子节点。在叶子节点之上的，统一分类为中间节点，或者说管理节点(因为这些个节点在逻辑上都有着自己的孩子)。在这些个管理节点中，除没有父亲的根节点外，其他的都大致一样。</p>
<p>总的来说，组合模式就是一颗专门用于管理类的树。在这个模式中，每个在这颗树中的节点都有着指针指向它的父亲(当然可能存在设计使得使用孩子指针，不给不太可能就是了)。在这种层次设计下，使得同一层次下的节点往往具有相同或相似的属性，而位于不同分支下的节点，由于深度的加深，各自的属性可能会逐渐的发生差异化，但是总的来说还是会符合整颗树的设计规范的。而且，只要在这颗树中，无论你是位于哪里，只要你遵守了抽象层，也就是抽象节点的接口设计规范，那么所有的节点都可以为外部使用统一的接口进行调用。</p>
<p>对了，既然是一颗树，那么对于这颗树的有效遍历，将会是这颗树无法逃脱的命题，而一个节点值保留其的父节点地址显然是无法实现遍历的。所以这个就需要我们去进行一些额外的设计，在我们的管理节点类中，我们需要去添加一个额外的成员变量来储存我们当前节点所连接的所有的子节点的地址。通过这个成员变量，我们才能够从整颗树的根节点去不断的向下遍历，知道遍历完整颗树。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><em><strong>该文档进行设计模式的装饰模式的介绍</strong></em></p>
<h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>​	装饰模式，重要就在于<strong>装饰</strong>俩字。装饰模式存在的意义是在于不改变一个对象本身的基础上去给对象添加添加额外的新行为。这种模式可以用一种现实生活中的一个行为进行类比。最贴近的就是一个裸人不断的穿上衣服，这个不断穿衣服的过程就可以视为装饰模式的目的。体现在具体类的设计中就是对于一个类的属性的不断扩充。</p>
<p>​	我们再来从设计模式三原则的角度来分析一下。主要看到开放封闭原则。我们在设计中如果想要去添加一个类的属性，由于开放封闭原则，我们是不希望去直接修改类的设计的。那么我们就需要另外一种方法来进行这个属性的扩充，这种设计的方法或者说模式就被定义为装饰模式。</p>
<p>​	总的来说，这种模式的真正意义就在于解决<strong>类的扩展性问题</strong></p>
</blockquote>
<span id="more"></span>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>要了解设计模式还是得回到具体的例子中去，我们举个网络传输的例子</p>
<img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/example.png" alt="example" style="zoom:80%;">

<blockquote>
<p>图中其实已经显示的很明确了，在网络传输的模型中，每层模型其实就相当于一个<strong>装饰器</strong>。每经过一层模型，我们的数据就会多一些属性，而这些属性就是装饰器给它进行添加的。在进入下一层后，我们会保留在这一层中获取到的新属性。或者这么理解，即使你当前数据已经经历过了一个装饰器的装饰，但是当你到达下一个装饰器的时候，你可以将这个数据对象看做是一个没有经历过装饰的数据。</p>
</blockquote>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>​	对于装饰模式提到的装饰方法，其实我们一般能够想到俩种装饰技巧</p>
<p>​	第一种就是最直观的<strong>继承</strong>，这种很好理解，你继承了一个类就继承了这个类的属性</p>
<p>​	你再在这个新类中去添加一些属性就可以实现这种封装了</p>
<p>​	第二种方法是装饰模式中常用的方法，使用<strong>关联机制</strong></p>
<p>​	这个你去看关联关系的UML类图也能够一眼看出来(你都看到这了不至于连这个都不知道吧)</p>
<h3 id="区别-优劣"><a href="#区别-优劣" class="headerlink" title="区别(优劣)"></a>区别(优劣)</h3><blockquote>
<p>​	既然这俩都能够实现装饰，那我们更常用<strong>关联机制</strong>下的装饰模式的原因以及这俩的优劣呢？</p>
</blockquote>
<h4 id="继承机制"><a href="#继承机制" class="headerlink" title="继承机制"></a>继承机制</h4><blockquote>
<p>​		使用继承的直接优点就是简单，我们需要一个新的属性，就直接在这个子类中去添加属性就可以了，但是这种设计也带来	了一些问题。回想一下我们C++中继承类的创建。这种类的创建其实是静态的。</p>
</blockquote>
<p>​		或者这么说吧，你的子类对象创建其实是需要创建一套属于子类自己的数据的，也就是说，包括了父类的对象也是在构建子类对	象时进行初始化的，这其实会导致一个什么问题呢，就是我们其实很难去控制这个子类包含的基类数据。因为这是一个属于自己的副	本，那么当我们想将这个子类再装饰上另一个子类时，这里的设计其实会比较混乱，即使你会说可以使用父类指针，但事实上这种设	计会导致在后续中我们的冗余数据会增多。因为在装饰时我们并不是使用现有的进行装饰，而是创建了一个副本进行装饰的，这个就	是整个继承机制的最大弊端。</p>
<p>​		而且在传统的继承模型中，我们是通过类层次结构来扩展功能的，但这会导致子类的功能是预先定义好的。如果想要动态地扩展	或修改对象的功能，传统的继承设计就显得不够灵活。例如：</p>
<p>​		如果我们想给一个已有的类添加新的行为，通常需要通过继承来创建新的子类，这种方式是静态的，需要在编译时确定。如果某	个子类已经被创建，我们无法在运行时再灵活地对其进行修改或扩展，不能随时给对象增加新的功能。这就是静态继承的局限性。</p>
<h4 id="关联机制"><a href="#关联机制" class="headerlink" title="关联机制"></a>关联机制</h4><blockquote>
<p>​		关联机制，顾名思义就是使用关联关系来实现的机制，这是一种更加灵活的方法，通过将一个类的对象嵌入到另一个新对	象中，有另一个对象来进行决定是否调用嵌入对象的api方法以及决定是否对于这个对象的行为进行扩展。我们将这么一个新对	象称之为<strong>装饰器</strong>。</p>
</blockquote>
<p>​		为了使得装饰器以及被装饰器装饰的对象相对于客户端来首透明，我们规定这俩者必须实现相同的接口。通过这样的设计，客户	端使用时不需要去关注这个类是否已经被装饰过。</p>
<p>​		我们可以在被装饰的类中去调用在装饰器类中定义的方法，来为这个类实现更多的功能。而且由于我们前面规定的接口统一而衍	生出来的透明性，这里就实现了我们前面的递归嵌套，即对于已经装饰过的对象可以继续作为新的被装饰的对象进行装饰。这种架构	下我们可以去递归嵌套多个装饰，从而添加任意多的功能。</p>
<p>​		也就是说，我们以关联机制来实现的装饰模式其实是以对客户来说透明的方式来动态的给一个对象加上更多的属性，换句话说，	客户端并不会觉的对象在装饰前后有什么不同，这句话说的有点歧义，不过你需要自己理解一下。装饰模式可以在不需要创建额外更	多的子类的情况下去对对象的功能进行扩展，这个就是装饰模式的模式动机。</p>
<p>​		我再对这里进行一下解析，可能对于前面的动态添加有点误会。简单来看吧，我们只需要在程序编译时去设计出对应的装饰器类	并进行实例化，然后我们就可以在代码中进行设计，在必要时将这些个装饰类绑定上我们需要的类对象，需要注意的是，我们这些装	饰类中，一般都存在一个父类指针用于指向一个相对唯一的对象，这个将会由一定区域内的代码进行使用。接着，当我们想要使用这	个装饰器时，我们只需要去调用对应的类方法即可，此时装饰器就能够实现我们的功能。就比如对应装饰api的多次调用应该实现对	于包含的类对象的多次装饰行为。</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/1419489-20190630151918778-1393745886.png" alt="img"></p>
<blockquote>
<p>​	<strong>在任何一个设计模式中，它的UML类图都是重中之重。</strong></p>
</blockquote>
<h3 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a>继承问题</h3><blockquote>
<p>​	这里你第一眼可能会注意到其中的<strong>继承</strong>关系。在这个类图中，你可以看到对应的所有子类的父类都是Component类。为什么呢，不是说我们不应该使用继承关系来实现吗？</p>
</blockquote>
<p>​	这里我们就需要来进行一些实际的分析了。首先我们应该明白，事实上在实际设计中，能够完全符合设计模式原则的项目是少之又少的，各个模式的具体应用落到项目中后，不免会发生一些变形，就比如这里。我们所有的类都是由Compontent类出来的，为什么呢？</p>
<p>​	这里其实就考虑了一个我们接口设计规范方面的问题了。在我们最理想的设计下，我们是期望我们的抽象装饰类是不依赖于这个Compontent类的。我们期望我们的封装类只包含对应的抽象构建类指针和对应的接口。我们实际上也完全可以这么做，但是我们这里为什么还是将这个装饰类从抽象构建类继承下来的呢。这里就是我们前面提到的接口规范。</p>
<h3 id="接口规范"><a href="#接口规范" class="headerlink" title="接口规范"></a>接口规范</h3><p>​	这我们一个项目的接口规范设计中，这个一般是需要在项目初期就进行确定的。但是吧，如果是手动去规定一个个类中的命名格式，其实是很不切实际的，毕竟这么做的工作量很大，而且一不小心就会出错。所以这里我们就考虑通过继承这种强耦合来实现我们整个装饰模式的接口规范。</p>
<p>​	我们前文已经提到，我们在装饰模式中，需要尽可能的实现装饰前类和装饰后类都尽可能的对用户<strong>透明</strong>。这种透明其实可以简单的理解为:通过学习一个类的api方法，我们基本可以通过同名api调用对应的所有类似的类，或者说继承下来的类以及那些通过设计模式实现的具有层次关系的类。这个就是我们的接口规范所能能做到的事。而这里巧妙的运用了继承这种前耦合的关系来进行设计，大大简化了设计的难度。</p>
<h3 id="妥协"><a href="#妥协" class="headerlink" title="妥协"></a>妥协</h3><p>​	对于这个抽象构件类，既然我们在这个装饰模式的设计中，我们需要其作为我们的接口规范，那么我们就还需要对其进行一些属性的限定。在这个抽象构件类中，我们一般需要为其添加任何成员变量，对于不必要的api，我们都不予以实现，一般的api都使用纯虚函数进行限定。通过一系列的规则设置，我们能够了解到这个接口类的规范以及系列子类的接口，大大简化了设计难度以及了解难度。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>​	我们回来对这个结构进行分析，其实我们可以看到，这种继承的妥协是十分<strong>优雅</strong>的。你看，从抽象构建类中继承下来的具体构建类以及抽象装饰者类中都将具有相同的接口，那么，在我们的抽象装饰者类中，我们就已经可以对于接口进行一层最简单的装饰了，就是在这个装饰者类中的同名函数去调用我们的成员指针所拥有的成员函数。这种对于默认行为的简单规定，将给我们这个抽象装饰类的具体装饰子类的设计省去很多麻烦。</p>
<p>​	<em><strong>多优雅吧，你看。</strong></em></p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><blockquote>
<p><em><strong>所有的代码和文档我都会放在另外一个仓库里，自行访问我的gitHub账号获取</strong></em></p>
</blockquote>
<h3 id="抽象构件类"><a href="#抽象构件类" class="headerlink" title="抽象构件类"></a>抽象构件类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//战士的基类    </span></span><br><span class="line"><span class="comment">//抽象接口类，以及一些十分基本的属性，这些不会很影响原则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solider</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solider</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Solider</span>(string name):<span class="built_in">m_name</span>(name)&#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_name;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fight</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Solider</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string m_name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这个是我们上面那个类图中的<strong>抽象构件类</strong>层次。在我这个类中，我添加了一个成员属性去进行标识，其实这个属性你完全可以丢到等下的子类中，不过丢到这里也无伤大雅了。需要注意的是，如果你一定要添加一些属性在这个抽象基类中，那么这些个属性应该是一些相对简单的，可以通过简单的方法进行操作的，所有比较复杂的操作都不应该被放到基类中。</p>
<p>​	可以看到，我们这里保留了几个虚方法，在这个层次下定义的虚方法将是所有子类中所需要实现的属性，也就是说，通过在抽象基(母)类中去定义抽象方法，我们可以去规定所有的子类所必须实现的一些属性，无论对应的实现类中是否还添加了自己的方法。</p>
<h3 id="抽象装饰类"><a href="#抽象装饰类" class="headerlink" title="抽象装饰类"></a>抽象装饰类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//恶魔果实基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">evil</span>: <span class="keyword">public</span> Solider</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSolider</span><span class="params">(Solider* solider)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_solider=solider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Solider* m_solider=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这个其实就是我们类图中的<strong>抽象装饰类</strong>层次。可以看到，在抽象装饰类中，我们只是添加了一个父类的指针。其实我们还可以对这种架构进行进一步的分析。</p>
<p>​	我们其实可以把装饰类和构件类先组合到一起，如果这样的话其实就是继承下的功能扩展，而且前面的缺陷也已经提到过了就不再赘述。这里之所以将抽象装饰类给它分离出来其实就是为了贴合我们三原则中的<strong>单一职责原则</strong>，我们等下再结合下面再进行分析。</p>
<p>​	其实在这个抽象装饰基类中，我们还可以在这个层次中去添加一些方法，如果添加了这些个方法，那么这些个方法将会像抽象装饰类和一层的具体构件类继承抽象构件基类方法一般去继承抽象装饰类的方法。不过由于层次间的隔离，所以这些由抽象装饰类派生出来的子类的方法的顶层只是抽象装饰类。因此，为了保证接口规范，如果我们一定需要在抽象装饰类中去添加方法的话，我们需要保证这些方法的接口应该跟我们抽象构件类的接口相似。而且由于<strong>单一职责原则</strong>，所有的这些类的功能应该是比较单一的，所以不应该出现接口功能会相差很大导致需要我们去在抽象装饰类中去添加属性的情况。</p>
<blockquote>
<p>​	在抽象装饰类中，我们需要做的其实就是明确我们需要添加的方法。如果必要时，为了可读性，我们应该在抽象装饰类中去添加当前层次的上层需要我们实现的函数，以避免我们需要逐层往上去寻找所有需要实现的方法。</p>
</blockquote>
<h3 id="具体构件类"><a href="#具体构件类" class="headerlink" title="具体构件类"></a>具体构件类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//黑胡子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teach</span> : <span class="keyword">public</span> Solider</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> Solider::Solider;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout&lt;&lt;m_name&lt;&lt;<span class="string">&quot; with great power.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这个类对应了我们UML类图中抽象构件类下的第一层的<strong>具体构建类</strong>，这个类规定了我们的一个基础具体构建的属性，在这个类中，我们除了必须要去实现抽象类方法以外，我们还可以对属性进行添加，因为这里的性质就是对应着我们生活中的产品。当然，在这种架构下，在这个类中添加的属性是不会被装饰类中所发现的(如果你不去专门的通知的话)。</p>
<blockquote>
<p>​	因此，在这一层次的具体构件类中去添加属性得慎之又慎</p>
</blockquote>
<p>​	即使我们添加了属性，这个属性由于单一职责原则也不应该脱离我们整个类的设计初衷，所以这些属性应该与我们的抽象基类方法之间存在着一些互动。</p>
<h3 id="具体装饰类"><a href="#具体装饰类" class="headerlink" title="具体装饰类"></a>具体装饰类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暗暗果实</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DarkFruit</span>:<span class="keyword">public</span> evil</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> evil::Solider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_solider-&gt;<span class="built_in">fight</span>();</span><br><span class="line">        cout&lt;&lt;m_solider-&gt;<span class="built_in">getName</span>()&lt;&lt;<span class="string">&quot;eat darkfruit,has dark ability.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">warning</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">warning</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;m_solider-&gt;<span class="built_in">getName</span>()&lt;&lt;<span class="string">&quot; you ate dark fruit,and you can&#x27;t move when you using ability.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这个类的层次就是我们前面的<strong>具体装饰类</strong>，这个类中，我们需要去实现所有的由抽象构件基类与上层抽象装饰类需要我们去实现的方法。不过，如果我们设计的架构良好，我们将不必去关注我们的上层到底存在了多少层套娃，只需要去关心最近一层的方法接口，这里的设计其实存在一点注意的细节，就是由于我们的抽象装饰类是抽象类，所以其中可能还一些来自抽象构件类的可以实现的方法，我们需要在子类中去实现这些可能存在的方法。当然，在一般的项目中，这些应该有一些清晰的指引的。</p>
<p>​	在这里我们就没有对抽象装饰类进行方法的再一次扩充，所以我们可以看到这里我们只需要实现我们抽象构件类要求的方法即可。除此之外，我们可以看到我们的具体装饰类中其实实现了自己的方法，其应用在了要求实现的接口中。这里其实装饰器类的核心，正是这里的嵌套调用起到了装饰的作用。</p>
<blockquote>
<p>​	对于这里，我们举出的其实就只是一些输出的例子。那么如果存在数据处理方面的要求时我们需要怎么做呢？</p>
</blockquote>
<p>​	在设计中，我们其实不想要我们期望的数据本身被修改，在这里就是我们的抽象构件基类中元素name，但是我们还是需要对这些数据进行处理的话，我们势必就需要一些副本来进行数据的处理的，在一些代码中，你可以看到是在抽象装饰基类中去进行一些成员的拷贝再在具体装饰类中去进行对应的操作的。这其实是取决于我们的具体装饰类的行为，如果我们具体装饰类行为普遍需要数据操作，那么我们就会考虑在基类中去添加对应的方法。但如果只是特殊的几个元素，自然也就没必要在基类中去声明了，只在特定的类中去修改即可。</p>
<blockquote>
<p>由于我还没去理解网络传输，我不太敢确定具体的传输过程，不过我可以应用一下这个场景。就是说你这个数据说是通过协议来进行了传输，但是你本地还是保留了你要传输的数据的。也就是说，你在这里传输数据的过程中，你至少是会对一些数据进行保护的，这里最浅显来看就是我们本地的要传输的数据始终是在本地有一份的。也就是说，这种多层的装饰，一般始终会对上一层的数据进行保护，不会直接去修改原本的数据，即使要使用，要修改，一般也只会涉及到副本。</p>
</blockquote>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">text</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Teach* obj=<span class="keyword">new</span> <span class="built_in">Teach</span>(<span class="string">&quot;黑胡子&quot;</span>);</span><br><span class="line">    obj-&gt;<span class="built_in">fight</span>();</span><br><span class="line">    evil* dark=<span class="keyword">new</span> DarkFruit;</span><br><span class="line">    dark-&gt;<span class="built_in">setSolider</span>(obj);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;===========&quot;</span>&lt;&lt;endl;</span><br><span class="line">    dark-&gt;<span class="built_in">fight</span>();</span><br><span class="line">    <span class="keyword">delete</span> dark;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;===========&quot;</span>&lt;&lt;endl;</span><br><span class="line">    obj-&gt;<span class="built_in">fight</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>​	通过上面那些，我们其实可以了解到装饰模式下的一个本质</p>
<blockquote>
<p>​	一个对象，只有经历过装饰了，那么它才能够具有这个装饰类的属性。如果我们将这个装饰类给从这个装饰完的类中剥离出来，那么这个类将会失去这些被赋予的属性。</p>
</blockquote>
<p>​	上面那个测试程序中就体现了这一点，我们使用了抽象构件进行了一个具体对象的构建，这个对象的输出也只是这个实现类对应的自己的方法，然后我们通过这个构件去为其调用具体装饰类的构建，通过调用对应的同名接口，我们可以看到其产生了不同的行为。接下来，我们将这个装饰类给他删除了并重新调用了具体构件类的方法，可以看到这个类输出的还是进入装饰类之前的方法。由此也证明了上面的那句话。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑胡子 with great power.</span><br><span class="line">===========</span><br><span class="line">黑胡子 with great power.</span><br><span class="line">黑胡子eat darkfruit,has dark ability.</span><br><span class="line">黑胡子 you ate dark fruit,and you can&#x27;t move when you using ability.</span><br><span class="line">===========</span><br><span class="line">黑胡子 with great power.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2024/12/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>​	<em>本文将进行结构性模式的外观模式的分析</em></p>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>​	为子系统中的一组接口提供一个统一的入口。外观模式定义类一个高层系统，使得下层的子系统更加容易使用。在外观模式中，外部与一个子系统的通信可以通过一个统一的外观对象进行。外观模式又叫做门面模式，它是一种对象结构型模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>​	外观模式跟装饰模式在一些属性上有点类似。从名字上也可以窥见一些东西，所谓装饰和外观，在显示生活中就是一种对于事物进行进一步的修饰。装饰模式是通过关联关系去给现有的事物进行一层修饰去给其添加一些属性。就比如我们穿衣服这个动作给我们添加了衣服这个属性。以此类推，外观模式在生活中的体现就是对现有一层修饰。在外观模式中，我们会对现有的方法进行外包装，让其变得易于使用。</p>
<p>​	先举一个现实生活中的外观模式的例子吧。就比如显示中你如果要去冲一杯茶，你如果是自己沏的话，你就需要经历选茶叶，过一遍茶水，倒茶水等众多步骤，这是由你自己进行的沏茶的这个行为所需要的步骤。而你如果去外面茶馆喝茶，你只需要提出需求，交出对应的费用，让小二给你上茶即可，你就不必去费心费力去沏一杯茶。在设计模式中，外观模式的目的与现实中这个茶馆存在的意义有些类似，就是去方便那些不愿意自己沏茶的人，去给这些想要方便的人提供一个更加简便的获取方式。</p>
<p>​	抽象茶馆的行为，我们可以看到这沏茶的中间步骤每一步都是一个行为，抽象到程序中每个行为就是一个行为类。而茶馆这个东家则是最大的行为类，它负责的就是给我们的用户提供一些接口，在这里就是提供一个茶给我们用户，而且我们顾客不再需要去关注这个背后的步骤到底是什么，到底需要先做哪个后做哪个，我们只需要付出相应的代价，就能够获取我们需要的商品。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>​	我们再对外观模式进行一下总结，外观模式的存在意义就是给现有的一系列复杂的步骤进行一次外部的封装并提供一个简单的接口，用户通过提供一些简单的参数供给可以调用这个接口，通过对这个接口的调用用户可以实现一些复杂的功能但是却不用去关注这些复杂功能的实现</p>
</blockquote>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2024/12/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/6983a8f93a172d723e31bd05cc3ae005.png" alt="img"></p>
<p><strong>简单找了一个UML类图来进行分析，简单但是很好的体现了外观模式下的UML架构</strong></p>
<p>​	可以看到，这里运用了一个抽象基类作为第二层具体构件类的父类，这个的抽象类的作用我们在前面装饰模式中一起分析过了，主要就是起到一个<strong>接口规范</strong>的作用，没什么好说的。</p>
<p>​	接下来看到由接口规范派生出的一系列的子类，可以看到，每一个都具有相对简单，单一的功能，符合了三原则的单一职责原则。主要来看我们下面的这个Computer类。在这个类中，我们可以看到这里使用了一个组合关系来进行该类的创建。从Computer类的成员的属性也可以看出，这个是与当前类的生命周期所挂钩的。</p>
<p>​	其实这里是否要使用组合来创建还是得看具体的设计，不过一般来说使用外观模式的话都是需要使用组合的。毕竟你想，我们使用外观来设计，就代表着这个外观之下的逻辑是相对复杂且精密的。既然这样，我们不应该允许用户能够随意的去访问这些子系统，毕竟这样的随机访问对于整个系统架构来说是存在较大的风险的。总之，注意使用环境，必要时再去使用聚合来构建关系对象。</p>
<p>​	主要来看这个Computer类的start函数，此时我们也可以感觉到一个接口规范的好处了，通过一个接口规范，我们可以保证在这个类图上的所有的具有相似功能的接口都能够保证接口的一致性以简化设计以及理解，不然你这里写个函数名是start那里写个函数名是open，那我还得费劲去了解你的源码，麻烦滴很啊。</p>
<p>​	我们这里就不给出代码示例了，因为这个外观模式确实很简单。我们简单来说一个这里的Computer类的start函数将会是一个怎么样的构造。在这个层次架构中，Computer类是直接与外界用户层所交互的，当外界调用start函数时，我们的期望是一个计算机能够被正确的启动，所以我们的这里的start函数就应该包含所有的应该被启动的硬件的start方法。通过这种包装，我们能够实现对于一个复杂操作的简单化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Computer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;CPU.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;Disk.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;Memory.<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这就是一种可能存在的代码顺序，当然，实际顺序并不重要，重要的是你需要去理解这里为什么需要这个外部类来进行这些操作的封装，以及这些封装的内生逻辑，这些才是外观模式的核心。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>​	外观模式是一个相对简单的结构型设计模式，但是它的使用频率也是相当高的，你可以把它类比为创建型模式中的原型模式，这你就应该知道为什么这么高了吧。</p>
<blockquote>
<p>差不多了，风紧扯呼~~~</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2024/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>运用共享技术有效地支持大量细粒度的对象。其目的是通过共享对象来减少内存的使用，尤其是当系统中有大量相似对象时，享元模式可以帮助减少对象的创建，从而降低系统的内存消耗。</p>
</blockquote>
<p>​	具体来说，享元模式将对象的<strong>共享部分</strong>和<strong>不共享部分</strong>分开，尽可能地将重复的对象共享，而将每个对象的<strong>独立部分</strong>(外部部分)保留在每个实例中。</p>
<span id="more"></span>

<h3 id="关键要素分析"><a href="#关键要素分析" class="headerlink" title="关键要素分析"></a>关键要素分析</h3><h4 id="内部状态与外部状态："><a href="#内部状态与外部状态：" class="headerlink" title="内部状态与外部状态："></a><strong>内部状态与外部状态</strong>：</h4><ul>
<li><h5 id="内部状态（Intrinsic-State）："><a href="#内部状态（Intrinsic-State）：" class="headerlink" title="内部状态（Intrinsic State）："></a><strong>内部状态（Intrinsic State）</strong>：</h5><p>​	可以共享的、不变的部分。例如，字体、颜色、形状等不随对象变化而变化的属性。</p>
</li>
<li><h5 id="外部状态（Extrinsic-State）："><a href="#外部状态（Extrinsic-State）：" class="headerlink" title="外部状态（Extrinsic State）："></a><strong>外部状态（Extrinsic State）</strong>：</h5><p>每个对象独有的、可能会变化的部分，例如位置、大小等。</p>
</li>
</ul>
<h5 id="共享对象："><a href="#共享对象：" class="headerlink" title="共享对象："></a><strong>共享对象</strong>：</h5><p>​	享元模式通过共享内部状态的对象来减少内存消耗。客户端只需要维护外部状态，内部状态由共享的享元对象提供。</p>
<h5 id="享元工厂（FlyweightFactory）："><a href="#享元工厂（FlyweightFactory）：" class="headerlink" title="享元工厂（FlyweightFactory）："></a><strong>享元工厂（FlyweightFactory）</strong>：</h5><p>​	负责管理享元对象的创建和共享。它维护一个缓存池，避免重复创建相同的享元对象，只有在享元对象不存在时才会创建一个新的对象。</p>
<hr>
<h2 id="目的分析"><a href="#目的分析" class="headerlink" title="目的分析"></a>目的分析</h2><p>​	还是得结合现实来进行一些分析，在生活中，存在一些场景需要我们去使用一些<strong>重复</strong>的对象或者具有<strong>高相似度</strong>的对象，在这种需求下，我们如果去给这些对象都进行一个完整的构造，(换句话说，我们如果想要对这些个对象进行各自数据的一套构建) 将会是很费时费力的。</p>
<p>​	这里我们引用C++中类的一个特性来说明:<strong>类的静态(static)成员</strong></p>
<p>​	我们知道，在类的设计中，我们如果将一个成员的属性声明为了<strong>static属性</strong>，那么这个成员将会是在这个类实现出的所有类中共享的。通过这个属性的声明，我们能够实现类对于这个成员属性的共享。同时，这个属性也不会在派生出的类中进行创建。</p>
<blockquote>
<p>​	题外话，你如果读过CSAPP你就应该知道这个静态成员会被储存在哪里。其实就是我们可执行文件中的.bss段。所有的实例类中应该都保留着这块内存区域的一个引用以提供对于这个静态成员变量的访问。</p>
</blockquote>
<p>​	从上面我们初步了解了享元模式下的一个基本性质，就是实现对于一些类属性的共享。当然，在我们的享元模式中，一般不指这些通过静态成员的实现。在具体实现中，我们是将这种属性应用到了更复杂的场景之中。这时如果使用一个静态成员来设计的话会导致设计上面的麻烦，所以我们考虑将这些应该被共享的属性放于一个类中并进行管理。</p>
<h3 id="无端猜测"><a href="#无端猜测" class="headerlink" title="无端猜测"></a>无端猜测</h3><blockquote>
<p>​	虽然我还没有深入去了解这个的应用场景。不过我想进行一些合理的猜测，在实际应用这种，我们这些共享类的创建如果比较严格，要求不能够被随便复制出去的话，可能考虑使用一个<strong>单例模式</strong>来创建这些个共享类。如果这些属性需要被频繁的修改以及被一些类给单独拿出进行使用，那么可能使用<strong>原型模式</strong>来设计共享类。</p>
</blockquote>
<p>​	</p>
<blockquote>
<p>​	话说回来，我们还是来系统的说明下襄垣模式的目的吧。我的问题就是在学一个东西时总是会发散出去，想当初学一节CSAPP的课就为了了解这了解那一个半小时的课硬是给我用了一个晚上和一个早上。</p>
</blockquote>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ol>
<li><strong>减少内存消耗</strong>：通过共享相同的对象，避免了每次创建相同对象的内存开销。</li>
<li><strong>提高性能</strong>：减少了重复对象的创建，降低了对象的实例化时间。</li>
<li><strong>控制细粒度对象的数量</strong>：享元模式适用于需要大量细粒度对象并且这些对象大部分具有相同状态的场景。</li>
</ol>
<h2 id="美图"><a href="#美图" class="headerlink" title="美图"></a>美图</h2><p><img src="/2024/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/flyweight-zh.png" alt="享元设计模式"></p>
<hr>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><h3 id="第一类图分析"><a href="#第一类图分析" class="headerlink" title="第一类图分析"></a>第一类图分析</h3><p><img src="/2024/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/edd2f30924f44ff6bae0bd259202b9c9.png" alt="img"></p>
<blockquote>
<p>​	让我们来分析下这个类图中的层次</p>
</blockquote>
<p>​	这个类图其实只是实际享元模式中的一个层次，即享元类的创建，不过这个图能够帮助我们很好的一步步理解具体的享元模式下的架构，我们先来分析下这里的功能。这个类图中的功能其实就只是在具体的享元模式中去负责享元类的创建，至于享元类在其他类的运用，并没有在这个图中显示出来。</p>
<p>​	在这个类中，<strong>BlackPiece类</strong>和<strong>WhitePiece类</strong>就是我们的俩种享元类。其实这个类图还可以进行优化，我们看到这俩个类其实具有相同的成员，也就是说，这俩个其实都可以归档到一个父类进行管理以及接口规范的，不过这里还行了，你可以自己去画一个类图。</p>
<p>​	我们来看，在这种类图中，我们其实不是直接通过享元类去进行创建的。相反，我们是通过一个工厂类来进行这些享元类的生产的。其实给出这个类图后你就应该了解这个工厂存在的意义了。毕竟，如果你都需要使用享元类了，就意味你不免需要创建大量的相似对象，你只是使用了结构性模式去进行这些对象的建构，但是这些对象的生产呢?这里是设计模式的<strong>建造者模式</strong>中需要去管理的。我们需要注意的是，对于系列的设计模式之间，其并不是相互割裂的，相反，它们的关系极其紧密。</p>
<blockquote>
<p>​	这里我对工厂的猜想是一般不会用到抽象工厂，一般的话应该使用工厂模式即可，不过还是那句话，依照现实需求去进行设计。这里直接使用简单工厂来画也无所谓，只是为了说明这种建造模式是可行且可取的。</p>
</blockquote>
<h4 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h4><p>​	在这里，我们存在着多种享元类，这些享元类具有着相同的外部属性，但是这些属性内部的实现可能有所不同，就比如在游戏中的子弹，可能伤害高点，可能伤害低点，依照这种差异化进行从抽象父类的派生。</p>
<p>​	接着，我们需要对这些个享元基类进行一些实例化。虽然说享元基类是为了减少实例化而产生的。但是，这里的工厂创建其实是为了适配现实生活中的场景的。毕竟，即使你再很多地方不用去进行享元基类的再创建，但是你在一些应用场景下你还是需要去对其进行批量再创建的，这里就需要我们的建造型设计模式了，上面说了一些，不再扩展。当然，你也可以不使用<strong>工厂</strong>，依照现实需求，你甚至可以对这些个享元基类进行<strong>单例模式</strong>的使用。</p>
<blockquote>
<p>​	总之，这上面这个类图，其实是为了进行享元模式中的享元类的构建，接下来，我们再看一个类图。</p>
</blockquote>
<hr>
<h3 id="第二类图分析"><a href="#第二类图分析" class="headerlink" title="第二类图分析"></a>第二类图分析</h3><img src="/2024/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/image-20241222204418259.png" alt="image-20241222204418259" style="zoom:80%;">

<blockquote>
<p>​	这里我们就不对那些之前分析过的进行分析，我们只来看这里的享元基类与实际对象之间的关系。</p>
</blockquote>
<h4 id="享元类与构件类"><a href="#享元类与构件类" class="headerlink" title="享元类与构件类"></a>享元类与构件类</h4><p>​	可以看到，它们之间是通过一个聚合关系来进行连接的，这其实也符合享元模式的设计思路。享元模式希望这些享元类是一些相对静态的数据。那么，我们不应该希望这些个享元被挂载到特定的构件类中导致这俩的声明周期被绑定。简单说吧，通过聚合关系而不是组合关系能够更符合我们生产环境中对于享元模式中的管理。</p>
<p>​	额外注意到一点，在这个类图中，其实享元类的生命周期是被工厂类所管理的。由工厂类去管理是否要生产享元类，同时，由工厂类来进行这些享元类的实际分配。通过这种职责的分离，各个类功能进行进一步的解耦，更加符合单一职责原则。</p>
<p>​	</p>
<blockquote>
<p>​	好了，其他的其实就没有什么好说的，你应该也能够看懂，该上代码了。</p>
</blockquote>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><blockquote>
<p>​	<strong>在设计模式的搓代码过程中，慢一点，跟着搓，去逐层建构其整个设计模式下的层次逻辑，能给让你对整个的理解更加深入。</strong></p>
</blockquote>
<hr>
<h3 id="享元基类"><a href="#享元基类" class="headerlink" title="享元基类"></a>享元基类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//享元模式的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightBody</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FlyweightBody</span>(string sprite):<span class="built_in">m_sprite</span>(sprite) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FlyweightBody</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y ,<span class="type">int</span> speed)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>= <span class="number">0</span>;<span class="comment">//重绘精灵图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string m_sprite;    <span class="comment">//精灵图</span></span><br><span class="line">    <span class="comment">//string color;    //颜色</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这个类定义了我们整个享元类的基本属性，定义了接口规范等，老生常谈的东西，这里就不再赘述，自己看吧。</p>
<hr>
<h3 id="享元子类"><a href="#享元子类" class="headerlink" title="享元子类"></a>享元子类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//享元类的子类-共享的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedBombBody</span> : <span class="keyword">public</span> FlyweightBody &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> FlyweightBody::FlyweightBody;</span><br><span class="line">    ~<span class="built_in">SharedBombBody</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y ,<span class="type">int</span> speed)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt;m_sprite&lt;&lt;<span class="string">&quot;以每小时&quot;</span> &lt;&lt;speed&lt;&lt;<span class="string">&quot;的速度飞到了(&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;)处&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前在(&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;)的位置处重绘了&quot;</span>&lt;&lt;m_sprite&lt;&lt;<span class="string">&quot;弹体...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//享元类的子类-不共享的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniqueBombBody</span> : <span class="keyword">public</span> FlyweightBody &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> FlyweightBody::FlyweightBody;</span><br><span class="line">    ~<span class="built_in">UniqueBombBody</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y ,<span class="type">int</span> speed)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_sprite&lt;&lt;<span class="string">&quot;以每小时&quot;</span> &lt;&lt;speed&lt;&lt;<span class="string">&quot;的速度飞到了(&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;)处&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前在(&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;)的位置处重绘了&quot;</span>&lt;&lt;m_sprite&lt;&lt;<span class="string">&quot;弹体...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这个其实页没有什么好说的，就是一个具体的享元类，定义了这类享元所应该有的属性。</p>
<p>​	需要注意的是，我们派生出来的这些享元类之间的属性应该是存在差异的，就比如，一个可能是共享的，一个可能是不共享的。可能还是抽象了点。换句话说吧，在**&lt;&lt;葬送的芙莉莲&gt;&gt;**（我缺的第二季这块快点给我端上来啊！！！！！）中的宝箱。这其中一些可能包含了一些魔导书，可能包含了一些装备，当然，也有可能是宝箱怪。但是，这些都是宝箱，而且，这些都是会在异世界世界观下普遍出现的事物。这里的就跟享元模式的应用环境很像了。</p>
<hr>
<h3 id="享元挂载类"><a href="#享元挂载类" class="headerlink" title="享元挂载类"></a>享元挂载类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发射炮弹，享元类挂载的大类，复杂的实际对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LaunchBomb</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LaunchBomb</span>(FlyweightBody* body):<span class="built_in">m_body</span>(body) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">LaunchBomb</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSpeed</span><span class="params">(<span class="type">int</span> speed)</span> </span>&#123;</span><br><span class="line">        m_speed = speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        m_x = x;</span><br><span class="line">        m_y = y;</span><br><span class="line">        m_body-&gt;<span class="built_in">move</span>(m_x,m_y,m_speed);  <span class="comment">//调用享元类的方法,统一接口的思想</span></span><br><span class="line">        <span class="built_in">draw</span>();  <span class="comment">//调用享元类的方法,统一接口的思想</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_body-&gt;<span class="built_in">draw</span>(m_x,m_y);  <span class="comment">//调用享元类的方法,统一接口的思想</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FlyweightBody *m_body;</span><br><span class="line">    <span class="type">int</span> m_speed=<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> m_x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m_y=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	这里就是对应的享元类挂载的地方，在这其中其实包含的是一些相对统一的方法。而且事先声明一点，在稍微复杂一点的设计中，这种类可能是不止一个的。这样类比吧，我这里其实是吧那些个宝箱怪，具有各种奖励的宝箱都归纳到了这个类中，并没有赋予具体的属性，在实际的设计中，对于这些宝箱怪，武器宝箱等，一般是存在各自独立的类来进行挂载的，这里只是为了简单而编写的，别被我限定了思路。</p>
<p>​	回来看到这个类中，我们可以看到在这个类中存在着一些自己的方法，其实这些方法你看起来有没有点眼熟。是不是有点像之前的外观模式中的封装。事实上也确实，你想啊，当你打开一个宝箱时，你知道里面发生了什么吗，不知道吧，你只是看到了最后的一个结果。当然，打住，这方面不再深入。</p>
<blockquote>
<p>​	<strong>总之，对于这个类，我们需要注意的是，这一系列类其实就是对应的享元类的具体使用实现，这些类是使用享元类的外层，是我们用户层所直接接触到的东西</strong></p>
</blockquote>
<hr>
<h3 id="享元工厂类"><a href="#享元工厂类" class="headerlink" title="享元工厂类"></a>享元工厂类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//享元简单工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BombBodyFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BombBodyFactory</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">//工厂类的析构函数  由工厂类来对享元类的对象进行管理释放</span></span><br><span class="line">    ~<span class="built_in">BombBodyFactory</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_map.<span class="built_in">begin</span>();it != m_map.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">            <span class="keyword">delete</span> it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        m_map.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FlyweightBody* <span class="title">getFlyweightBody</span><span class="params">(string key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_map.<span class="built_in">find</span>(key) == m_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            FlyweightBody* body = <span class="literal">nullptr</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;创建新的&quot;</span>&lt;&lt;key&lt;&lt;<span class="string">&quot;对象&quot;</span>&lt;&lt;endl;</span><br><span class="line">            body = <span class="keyword">new</span> <span class="built_in">SharedBombBody</span>(key);</span><br><span class="line">            m_map[key] = body;</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;正在复用&quot;</span>&lt;&lt;key&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> m_map[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    map&lt;string,FlyweightBody*&gt; m_map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	<strong>这个类其实是我认为这些类之中最有理解难度的一个类了。</strong></p>
<h4 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h4><p>​	看到这了，我们先停下来，你还记得住前面我们讲的层次吗，我们再来梳理一遍。</p>
<blockquote>
<p>​	首先，这些类最底层的，应该是我们的享元抽象类，这个抽象类管理者享元类的基本属性以及接口规范</p>
<p>​	然后，是我们的具体享元类，这些类定义了我们具体的享元属性。例如，宝箱怪属性，武器箱属性</p>
<p>​        再然后，是我们的享元挂载类，这是一系列享元实例化的地方。为什么要说实例化，因为一般来说，单独的享元类是没有使用的    价	值的，只有将这些属性添加到实际的事物上它才有使用的价值。</p>
<p>​	最后就是我们现在要讲的享元工厂类了。</p>
</blockquote>
<hr>
<blockquote>
<p>​	<strong>当然，我们这里讲的不是整个的层次，你看层次还是得看UML类图，这里只是说的我的顺序。叠个小甲</strong></p>
</blockquote>
<p>​	来进入这个工厂，这个工厂的外部功能其实很清晰，而且由于我们已经学完了工厂模式，所以我们看过去就知道这个工厂打的怎么工作的，所以我们看到这个工厂中最有意思的一个地方。就是这里的成员变量 <strong>map&lt;string,FlyweightBody*&gt; m_map;</strong> </p>
<p>​	这里最有意思的地方就是这里的<strong>键值对</strong>，这里的第二个成员是我们的抽象享元基类指针，这意味着什么，意味着我们可以对其进行内存的管理。而我们回想一下工厂的功能是什么，就是<strong>生产</strong>我们的实例对象吧。你到这里应该有自己的想法了吧。是的，这里工厂最特殊的地方就是在于<strong>其可以管理所有在这个工厂中生产的享元对象的整个生命周期</strong>，包括从创建一直到死亡。</p>
<p>​	你到现在可能还有点疑惑，没事，等我给出下面的测试代码你就明白了。</p>
<hr>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建三种型号炮弹，每种有若干个对象对该类对象进行复用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BombBodyFactory factory;</span><br><span class="line">    string key1 =<span class="string">&quot;毒气弹&quot;</span>;</span><br><span class="line">    string key2 =<span class="string">&quot;炸弹&quot;</span>;</span><br><span class="line">    string key3 =<span class="string">&quot;彩蛋&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要动态数据，即那些具体发射炮弹的类，就是上面的LaunchBomb类</span></span><br><span class="line">    vector&lt;LaunchBomb*&gt; bombs;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建三种型号炮弹，每种有3对象,2个会对该类对象进行复用</span></span><br><span class="line">    vector&lt;string&gt; keys = &#123;key1+<span class="string">&quot;1&quot;</span>,key2+<span class="string">&quot;2&quot;</span>,key3+<span class="string">&quot;3&quot;</span>,key1+<span class="string">&quot;1&quot;</span>,key2+<span class="string">&quot;2&quot;</span>,key3+<span class="string">&quot;3&quot;</span>,key1+<span class="string">&quot;1&quot;</span>,key2+<span class="string">&quot;2&quot;</span>,key3+<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过工厂类创建炮弹对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> key:keys) &#123;</span><br><span class="line">        FlyweightBody* body = factory.<span class="built_in">getFlyweightBody</span>(key);</span><br><span class="line">        LaunchBomb* bomb = <span class="keyword">new</span> <span class="built_in">LaunchBomb</span>(body);</span><br><span class="line">        <span class="comment">//使用随机轨迹</span></span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            x = <span class="built_in">rand</span>()%<span class="number">1000</span>;</span><br><span class="line">            y = <span class="built_in">rand</span>()%<span class="number">1000</span>;</span><br><span class="line">            bomb-&gt;<span class="built_in">move</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        bombs.<span class="built_in">push_back</span>(bomb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动炮弹</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> bomb:bombs) &#123;</span><br><span class="line">        bomb-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> bomb:bombs) &#123;</span><br><span class="line">        <span class="keyword">delete</span> bomb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建彩蛋</span></span><br><span class="line">    <span class="comment">//可以采取一个工厂类来创建，也可以直接new</span></span><br><span class="line">    FlyweightBody* body = <span class="keyword">new</span> <span class="built_in">UniqueBombBody</span>(<span class="string">&quot;大彩蛋&quot;</span>);</span><br><span class="line">    LaunchBomb* bomb = <span class="keyword">new</span> <span class="built_in">LaunchBomb</span>(body);</span><br><span class="line">    bomb-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">delete</span> bomb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//享元类是与业务类聚合的，业务类的生命周期结束，享元类不一定也就结束了，所以需要手动释放</span></span><br><span class="line">    <span class="keyword">delete</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这个测试程序我就不进行分析了，自己分析去吧。我们主要来看到这个测试程序中的<strong>内存管理</strong>这一块。</p>
<p>​	在这个程序中，我们大部分的享元类都是由工厂创建的，那么也就意味着，这些个享元类在工厂类中都保有一份指针。或者，我们其实可以这么理解，这些享元类是一系列的单一产品，由工厂生产，且只会在工厂内部保留一份。当你想要使用产品时，你去申请对应的使用权，你可以利用这个产品进行一些操作，，但是你无权对于这个产品进行销毁。</p>
<p>​	现实生活中其实存在这种例子，但是我不是很清楚，我能够想到的就是一些公司提供的一些服务。有懂的可以在下面评论区分享。</p>
<p>​	总之，在这种工厂架构下，你无权去对这个产品的声明周期进行管理，这里是可以的，所以这里其实存在一些设计上的巧妙之处，当然巧在哪我也不知道()。也就是说，这个工厂其实还起到了一个屏蔽上下层使用的作用，用户只需要去使用，至于内存管理这方面的细节，其并不需要去关心，自然有人去进行管理。在这里，就是由工厂区进行管理的。</p>
<p>​	当我理解这一点之后，我其实是感觉到很兴奋的，因为<strong>这种设计实在是太妙了</strong>。用户不需要去进行繁琐的可能错漏的一个个享元对象的内存管理(如果存在多个享元类实例的话)。享元类本身其实也不需要去注意它什么时候去死。享元类的内存生命周期被巧妙的绑定到了工厂之上，由工厂直接管理。我们可以在工厂中去定义内存管理上面的细节，就比如工厂(死亡)倒闭时，其中的产品也大多不存在一般，可能是在工厂死亡是被一起析构掉的，也可能是其他。</p>
<blockquote>
<p>​	总的来说，这个架构对于单一职责的遵守，使得整个程序的架构变得很美。这种美是你不去自己搓一遍码，去理解对应的UML图所接触不到的，所以说，看UML类图是设计模式的不可或缺的一环。</p>
</blockquote>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	在享元模式中，存在一些令人兴奋的设计方法，这些方法需要你去进行一定程度的理解。</p>
<p>​	享元模式的重点，如其他模式一般，落在了它的名字之上。</p>
<p>​	<strong>享元二字，重点在享</strong>。通过对于一系列的共有属性的剥离，实现了属性的复用，通过将这种属性的创建和管理对于工厂的委托，实现了资源管理上的优化。不仅使得属性得以很大程度上的复用，还是得用户不用去担心内存管理上的细节。</p>
<hr>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2024/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><blockquote>
<p>由于一些原因，我需要先学观察者模式，其实就是我需要这个模式去进行课设()</p>
</blockquote>
<hr>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><blockquote>
<p>​	其实所有的设计模式如果只是在看的阶段去过一遍你的感触其实不会很深。相反，如果你在设计中因为一些设计导致出现了一些问题，需要一些设计模式来进行弥补的话，这种学习将会是很深刻的。当然啦，你如果一点设计模式都没有学过，你其实都不会意识到你需要这些设计模式。</p>
<p>​	所以，在我的设想中，一个设计模式好的学习流程应该是先去系统的学一学一些设计模式，就比如创建型设计模式中的几种，然后去进行使用，在使用的阶段你其实不时就会发现你的创建型设计模式和结构型设计模式通常会出现一些问题。或者吧，也可以先依照设计模式的三原则去进行设计架构，然后你一定会发现使用三原则的话会导致的一些疑惑的。</p>
<p>​	就比如我的课设，我在进行重构，想要重新规范下三原则中的单一职责原则时，我想要进行数据模块和渲染模块间的解耦，然后发现这种解耦会导致我的渲染操作不知道在哪里调用，这时我就回来看设计模式，发现这种问题可以通过行为模式中的观察者模式来解决，然后我就自我驱动的去学了，这才是一个学习的正反馈过程啊。</p>
</blockquote>
<hr>
<span id="more"></span>

<h2 id="存在意图"><a href="#存在意图" class="headerlink" title="存在意图"></a>存在意图</h2><blockquote>
<p>​	定义对象建一种一对多的依赖关系，当一个对象的状态发生转变事，所有依赖于它的对象都得到通知并且自动更新。</p>
</blockquote>
<p>​	</p>
<h2 id="使用的动机"><a href="#使用的动机" class="headerlink" title="使用的动机"></a>使用的动机</h2><p>​	在实际的设计过程中，我们常常会遇到一个问题。就是当我们对于一个系统进行解耦的时候，我们把它分割为了一系列的模块。就比如，你在原本的设计中设计了一个可以自己实现数据处理和结构渲染的类。现在你要对这个类进行进一步的解耦，我们先不考虑它是怎么解耦的。</p>
<p>​	我们目前需要看的是，这种解耦会出现的副作用，其中最明显的就是在我们解耦过后，我们原本代码中合作的数据处理模块和渲染模块之间无法协调工作了，这是由于类的特殊性导致的，如果使用嵌套类来实现这只新的模块分割倒也是一种解决方案，但是这种设计又违反了我们的开放封闭原则。所以我们需要一种机制来实现这种独立出来的类的联动。当然，是有其他的一些应用场景的，但是我还没碰到过。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>​	就比如我们的数据模块和渲染模块间的联动，我们期望的是当我们数据发生变动时我们能够实时的去反应出这种变化。这在我们原有的一个系统中只需要去在数据变更时去进行对应的渲染代码执行即可。但是我们现在已经不能够直接去调用渲染代码了，但是我们还是需要这个功能。此时就需要一种机制去进行通知对应的渲染模块去进行工作，而观察者模式恰恰好能够充当这个角色。</p>
<p>​	说了这么多其实还是实际项目中的应用情况。我们来举几个生活中的例子。</p>
<p>​	在现实生活中，我们在任何一个视频网站上，通常都有关注这个功能，当我们关注之后，这个博主只要一更新内容，我们如果有对应的设置的话，我们就能收到对应的通知。同时，一个博主可能存在着许多粉丝，相应的，所有这些粉丝都能够收到对应的推送。这就是一种<strong>发布-订阅模式</strong>。在这种模式中，博主和用户这俩个账号是相对独立的。其中是存在着一种机制来进行实时的通知的。正是由观察着模式来实现这种功能。</p>
<hr>
<h2 id="简单概括"><a href="#简单概括" class="headerlink" title="简单概括"></a>简单概括</h2><p>​	在观察者模式中，一般存在着俩种角色。一个是<strong>订阅者</strong>，一个是<strong>发布者</strong>。一个发布者可能有着多个订阅者。但是一般来说一个订阅者对于发布者是一对一的的。当然实际中，你可能会说一个人可以订阅多个博主，但是这也是不冲突的。这用文字是不好进行阐述的，但是你应该能够理解。</p>
<p>​	通过进行观察者模式，我们实现了一种通知机制，在发布者发布一些信息之后，所有的订阅者应该都能够收到对应的信息。至于订阅者收到这个信息后会进行一个什么样的处理，这个是观察者模式中不关注的。</p>
<blockquote>
<p>​	在观察者模式中，最重要的就是通知机制。这个会在接下来的UML类图中去进行分析。</p>
</blockquote>
<hr>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2024/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/eb9aece31234e8ef95f7e2e0399e5915.png" alt="img"></p>
<blockquote>
<p>观察者模式的UML类图是需要重点分析的，需要重点理解的就是观察者模式中的通知机制。</p>
</blockquote>
<p>​	这里我们将只进行抽象发布者类和抽象订阅者类的分析，其他的子类都不是很重要。</p>
<p>​	首先可以看到在途中ConcreteObserver和ConcreteSubject是一个互相聚合的关系。我们就是通过这种互相聚合来实现通知机制的。</p>
<p>​	</p>
<h3 id="ConcreteObserver类"><a href="#ConcreteObserver类" class="headerlink" title="ConcreteObserver类"></a>ConcreteObserver类</h3><p>​	这个类就是我们对应的观察者类。这个设计中使用了一个name作为信息的接收。当然，这个成员也可以是订阅者的名字，不过这个不重要。主要是看到另外的一个成员，一个指针链表，在这个指针链表中，储存的是当前观察者对应的发布者的指针。也就是说，在订阅者的属性中，是存在一个成员用于管理发布者的信息的。其实你应该很可以理解这个存在的意义，就比如你社交软件中关注的博主。这个其实就是你对应的发布者。订阅者可以通过这个list链表去找到其的订阅者信息并以此进行通知操作。</p>
<p>​	这个其实就是一个对于前面一对多的扩展，实现了一个人可以同时关注多个博主的功能。当然，这里的信息处理事很薄弱的。</p>
<blockquote>
<p>​	还需要来进行着下面的系列成员函数的分析。</p>
</blockquote>
<h4 id="addSubject函数"><a href="#addSubject函数" class="headerlink" title="addSubject函数"></a>addSubject函数</h4><p>​	这个函数的作用其实就写在明面上了，就是添加我们的订阅者，通过一个指针去实现对于发布者的添加，实际上就是添加到自己的发布者链表中去进行管理。</p>
<h4 id="deleteSubject函数"><a href="#deleteSubject函数" class="headerlink" title="deleteSubject函数"></a>deleteSubject函数</h4><p>​	这个函数同样很好理解，就是简单的吧我们指定的一个发布者从我们的成员链表中去移除。没什么好说的。</p>
<h4 id="update函数"><a href="#update函数" class="headerlink" title="update函数"></a>update函数</h4><p>​	这个是整个类的核心，用于进行事件的通知，在这UML类图中是体现不出它到底是怎么进行一个通知的，简单来说一下吧，这其实是一个被调用的函数，而且调用对象一般是对应的发布者，发布者能够通过这个接口来进行信息的传递。</p>
<hr>
<h4 id="ConcreteObsertver类"><a href="#ConcreteObsertver类" class="headerlink" title="ConcreteObsertver类"></a>ConcreteObsertver类</h4><p>​	这个类就是我们的发布者基类了，在这个基类中，很多属性都跟订阅者很相似，我们这里就不加以赘述了。这里主要看到一个函数。就是这里的send函数</p>
<h4 id="send函数"><a href="#send函数" class="headerlink" title="send函数"></a>send函数</h4><p>​	这个函数的作用已经写的很明白了，就是发送信息。它的参数就是它的信息。但是UML类图是体现不出发送这种操作的，还是得等等下的代码分析，不过可以简单的说一下，这里的发布信息就是通过对应的成员链表去进行通知，去进行一次链表的遍历，并依次调用每个成员对应的接收信息的方法去进行推送。</p>
<hr>
<p>​	</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>​	在观察者模式中，最重要看的是它的代码，毕竟相对于其他模式，观察者模式在其的UML类图中暴露的信息有限，但是我并不想再进行分析了，我要回去搓我的课设了，所以我要挖一个我可能永远也不会填的坑了。</p>
<p>​	自己分析去吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象观察者（订阅者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string &amp;message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者（订阅者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subscriber</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Subscriber</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> : name(name) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string &amp;message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Subscriber &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; received message: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125; <span class="comment">// 用于识别订阅者</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象发布者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Publisher</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Publisher</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">subscribe</span><span class="params">(std::shared_ptr&lt;Observer&gt; observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">unsubscribe</span><span class="params">(<span class="type">const</span> std::string &amp;observerName)</span> </span>= <span class="number">0</span>; <span class="comment">// 通过标识符移除</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notify</span><span class="params">(<span class="type">const</span> std::string &amp;message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体发布者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsPublisher</span> : <span class="keyword">public</span> Publisher &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Observer&gt;&gt; subscribers; <span class="comment">// 订阅者列表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">subscribe</span><span class="params">(std::shared_ptr&lt;Observer&gt; observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        subscribers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unsubscribe</span><span class="params">(<span class="type">const</span> std::string &amp;observerName)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        subscribers.<span class="built_in">erase</span>(</span><br><span class="line">            std::<span class="built_in">remove_if</span>(subscribers.<span class="built_in">begin</span>(), subscribers.<span class="built_in">end</span>(),</span><br><span class="line">                           [&amp;observerName](<span class="type">const</span> std::shared_ptr&lt;Observer&gt; &amp;subscriber) &#123;</span><br><span class="line">                               <span class="keyword">auto</span> concreteSubscriber = std::<span class="built_in">dynamic_pointer_cast</span>&lt;Subscriber&gt;(subscriber);</span><br><span class="line">                               <span class="keyword">return</span> concreteSubscriber &amp;&amp; concreteSubscriber-&gt;<span class="built_in">getName</span>() == observerName;</span><br><span class="line">                           &#125;),</span><br><span class="line">            subscribers.<span class="built_in">end</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">(<span class="type">const</span> std::string &amp;message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;subscriber : subscribers) &#123;</span><br><span class="line">            subscriber-&gt;<span class="built_in">update</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建发布者</span></span><br><span class="line">    <span class="keyword">auto</span> publisher = std::<span class="built_in">make_shared</span>&lt;NewsPublisher&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建订阅者</span></span><br><span class="line">    <span class="keyword">auto</span> subscriber1 = std::<span class="built_in">make_shared</span>&lt;Subscriber&gt;(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> subscriber2 = std::<span class="built_in">make_shared</span>&lt;Subscriber&gt;(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅新闻</span></span><br><span class="line">    publisher-&gt;<span class="built_in">subscribe</span>(subscriber1);</span><br><span class="line">    publisher-&gt;<span class="built_in">subscribe</span>(subscriber2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布新闻</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Publishing news...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    publisher-&gt;<span class="built_in">notify</span>(<span class="string">&quot;Breaking News: Observer Pattern in Action!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消订阅</span></span><br><span class="line">    publisher-&gt;<span class="built_in">unsubscribe</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次发布新闻</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nPublishing more news...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    publisher-&gt;<span class="built_in">notify</span>(<span class="string">&quot;Update: Observer Pattern Still Relevant!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2024/12/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>最后一种结构型模式了，会赢的</p>
</blockquote>
<p>​	通过代理模式的名字我们也可以了解到这个模式的重要之处就在与这个”代理”二字。我们举几个生活中的例子吧。就比如之前闹的沸沸扬扬的俄乌冲突，其实就是一场代理人战争，乌克兰实际上就是美国的代理人，为什么需要这个代理人呢，因为本人不好下场。换句话说，使用代理人的一般场景就是自己动手的代价是无法接受的，需要通过一种手段来<strong>减少损失</strong>，这就是代理的关键之处。</p>
<span id="more"></span>

<p>​	再举一个较近的例子。就比如我们去打开一个md文档，这个文档可能会很大，其中包含了一系列的数字和图片，如果我们需要一次性的全部打开的话代价是很大的，可能会感觉到明显的卡顿，这是很影响体验的。为了优化这种，我们可以考虑将这里的系列图片给添加代理。在我们打开时我们不需要去创建图片，而是去通知这些个代理我可能用到这些图片，去让这些代理准备好。直到我们真正需要使用图片(观看，下载等)时才去加载对应的数据。</p>
<p>​	其实吧，我感觉我们的内存系统中应该就应用到了<strong>代理</strong>这一概念。让我们想想我们的内存系统是怎么去加载一个程序的。不知道就去学<strong>CSAPP</strong>吧，小子。当我们点击一个可执行文件或者命令行输入一个指令时。程序调取对应的数据段进入主存。那么，也就是说，我们前面在主存之中最多就保留着对于可执行文件的引用而不是完整的文件。这种引用其实就是一种代理。</p>
<p>​	接着来看一下我们的页缺失异常的情况。当发生页缺失时，触发对应的信号，程序中断，控制权交还内核，内核进行复制，复制完成后重新把控制权交给程序这个用户。可以看到，这里的内核其实就相当于一个代理人的角色，其代理了所有的程序，当我们的CPU等需要一个程序的信息时，都是通过内核这个代理去进行间接的提取的。通过这样，程序不过去关心这个数据的提取是否麻烦。隔离了用户层与数据层。</p>
<hr>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>​	<strong>为其他对象提供一种代理以控制对这个对象的访问。</strong></p>
</blockquote>
<p>​	这是《设计模式：可复用面向对象软件的基础》（<strong>Gang of Four，GoF</strong>）中给出的定义。这个定义我们前面其实已经说的很清楚了。这里就不再对其进行赘述了。</p>
<p>​	</p>
<p>我们来看一下在《设计模式：可复用面向对象软件的基础》（<strong>Gang of Four，GoF</strong>）提高的适用性，其实也是几个具体的例子。</p>
<p>《设计模式：可复用面向对象软件的基础》（<strong>Gang of Four，GoF</strong>）中指出，代理模式适用于以下场景：</p>
<hr>
<h3 id="1-远程代理（Remote-Proxy）"><a href="#1-远程代理（Remote-Proxy）" class="headerlink" title="1. 远程代理（Remote Proxy）"></a>1. <strong>远程代理（Remote Proxy）</strong></h3><p>当需要访问一个远程对象时，代理可以在本地充当远程对象的代表，客户端可以像操作本地对象一样操作代理。</p>
<ul>
<li><strong>场景</strong>：分布式系统或网络通信中，客户端与远程服务之间通过代理进行交互。</li>
<li><strong>示例</strong>：Java RMI（远程方法调用）或 gRPC 中的客户端存根。现实中的大使馆</li>
</ul>
<hr>
<h3 id="2-虚拟代理（Virtual-Proxy）"><a href="#2-虚拟代理（Virtual-Proxy）" class="headerlink" title="2. 虚拟代理（Virtual Proxy）"></a>2. <strong>虚拟代理（Virtual Proxy）</strong></h3><p>当创建一个消耗大量资源的对象时，代理可以推迟对象的创建，并在真正需要时才实例化它（即延迟加载）。</p>
<ul>
<li><strong>场景</strong>：需要优化性能或延迟加载资源的场景，例如加载大文件、大图片等。</li>
<li>示例：<ul>
<li>加载大图片时，只在显示时才真正加载。</li>
<li>数据库连接池中的连接代理。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-保护代理（Protection-Proxy）"><a href="#3-保护代理（Protection-Proxy）" class="headerlink" title="3. 保护代理（Protection Proxy）"></a>3. <strong>保护代理（Protection Proxy）</strong></h3><p>当需要控制对对象的访问权限时，代理可以提供额外的权限检查功能。</p>
<ul>
<li><strong>场景</strong>：需要对不同用户角色（如管理员和普通用户）进行访问控制的场景。</li>
<li>示例：<ul>
<li>操作系统中的文件访问控制。</li>
<li>公司内部的权限管理系统。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-智能引用（Smart-Reference）"><a href="#4-智能引用（Smart-Reference）" class="headerlink" title="4. 智能引用（Smart Reference）"></a>4. <strong>智能引用（Smart Reference）</strong></h3><p>在访问某个对象时，代理可以在实际操作前后执行一些附加操作，例如记录访问日志、统计引用计数、监控性能等。</p>
<ul>
<li><strong>场景</strong>：需要跟踪或管理对象的引用与访问。</li>
<li>示例：<ul>
<li>引用计数机制，自动管理对象的生命周期。</li>
<li>日志记录代理，记录对某些重要对象的访问情况。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-缓存代理（Caching-Proxy）"><a href="#5-缓存代理（Caching-Proxy）" class="headerlink" title="5. 缓存代理（Caching Proxy）"></a>5. <strong>缓存代理（Caching Proxy）</strong></h3><p>代理保存一些已有的计算结果，当客户端请求时，直接返回缓存值而不是重新计算。</p>
<ul>
<li><strong>场景</strong>：需要频繁访问资源但不希望重复计算的场景。</li>
<li>示例：<ul>
<li>数据库查询结果的缓存。</li>
<li>大型计算任务结果的缓存。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-防火墙代理（Firewall-Proxy）"><a href="#6-防火墙代理（Firewall-Proxy）" class="headerlink" title="6. 防火墙代理（Firewall Proxy）"></a>6. <strong>防火墙代理（Firewall Proxy）</strong></h3><p>代理用于保护对象，使其不直接暴露在潜在的风险环境中。</p>
<ul>
<li><strong>场景</strong>：需要保护内部资源免受外部非法访问时。</li>
<li>示例：<ul>
<li>网络层中的防火墙代理。</li>
<li>内网与外网之间的网关。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>GoF 提到的代理模式适用性主要聚焦于以下几点：</p>
<ol>
<li>优化性能（如虚拟代理、缓存代理）。</li>
<li>控制访问权限（如保护代理、防火墙代理）。</li>
<li>隔离复杂性（如远程代理、智能引用）。</li>
</ol>
<p>​	通过代理，<strong>访问的灵活性</strong>和<strong>系统的扩展性</strong>得到了极大增强。代理模式的适用性非常广泛，可以根据实际需求选择合适的代理类型。其实吧，这上面的几个代理模式都不重要，没有必要去深入了解，这些都是在一些代理模式中的实际应用场景中抽离出来的普适性质。主要还是得去看UML类图和自己去搓一遍码才能深入理解。</p>
<hr>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><hr>
<p><img src="/2024/12/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/1.png" alt="img"></p>
<hr>
<p>​	可以看到，代理模式对应的类图相对于之前的享元模式等都是算简单的那一批了。</p>
<p>​	<em>圖中包含三大類別：</em></p>
<blockquote>
<p><code>**Subject**：是一個抽象類別或介面，定義*</code><em>Proxy</em><code>*和*</code><em>RealSubject</em><code>*的共同介面，當任何有使用*</code><em>RealObject</em><code>*的地方皆能使用*</code><em>Proxy</em>&#96;<em>。</em></p>
<p><code>***RealSubject***</code><em>：被代理的角色，也就是</em><code>*Proxy*</code><em>所代表的真實物件。</em></p>
<p><code>***Proxy***</code><em>：保存一個參考使得代理可以存取實體，並提供一個與</em><code>*Subject*</code><em>相同的介面，這樣代理就可以用來代替真實物件。</em></p>
</blockquote>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><strong>三个类：</strong>	</p>
<hr>
<p><strong>Subject类</strong></p>
<p>​	这个类是所有进行交互的类的父类，也就是说，这是一个定义了接口规范的类，之后的代理人类，幕后人类，用户层类都是使用这个接口规范的。还是那句话，你实际设计中可能没有这个这个类，但是没有这个类不太可能。</p>
<hr>
<p><strong>RealSubject类</strong></p>
<p>​	这个类是幕后人类，当然，这些个名字都是我瞎编的，无所谓了。在代理模式中，这个就是那个会被代理的类。通过一个接口规范类的继承可以大大简化我们设计阶段的接口问题，何乐而不为。</p>
<hr>
<p><strong>Proxy类</strong></p>
<p>​	这个类就是我们这个类图中的代理人类了，这个类直接与我们的RealSubject类接触。并且，一般来书，其接触的类只会有有限个代理人且不能随便扩展，不然那不就成公交车了。这个类进行了用户层与幕后层之间的直接联系，好处在之前已经说过了就不再赘述。</p>
<blockquote>
<p>​	由于代理模式的UML类图是相对简单的，所以我们更需要靠代码来进行进一步的理解。</p>
</blockquote>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>​	代理模式的代码简单来写时相当简单的，但是吧，实际的应用场景并没有遇到过，之后有机会再看吧。</p>
<p>​	这里直接给出三个类的代码，这次不会进行细致分析，只简单过一遍</p>
<p>​	</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象主题角色：声明真实主题和代理主题的共同接口。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Communication</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">commuication</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Communication</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	在这个类中，定义了抽象的接口。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//幕后人：定义了代理角色所代理的事物</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Speaker</span> : <span class="keyword">public</span> Communication &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">commuication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Speaker is speaking.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	在这个类中去定义实际的行为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代理主题角色：保存一个引用使得代理可以访问实体，并提供一个与真实主题角色相同的接口，这样代理就可以用来代替真实主题。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Communication &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Proxy</span>() &#123;</span><br><span class="line">        is_Start = <span class="literal">true</span>;<span class="comment">//只要创建了就是开启代理</span></span><br><span class="line">        speaker = <span class="keyword">new</span> <span class="built_in">Speaker</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> is_Start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStart</span><span class="params">(<span class="type">bool</span> isStart)</span> </span>&#123;</span><br><span class="line">        is_Start = isStart;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">commuication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_Start) &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;开始代理&quot;</span>&lt;&lt;endl;</span><br><span class="line">            speaker-&gt;<span class="built_in">commuication</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;没有代理权限&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Proxy</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> speaker;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> is_Start;</span><br><span class="line">    Speaker* speaker;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	这就是一个相当简单的代理类的实现了。可以看到，这里简单的设置了一些权限位进行一些标识。通过这些个标识，可以看到当前代理是否存在一些权限，这里获取权限的实现可以交给别的类来做来实现单一职责。</p>
<p>​	其他其实没什么需要注意的，还有一点，就是这里的代理类跟幕后人类是一个组合的关系。这不是一定的，但是代理人类中需要保留一个幕后人类的这一设定一般来说是一定的。毕竟只有保留了这个简单的引用，我们才能够实现代理。就比如，一个国家的大使馆中必须存在实际的工作人员，那么这个大使馆才能实现这个代理的能力。不然，它就是一座挂着名字的空房而已。</p>
<hr>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>​	代理模式相对来说是一个相对好理解的结构型设计模式了，通过一层代理封装实现用户层与实现层之间的隔离。其实很多设计模式都可以看到这一点，只是代理模式进行了一定程度上的特化，将这种功能上的封装特化为代理模式而已。</p>
<blockquote>
<p>​	作为看到的最后一种结构型设计模式，其的使用频率跟我们前面创建型设计模式中的原型模式中好像有点相似。毕竟对于代理这种思想的引入是很自然的，就像原型模式在工厂等创建型设计模式中的使用一样。所以啊，得找点项目来搓才能更好的理解这些个设计模式啊</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2024/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>​	定义一系列的算法，将它们一个个封装起来，并且使得它们可以相互替换。策略模式使得算法可以独立使用与它的用户而变化。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><blockquote>
<p>​	在我们使用的许多编辑器乃至编译器中，我们通常可以看到一些不同的换行符算法，有windows的\r\n，linux的\n，Mac用的\r等。将这些个换行符算法硬编码进我们使用的编辑器或者编译器软件中是不可取的。实际你也可以看到，基本所有的编辑器和编译器都有自己的切换换行符的功能。那么，原因是什么呢?</p>
</blockquote>
<span id="more"></span>

<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol>
<li><strong>复杂性增加</strong><ul>
<li>如果将换行算法直接嵌入到需要换行功能的程序中，会导致代码臃肿且难以维护。</li>
<li>支持多种换行算法的需求进一步加剧了这一问题。</li>
</ul>
</li>
<li><strong>灵活性受限</strong><ul>
<li>如果需要更改换行算法，不希望仍然支持之前的算法。例如，从 Windows 换行标准切换到 Linux 或 macOS 的标准，可能希望只支持新的规则。</li>
<li>继续支持不需要的旧规则可能导致解析问题。</li>
</ul>
</li>
<li><strong>扩展性受限</strong><ul>
<li>当功能被硬编码后，添加新算法或修改现有算法变得十分困难。</li>
</ul>
</li>
</ol>
<p>​	</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>​	也就是说，我们策略模式出现的动机就是为了解决上诉这种硬编码会导致的缺陷。所谓<strong>策略</strong>，就是在一个人面对不同事情时选择的不同应对方法，就比如你在window平台上设计时需要去使用window的换行符，你在linux平台开发时需要去使用linux的换行符。这些都是一种策略模式的体现。</p>
<p>​	也就是说，策略模式最本质的作用，就是通过一种策略来代替一种硬编码的步骤，使得用户能够自己选择当前要使用的方法，或者程序自己选择要使用的方法以取代全部的一种硬编码程序。也就是说，这是一种对于程序的进一步的解耦。</p>
<blockquote>
<p>通过<strong>解耦算法的选择与其具体实现</strong>来提高程序的灵活性和可维护性。</p>
</blockquote>
<p>​	就拿上面那个换行符算法举例，当我们使用策略模式来设计我们的编辑器后，我们能够在编辑器中去自由选择我们当前想要使用的换行符版本，这种动态选择提供了很高的灵活性，显著的提升了我们使用时的灵活性，将这个扩展到我们的类的设计中也是如此。</p>
<p>​	而且我们在考虑一下，如果我们使用策略模式来设计我们的换行符算法，那就意味着如果我们后续还需要对这个换行符算法进行添加或者修改的话，我们只需要去修改对应的区域或者添加新的算法即可，不必去修改现有的选择模块，这也是一种策略模式下的原则遵守和优势。</p>
<hr>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2024/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/735104bbfb7d801a684b9fc3fcd628b4.png" alt="img"></p>
<blockquote>
<p><strong>百闻不如一见，UML类图，启动</strong></p>
</blockquote>
<p>​	首先，策略模式的UML类图是相对简单的，毕竟从本质来看，它关注的其实主要就来个模块，一个模块时选择模块，另一个是算法模块，选择模块时面向用户层的接口，通过这个模块隔离了用户层与算法实现，同时提供了用户选择算法的方式。</p>
<p>​	至于算法层，只需要关注自身的实现，关注与选择模块的接口对接即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------+         +----------------+</span><br><span class="line">|  Context       |         |   Strategy     |</span><br><span class="line">|----------------|         |----------------|</span><br><span class="line">| setStrategy()  |&lt;&gt;------&gt;| + execute()    |</span><br><span class="line">| execute()      |         |----------------|</span><br><span class="line">+----------------+         +----------------+</span><br><span class="line">        |</span><br><span class="line">        |-----------------------------------------+</span><br><span class="line">        |                                         |</span><br><span class="line">+------------------+                  +------------------+</span><br><span class="line">| ConcreteStrategyA|                  | ConcreteStrategyB|</span><br><span class="line">|------------------|                  |------------------|</span><br><span class="line">| + execute()      |                  | + execute()      |</span><br><span class="line">+------------------+                  +------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	更为简单的一个UML类图。虽然有点糙，凑活这看吧</p>
<h3 id="类图要点："><a href="#类图要点：" class="headerlink" title="类图要点："></a><strong>类图要点：</strong></h3><ul>
<li><code>Context</code>（选择模块）：持有 <code>Strategy</code> 的引用，用于调用具体算法。</li>
<li><code>Strategy</code>（算法模块）：定义算法的统一接口，提供一个抽象的算法约束。</li>
<li><code>ConcreteStrategyA</code>、<code>ConcreteStrategyB</code>（具体算法实现）：实现 <code>Strategy</code> 接口，分别提供具体的算法逻辑。</li>
</ul>
<p>​	在这里我们在选择模块中没有列出引用这个属性，但是我们使用这个聚合关系来表示了。不对，你都看到这里了，不应该不知道这个啊，我还写个蛋啊。</p>
<p>​	在这个类图中其实没有显示出到底是一种什么个选择的逻辑，这个是等下我们的代码的工作。在这个类图中，我们主要来分析下我们设计的解耦性。</p>
<h3 id="设计的解耦性"><a href="#设计的解耦性" class="headerlink" title="设计的解耦性"></a>设计的解耦性</h3><ul>
<li><p><strong>对用户：</strong></p>
<ul>
<li><p>用户只需与 <code>Context</code> 交互，完全无需了解具体算法的实现逻辑。</p>
</li>
<li><p><code>Context</code> 提供了灵活的接口，让用户能够动态选择策略或依赖默认策略。这种灵活的选择可能是用户自己的选择也可能是程序自己的旋转，但是一般来说，这种选择都不是有if-else实现的，毕竟你策略模式的一种存在意义就是代替这种令人反感的长嵌套语句</p>
<blockquote>
<p><strong>你可能会疑惑那得怎么动态选择，别急，接着看</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>对算法：</strong></p>
<ul>
<li>各种算法被封装为独立类，彼此互不干扰。它们只需实现 <code>Strategy</code> 接口，与 <code>Context</code> 保持对接即可。</li>
<li>新增算法时，只需增加一个新的具体策略类，无需修改 <code>Context</code> 和其他策略。</li>
</ul>
</li>
</ul>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><blockquote>
<p><strong>实践才是检验真理的唯一方法</strong></p>
</blockquote>
<p>​	其实这里给的代码实例大部分还是为了写而写的，所以其实并没有什么实际应用的价值。而这些存在的意义是给你阐述这些的存在，并在实际的应用中去尝试使用，就比如，我学完策略模式将会把我课设中的数据模块再次进行解耦，将其分割为可以单步执行渲染和一直渲染到底的俩种策略模式，不过那都是后话了，我们先来看代码。</p>
<h3 id="对比示例"><a href="#对比示例" class="headerlink" title="对比示例"></a>对比示例</h3><h4 id="使用-if-else-的实现（不推荐）"><a href="#使用-if-else-的实现（不推荐）" class="headerlink" title="使用 if-else 的实现（不推荐）"></a>使用 <code>if-else</code> 的实现（不推荐）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLineBreak</span><span class="params">(<span class="type">const</span> std::string&amp; os)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (os == <span class="string">&quot;Windows&quot;</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Line break: \\r\\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (os == <span class="string">&quot;Linux&quot;</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Line break: \\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (os == <span class="string">&quot;Mac&quot;</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Line break: \\r&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Unknown OS!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextEditor editor;</span><br><span class="line">    editor.<span class="built_in">printLineBreak</span>(<span class="string">&quot;Linux&quot;</span>);  <span class="comment">// Output: Line break: \n</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li><p><code>printLineBreak</code> 方法中耦合了换行逻辑的选择和实现，扩展性差,破坏了单一职责原则。</p>
</li>
<li><p>增加新的操作系统时，必须修改方法内部的条件分支，破坏了开放封闭原则。</p>
</li>
<li><p>我们在修改时必须对所有的算法都进行维护，可能需要进行全部的实例化占用空间，也可能会使用懒加载机制来复杂使用逻辑。</p>
</li>
</ul>
<h4 id="使用策略模式的实现（推荐）"><a href="#使用策略模式的实现（推荐）" class="headerlink" title="使用策略模式的实现（推荐）"></a>使用策略模式的实现（推荐）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineBreakStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">LineBreakStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">formatLineBreak</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsLineBreak</span> : <span class="keyword">public</span> LineBreakStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">formatLineBreak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\\r\\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxLineBreak</span> : <span class="keyword">public</span> LineBreakStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">formatLineBreak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacLineBreak</span> : <span class="keyword">public</span> LineBreakStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">formatLineBreak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\\r&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;LineBreakStrategy&gt; strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(std::unique_ptr&lt;LineBreakStrategy&gt; newStrategy)</span> </span>&#123;</span><br><span class="line">        strategy = std::<span class="built_in">move</span>(newStrategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLineBreak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strategy) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Line break: &quot;</span> &lt;&lt; strategy-&gt;formatLineBreak() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No strategy set!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextEditor editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态选择策略</span></span><br><span class="line">    editor.<span class="built_in">setStrategy</span>(std::<span class="built_in">make_unique</span>&lt;LinuxLineBreak&gt;());</span><br><span class="line">    editor.<span class="built_in">printLineBreak</span>();  <span class="comment">// Output: Line break: \n</span></span><br><span class="line"></span><br><span class="line">    editor.<span class="built_in">setStrategy</span>(std::<span class="built_in">make_unique</span>&lt;WindowsLineBreak&gt;());</span><br><span class="line">    editor.<span class="built_in">printLineBreak</span>();  <span class="comment">// Output: Line break: \r\n</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优势：</p>
<ol>
<li>避免了 <code>if-else</code> 的分支判断，代码简洁清晰。</li>
<li>新增策略只需添加新的策略类，无需修改现有代码。</li>
<li>动态选择和切换策略，灵活性更强。</li>
</ol>
<p>​	</p>
<blockquote>
<p><strong>那么，代价是什么?</strong></p>
</blockquote>
<p>​	从上面来段代码我们其实可以看到最直观的一点就是，策略模式设计下的程序相对来说会存在更多的子类，这些子类都是对应的子算法类，这样会导致这个程序看起来很臃肿。</p>
<p>​	同时，无论是使不使用策略模式下的设计，我们其实都会存在一种问题，就是我们如果要选择一种算法，我们就必须知道一种算法的存在，这个其实就跟我们平时使用的很多软件一样，特别是编译器这种集成度很高的软件。</p>
<p>​	通常来说，为了集成到图形化界面上并提供一些多元化的选择，设计者会将功能的选择绑定到按钮上，而程序中的交互按钮又乱七八糟，很多按钮对很多用户来说只是个黑盒，这无疑还是会提高用户的使用难度。</p>
<p>​	而且在很多情况下，我们可能会碰到一些策略算法类之间存在部分逻辑重叠的情况，这会导致代码的重复，不过这种也可以通过基类的方法提取来解决。</p>
<p>​	我为什么提出这一点，其实是为了说明在我们提出一个模式的缺点后，我们应该做的不是去记住这些缺点然后接受它，而是应该通过我们已有的或者将来可能会有的知识来进行我们现有的缺点的一些个隐藏，这个才是举出缺点的意义。而不是，好，这个模式有这些缺点，那我就记住它，当我被问到这些时，我一五一十的去吧这些缺点说出来，这是没有意义的。</p>
<p>​	</p>
<blockquote>
<p>​	但是，总的来说，策略模式的这种优化，还是利大于弊的。因为设计模式关注的过程大多还是程序开发的这个过程，策略模式的设计思想本质就是让每种策略自成一体，通过接口与上下文对接，从而取代臃肿的条件分支语句，使代码更加模块化、可扩展和易维护。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	策略模式的核心思想是<strong>通过封装变化和动态选择策略，来提升代码的灵活性和可维护性</strong>。尽管它可能会增加类的数量和一定的设计复杂度，但其在算法扩展性和代码清晰度上的优势使得它在实际开发中广受欢迎。</p>
<p>​	通过合理设计和优化，策略模式能够很好地实现<strong>高内聚、低耦合</strong>的设计目标，帮助我们构建更易维护、更具扩展性的系统。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2024/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​	为请求创建一个接收者对象的链。该模式使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连接成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>​	责任链模式其实在现实生活中非常的常见，最简单的一种架构就是一个公司中对于一个员工提出的需求的处理。就比如，这个员工可能会想要加薪，可能要请假，可能想辞职。总总这些，都是员工的一些可能的行为，在提出这些需求后，员工会将这些需求提交给他的上级。就比如他的部门的老大。</p>
<p>​	他部门的老大会看当前他是否存在权利能够处理当前提出的需求，就比如如果一个员工想要请个小假，这种权利一般来说一个部门老大还是有的，相反，如果员工想要的是进行升职加薪这种，那对应的部门老大这个层级是没有权利去审批这事的。那么，我们先不去考虑哪种请求会被吞的情况。</p>
<p>​	一般情况下，如果一个层级的人物没有权利去处理下一级传递上来的请求，那么这个请求将会被当前任务再次提交给上级，在这种情况下，这个相对的上级还会去考虑当前自己是否有权利去处理这件事，然后做出抉择，我是需要去进行当前时间的审批处理还是我仍然没有权利去处理这件事而导致再次的往上去传递信息。这种不对的递归往上传递信息，直到信息被处理后再进行返回的结构，就是责任链模式的一种实例。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>​	可以想象到，在责任链模式中，我们不应该存在一个信息没有被处理的情况，在现实中也是如此，在生活中，一个公司的最上层应该拥有着对于下面的所有请求的处理权限，在这里也是如此。当然，在责任链模式中不同的是，现实中你可能会看到上层去处理一些下层处理的是，但是在责任链模式中，这种行为是不被允许的。</p>
<p>​	你可以把责任链模式看做一层层的筛网，每层筛网的大小不同，会筛去符合当前权限的事件，如果当前筛网上还存在着时间没有处理，那么这些时间就会被转移到下一层筛网进行处理，直到所有的事件都被处理。这种对于事件的处理机制，才是责任链模式的核心。</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2024/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/image-20241228094455900.png" alt="image-20241228094455900"></p>
<blockquote>
<p>​	这里使用了我看的课的一个UML类图，这个类图中的职责其实已经写的很清楚了，都看到行为性模式了你自己也应该看的懂这个类图了，这里就简单过一遍就行。</p>
</blockquote>
<p>​	</p>
<h3 id="AbstractManager类"><a href="#AbstractManager类" class="headerlink" title="AbstractManager类"></a>AbstractManager类</h3><p>​	这个类是我们全部责任链上的类的基类，可以看到，这个类中定义了一系列的方法来进行我们责任对象的行为规定。其中的函数我们不需要去进行详细了解，我们来抽象俩个在这个抽象类中必不可少的几个属性。</p>
<h4 id="抽象成员指针"><a href="#抽象成员指针" class="headerlink" title="抽象成员指针"></a>抽象成员指针</h4><p>​	在责任链模式中，对于链上的每一个元素，我们至少要提供一种能够往上去传递信息的方法，在这里我们就是通过一个成员指针来实现它的链式结构来实现的，通过这个成员指针，我们将能通过这个成员指针去递归的进行信息的处理，还是那个问题，有些操作是无法再UML类图上展示出来的，还是得等到之后的代码去进行分析。</p>
<h4 id="信息处理api"><a href="#信息处理api" class="headerlink" title="信息处理api"></a>信息处理api</h4><p>​	在每个管理层中，都应该存在能够处理下层传递的api接口，在这里面你其实也很清楚它到底是谁，这里就不再赘述。这里使用了枚举变量来进行我们处理信息的一次分类，这个无所谓，你但可以使用自己的一套数据来进行识别。</p>
<h3 id="实例子类"><a href="#实例子类" class="headerlink" title="实例子类"></a>实例子类</h3><p>​	这里面的系列抽象子类其实没有什么分析的价值，在这里面，对于具体子类，其实就是继承了父类的方法并且进行了一些对于自己信息处理的特化。唯一优点讨论价值的就是它的责任链的构建，每个子类都只关注与它联系的上一层的子类的指针，对于其他的层次，子类并不关注。</p>
<blockquote>
<p>对于请求发出类，这里就不再进行分析了，没意思。</p>
</blockquote>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">RequestType</span> &#123;</span><br><span class="line">    Leave,       <span class="comment">// 请假</span></span><br><span class="line">    Raise,       <span class="comment">// 加薪</span></span><br><span class="line">    Resignation  <span class="comment">// 辞职</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">    RequestType type;</span><br><span class="line">    std::string description;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Request</span>(RequestType t, <span class="type">const</span> std::string&amp; desc) </span><br><span class="line">        : <span class="built_in">type</span>(t),	 <span class="built_in">description</span>(desc) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这里就是一些属性的抽离定义了，没什么好说的。</p>
<h3 id="抽象处理者"><a href="#抽象处理者" class="headerlink" title="抽象处理者"></a>抽象处理者</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::shared_ptr&lt;Handler&gt; next; <span class="comment">// 下一个处理者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Handler</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNext</span><span class="params">(std::shared_ptr&lt;Handler&gt; nextHandler)</span> </span>&#123;</span><br><span class="line">        next = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canHandle</span>(request)) &#123;</span><br><span class="line">            <span class="built_in">processRequest</span>(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next) &#123;</span><br><span class="line">            next-&gt;<span class="built_in">handleRequest</span>(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;请求未被处理：&quot;</span> &lt;&lt; request.description &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">canHandle</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	可以看到，在这个处理者中，我们定义了一系列的抽象方法提供使用，其他的没什么意思，主要是这个处理请求的函数。</p>
<p>​	在这个处理函数中，我们会先去考虑当前是否存在权限去进行处理，如果有就直接处理并且返回。如果没有权限，那么就去递归调用责任链条中的下一层角色，直到被返回为止。</p>
<p>​	理论上，一定是存在角色能够处理我们这个事件的。当然，如果你输入的是一个额外的请求，不符合我们规定的请求，那抱歉，我们将无法处理，并且将会一直返回到底。</p>
<h3 id="具体处理者"><a href="#具体处理者" class="headerlink" title="具体处理者"></a>具体处理者</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体处理者：部门主管</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Supervisor</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandle</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.type == Leave;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;主管批准请求：&quot;</span> &lt;&lt; request.description &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者：部门经理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandle</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.type == Raise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;经理批准请求：&quot;</span> &lt;&lt; request.description &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者：CEO</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CEO</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandle</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// CEO可以处理所有请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CEO批准请求：&quot;</span> &lt;&lt; request.description &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这一个就更没有什么好说的了，就是一些具体的处理逻辑而已。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建责任链</span></span><br><span class="line">    <span class="keyword">auto</span> supervisor = std::<span class="built_in">make_shared</span>&lt;Supervisor&gt;();</span><br><span class="line">    <span class="keyword">auto</span> manager = std::<span class="built_in">make_shared</span>&lt;Manager&gt;();</span><br><span class="line">    <span class="keyword">auto</span> ceo = std::<span class="built_in">make_shared</span>&lt;CEO&gt;();</span><br><span class="line"></span><br><span class="line">    supervisor-&gt;<span class="built_in">setNext</span>(manager);</span><br><span class="line">    manager-&gt;<span class="built_in">setNext</span>(ceo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建请求</span></span><br><span class="line">    <span class="function">Request <span class="title">leaveRequest</span><span class="params">(Leave, <span class="string">&quot;请假一天&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Request <span class="title">raiseRequest</span><span class="params">(Raise, <span class="string">&quot;加薪申请&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Request <span class="title">resignationRequest</span><span class="params">(Resignation, <span class="string">&quot;辞职申请&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试责任链</span></span><br><span class="line">    supervisor-&gt;<span class="built_in">handleRequest</span>(leaveRequest);</span><br><span class="line">    supervisor-&gt;<span class="built_in">handleRequest</span>(raiseRequest);</span><br><span class="line">    supervisor-&gt;<span class="built_in">handleRequest</span>(resignationRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这个也没有什么好说的，主要来看这里的日志输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\ASUS\Desktop\CS\CS_STUDY\designPattern\19-责任链模式&gt; .\test.exe</span><br><span class="line">主管批准请求：请假一天</span><br><span class="line">经理批准请求：加薪申请</span><br><span class="line">CEO批准请求：辞职申请</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	可以看到，这里是正确的处理了我们提出的请求的，所以，可以看到，这种模式的作用也就在这。通过对于上层权利的不断下发，当然，上层还是保留着对应的权利的，可以实现在多个环节对于信息的处理，我们可以在各个环节中去细化信息处理的细节而不去影响其他环节上的代码。这种分包式的设计，使得各个环节上的功能更加容易扩展，同时也遵守了开放封闭原则。</p>
<h2 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h2><p>责任链模式（Chain of Responsibility）是一种行为设计模式，其核心意义在于通过<strong>链式传递的方式解耦请求的发送者和处理者</strong>，从而实现系统的灵活性和可扩展性。</p>
<p>以下是责任链模式的具体意义：</p>
<hr>
<h3 id="1-降低耦合性"><a href="#1-降低耦合性" class="headerlink" title="1. 降低耦合性"></a>1. <strong>降低耦合性</strong></h3><ul>
<li>责任链模式通过将请求的发送者和具体处理者分离，使二者之间不再直接关联：<ul>
<li>发送者只需要将请求传递给链的起始节点，无需关心请求最终由谁处理。</li>
<li>每个处理者只需关注自己的能力范围，并决定是否处理或将请求传递给下一个处理者。</li>
</ul>
</li>
<li>这种分离提高了系统的模块化，使得代码更易于维护。</li>
</ul>
<hr>
<h3 id="2-增强灵活性"><a href="#2-增强灵活性" class="headerlink" title="2. 增强灵活性"></a>2. <strong>增强灵活性</strong></h3><ul>
<li>可以动态地调整链中的处理者以及处理顺序，而不会影响其他部分：<ul>
<li>通过新增处理者类实现新功能。</li>
<li>通过重组链条调整优先级或职责分配。</li>
</ul>
</li>
<li>在运行时可以改变链的结构，从而适应不同的需求场景。</li>
</ul>
<hr>
<h3 id="3-实现职责分离"><a href="#3-实现职责分离" class="headerlink" title="3. 实现职责分离"></a>3. <strong>实现职责分离</strong></h3><ul>
<li>每个处理者只关注自身的业务逻辑：<ul>
<li>将单一职责原则（SRP）落实到代码中，避免将多个职责耦合到一个类中。</li>
<li>每个类的职责单一，易于测试和复用。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-支持请求的动态处理"><a href="#4-支持请求的动态处理" class="headerlink" title="4. 支持请求的动态处理"></a>4. <strong>支持请求的动态处理</strong></h3><ul>
<li><p>请求可以在责任链中</p>
<p>动态传递</p>
<p>，直到某个处理者能够处理它：</p>
<ul>
<li>无需显式指定处理者，由链上的逻辑决定。</li>
<li>这种动态决策使得请求的处理更加灵活。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-容错与扩展能力"><a href="#5-容错与扩展能力" class="headerlink" title="5. 容错与扩展能力"></a>5. <strong>容错与扩展能力</strong></h3><ul>
<li>如果请求无法被任何处理者处理，可以通过链末端的逻辑提供默认处理方案或报错机制：<ul>
<li>避免请求被丢弃或未响应的情况。</li>
</ul>
</li>
<li>责任链模式支持扩展，例如添加一个新的处理者以处理特殊的请求，而不影响现有链条。</li>
</ul>
<hr>
<h3 id="6-现实中的类比"><a href="#6-现实中的类比" class="headerlink" title="6. 现实中的类比"></a>6. <strong>现实中的类比</strong></h3><ul>
<li><p>责任链模式的意义也体现在现实场景中</p>
<p>，例如：</p>
<ul>
<li><strong>公司审批流程</strong>：如请假申请，会从部门主管到经理再到CEO逐级审批。</li>
<li><strong>技术支持系统</strong>：用户请求会先经过一级客服，若无法处理则转给二级客服，直至请求被解决。</li>
</ul>
</li>
</ul>
<p>这种模式将复杂的职责分配抽象为“链式传递”，使流程自然且易于理解。</p>
<hr>
<h3 id="使用责任链模式的场景"><a href="#使用责任链模式的场景" class="headerlink" title="使用责任链模式的场景"></a>使用责任链模式的场景</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ol>
<li>多个处理者可以处理同一类请求，但实际处理者不确定：<ul>
<li>如权限校验、事件分发等。</li>
</ul>
</li>
<li>请求的处理逻辑需要解耦，避免硬编码依赖：<ul>
<li>如日志处理、UI事件处理等。</li>
</ul>
</li>
<li>需要灵活的责任分配和动态调整：<ul>
<li>如任务分发系统、策略模式的动态实现。</li>
</ul>
</li>
</ol>
<h4 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a><strong>不适用场景</strong></h4><ol>
<li>处理链过长且复杂：<ul>
<li>过多的处理者可能导致性能下降。</li>
</ul>
</li>
<li>请求需要明确的唯一处理者：<ul>
<li>如果明确知道请求由哪个处理者完成，则责任链模式可能不适合。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>责任链模式的意义在于通过链式传递，将职责分离、降低耦合，同时提高灵活性和可扩展性。它在解决复杂的职责分配问题时表现出色，尤其是在处理多层审批、事件分发等场景中，使得系统结构更清晰、更易于维护。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类图</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2-UML%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<p>UML类图是一个常用于面向对象程序设计的工具。用于图形化描述类的基本属性和类与类之间的关系。</p>
<p>类与类之间存在着5种关系。</p>
<span id="more"></span>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2-UML%E7%B1%BB%E5%9B%BE/1.jpeg" alt="1"></p>
<p>对于一个类的类图构造，有几个规则，直接上例子吧。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2-UML%E7%B1%BB%E5%9B%BE/2.jpeg" alt="2"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2-UML%E7%B1%BB%E5%9B%BE/3.jpeg" alt="3"></p>
<p>如图。首先，整个类图分为3块。</p>
<p>最上面一块为类名。这一块规则不多。如果你的类是一个可实例化的类，那么这个类名应该是正体字。相反，如果是一个虚类，那么这个类名就应该是一个斜体字。</p>
<p>第二块是类成员的区域。这一块有着一定的规范，一行的数据应该由(访问权限|成员名|:|类型名)组成。特殊的是，如果这个类成员是一个默认初始化的成员，那么需要在之后加上一个&#x3D;和对应的初始化对象。特殊的是，如果这个类成员是一个静态类成员，那么需要在这个成员处加上下划线进行标识。</p>
<p>来看一下我们访问权限的符号定义。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2-UML%E7%B1%BB%E5%9B%BE/4.jpeg" alt="4"></p>
<p>接下来进入第三个区域。这个区域是用于类成员函数的标识。基本组成结构是(访问权限|函数名|函数参数列表|:|函数返回值类型)。对于参数列表内部的组成，如果为空，那么()为空即可。若不为空，按照(参数名|参数类型)并按(,)分割的格式进行制作。特殊的是，如果这个成员函数是一个静态成员函数，那么需要加上一个下划线进行标识。如果是一个虚函数，那么需要写成斜体字，如果还是一个纯虚函数，那么需要在末尾加上一个&#x3D;0进行标识。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>UML类图</category>
      </categories>
      <tags>
        <tag>设计模式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2025/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​	提供一个方法顺序·访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
<span id="more"></span>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>​	在我看起来迭代器出现的原因其实很简单，也很符合我们的单一职责原则。这个模式出现的原因，就是为了去解决一个数据结构中可能存在的数据遍历问题。</p>
<p>​	搓过数据结构的都知道，你只搓出数据的底层表示是远远不够的，你还需要提供一个或多个方法去进行这些个数据的查找，遍历等。在C++中的stl库中也是如此，所有的数据类型中都给我们提供了一系列的迭代器接口供我们去对数据进行查找和遍历等。而这些个查找和遍历所应用的设计模式，就是迭代器模式。</p>
<p>​	总的来说，一个迭代器模式的出现就是一个为了方便用户去进行使用的初衷，通过对于一个数据结构提供一个查询的接口，去避免用户自己去进行底层数据的遍历。</p>
<p>​	这是一个很朴素的哲学，一路过来，我们都尽量避免我们的底层数据能与用户直接接触，因为这种接触是不可控的，我们无法控制这种交由用户自己处理的行为是否会出现什么问题。因此，为了程序的稳定，同时也为了使我们的程序更加的智能，我们通常需要去为我们设计的东西添加尽可能多的接口而不是去暴露我们的数据。而且，你应该也有体会，当现有的就存在一些简便的方法时，你一般不会去在现有的方法上再去设计一个功能相似的方法，这也是设计模式的一种哲学。</p>
<h3 id="补充的哲学思考"><a href="#补充的哲学思考" class="headerlink" title="补充的哲学思考"></a>补充的哲学思考</h3><ol>
<li><strong>接口即契约</strong>：<br>提供一个迭代器接口，就是在告诉用户“这是访问数据的唯一正确方式”，从而规范了用户的行为。这种契约精神不仅使程序更稳定，也为团队协作和代码复用带来了极大的便利。</li>
<li><strong>从用户角度出发</strong>：<br>当你设计一个程序时，始终要考虑用户的使用体验。迭代器模式的核心出发点就是“如何让用户以最简单的方式访问数据”，这体现了优秀设计的以人为本。</li>
<li><strong>避免重复发明轮子</strong>：<br>一般来首现有的迭代器接口已经很好地解决了数据访问问题，因此通常不需要重复设计功能相似的接口。这种“站在巨人肩膀上”的思维不仅高效，也能让你的设计更加稳健。</li>
</ol>
<blockquote>
<p>对于迭代器模式存在的意义，我们已经基本了解了，接下来我们直接进入对应的UML类图和代码实现吧</p>
</blockquote>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="/2025/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20250101180051284.png" alt="image-20250101180051284" style="zoom:80%;">

<p>​	借用一个UML类图进行分析</p>
<p>​	对于一个迭代器模式，我们首先需要知道的是，其根本上是为了对于一个数据结构进行排序查找等方法的提供的。因此，我们需要一个数据结构作为我们的底子。在这里的UML类图中，我们使用一个双向链表作为示例。</p>
<h3 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h3><p>​	做过数据结构的就知道这个是用来干嘛的了，这里就不再进行赘述了</p>
<h3 id="MyList类"><a href="#MyList类" class="headerlink" title="MyList类"></a><strong>MyList类</strong></h3><p>​	这个类就是我们这个迭代器模式中的服务对象，就是我们的具体的数据结构。可以看到在这个类中，我们包含了一个计数用于标识这个数据结构中插入元素的数量，该包含了一个用户头结点和尾节点的指针用于这个链表的标识。</p>
<p>​	接下来看到这个类中的函数，其中很多都很常见，就不再赘述，主要看到这里的getIterator函数，这个函数返回一个指针，这个函数返回一个指针，这个指针指向一个迭代器。也就是说，这个函数就是一个我们进行迭代器调用的接口，通过这个接口，我们可以实现迭代器方法的调用。</p>
<p>​	当然，这种你爹带起的调用其实见仁见智，我觉得还存在一种调用方法就是直接在这个类中去进行一个迭代器的声明，利用组合或者聚合的关系进行构造，也可能再利用一种外观模式，将我们的这个数据模块和排序模块给封装起来实现我们的功能，当然，这里只是提出一种方法，具体的实现可以多种，虽然我自己也没搓过几个，见仁见智吧。在这里说这些知识我思维的一些发散罢了。</p>
<h2 id="Iterator类"><a href="#Iterator类" class="headerlink" title="Iterator类"></a>Iterator类</h2><p>​	这个类就是我们的迭代器类，这个类在设计中准备负责的功能就是实现我们的排序模块。可以看到，在这个类的成员中，包含了一个我们自己设计的一个链表，这个就是我们这个迭代器中赖以实现排序功能的基础。这里就不再赘述。另一个成员是一个用于标识当前指向的节点的地址，也没有什么分析的价值，看到成员函数吧。</p>
<p>​	在这里的成员函数中，大多都是一些抽象虚函数，由这些形成了多态体系，这里也不再多说，总的来说，这里的迭代器的组成还是相对来说比较简单的，不需要多么深入的剖析。</p>
<p>​	还可以看到，在这里的抽象基类底下，还有着几个相对独立的子类，这里分别是一种顺序遍历和逆序遍历的方法，这里也是对前面多态特性的一种补充，也没什么好说的。</p>
<p>​	总的来说，迭代器模式的UML类图相对来说比较简单，主要是看代码自己搓一遍熟悉流程，等到之后自己项目中去用一遍也就差不多了。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>​	进入代码分析之前，我们需要对一个C++性质进行一定的分析，其实我也有点忘了，之前学过就没有再拿起来用过。</p>
<h3 id="模版特性简析"><a href="#模版特性简析" class="headerlink" title="模版特性简析"></a>模版特性简析</h3><p>​	使用template <typename t>或者template <class t>进行一个模版的声明，这个模版的名字是后面的这个指定的T。至于是typename还是class，这个是等价的无所谓。</class></typename></p>
<blockquote>
<p>​	一个模版声明的作用域是有限的，其只会在其最近的一个作用域中生效。</p>
<p>​	这里使用GPT总结版，写的很清楚。</p>
</blockquote>
<h4 id="1-模板的声明与定义"><a href="#1-模板的声明与定义" class="headerlink" title="1. 模板的声明与定义"></a>1. <strong>模板的声明与定义</strong></h4><p><code>template &lt;typename T&gt;</code> 声明的模板类型参数 <code>T</code> 的作用范围从声明开始，覆盖模板定义内的所有内容。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    T member; <span class="comment">// 这里的 T 是模板参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>T</code> 只在 <code>MyClass</code> 的定义内有效，离开 <code>MyClass</code> 后 <code>T</code> 不再有意义。</p>
<hr>
<h4 id="2-嵌套作用域"><a href="#2-嵌套作用域" class="headerlink" title="2. 嵌套作用域"></a>2. <strong>嵌套作用域</strong></h4><p>如果模板参数声明出现在嵌套的作用域中（如嵌套类、成员函数等），模板参数的作用范围会受到进一步限制。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(U value)</span> </span>&#123;</span><br><span class="line">        T outerMember; <span class="comment">// 这里的 T 是 Outer 的模板参数</span></span><br><span class="line">        U innerMember; <span class="comment">// 这里的 U 是 func 的模板参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>Outer</code> 的定义中，<code>T</code> 是有效的。</li>
<li>在 <code>func</code> 的定义中，<code>U</code> 是有效的，但 <code>U</code> 的作用范围仅限于 <code>func</code> 的内部。</li>
</ul>
<hr>
<h4 id="3-局部模板参数的作用范围"><a href="#3-局部模板参数的作用范围" class="headerlink" title="3. 局部模板参数的作用范围"></a>3. <strong>局部模板参数的作用范围</strong></h4><p>局部模板参数的作用范围只限于其声明的具体位置。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T outerVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套的模板</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">innerFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        U innerVar; <span class="comment">// 这里的 U 是 innerFunction 的模板参数</span></span><br><span class="line">        T outerVarCopy = outerVar; <span class="comment">// 可以访问外部的 T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>innerFunction</code> 中，<code>U</code> 是局部模板参数，其作用范围仅限于 <code>innerFunction</code> 的定义。</p>
<hr>
<h4 id="4-特殊注意：模板的作用范围与嵌套"><a href="#4-特殊注意：模板的作用范围与嵌套" class="headerlink" title="4.特殊注意：模板的作用范围与嵌套"></a><strong>4.特殊注意：模板的作用范围与嵌套</strong></h4><p>在某些嵌套场景中，外层模板参数与内层作用域可能会产生冲突。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 这里的 T 会隐藏外层的 T</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处 T 指的是内层模板参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>method</code> 中，<code>T</code> 指的是方法的模板参数，而不是类 <code>Container</code> 的模板参数。这种情况下可能会导致混淆，需要注意命名的区分。</p>
<hr>
<h4 id="模版总结"><a href="#模版总结" class="headerlink" title="模版总结"></a>模版总结</h4><p><code>template &lt;typename T&gt;</code> 的作用范围确实是<strong>局部的</strong>，仅限于最近的声明和定义所在的作用域。如果有嵌套作用域，内层的模板参数会遮蔽外层的模板参数。这种规则确保了模板的灵活性，同时也要求在设计模板时小心命名冲突的问题。</p>
<blockquote>
<p>有了这个，我们可以来进行我们代码的分析了，启动!!!!!</p>
</blockquote>
<h3 id="通用迭代器类"><a href="#通用迭代器类" class="headerlink" title="通用迭代器类"></a>通用迭代器类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(T val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedIterator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* current;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SharedIterator</span><span class="params">(Node&lt;T&gt;* start)</span> : current(start) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> current != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = current-&gt;data;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>​	首先可以看到，我们使用一个模版来进行我们结构体Node的创建，这就使得我们最后的结构体基本能够兼容所有的基本数据类型，至于负责数据类型，可能还需要后续的更多调整。</p>
<p>​	额外多说一嘴，这里的结构体使用了构造函数，需要注意的是，这是cpp中的结构体有的特性，在c中是不存在的。</p>
<p>​	接下来看到我们的迭代器类，可以看到，我们的迭代器类也是使用了一个模版，在这个模版类中，我们还使用了一个模版结构体。这种嵌套需要我们在使用对应的嵌套结构体中去指定对应的类型，这里也是如此，通过将Node的类型指定为自身的模版T实现了一种模版范围的衍生，提高了扩展性。</p>
<p>​	接下来看到几个基类函数，这里就没有考虑去进行功能的扩展了，需要的话可以把这个类重新设计为一个ABC类再进行对应的设计，这里就不再展开了。可以看到，在这些个类方法中，提供了系列方法用于一些元素位置的查找，这里也不赘述，直接跳过。</p>
<h3 id="具体的数据结构类"><a href="#具体的数据结构类" class="headerlink" title="具体的数据结构类"></a>具体的数据结构类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedList</span>() : <span class="built_in">head</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(value);</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;T&gt;* <span class="title">getHead</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	对于这个十分简陋的链表，我其实没什么可说的，唯一需要注意一点的就是我们这里的链表插入使用的是一个头插法的插入规则。那几个想说的放在这里又不太合适，我们直接看接下来的测试程序吧。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;<span class="type">int</span>&gt; list1;</span><br><span class="line">    list<span class="number">1.</span><span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">    list<span class="number">1.</span><span class="built_in">add</span>(<span class="number">2</span>);</span><br><span class="line">    list<span class="number">1.</span><span class="built_in">add</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;<span class="type">int</span>&gt; list2;</span><br><span class="line">    list<span class="number">2.</span><span class="built_in">add</span>(<span class="number">4</span>);</span><br><span class="line">    list<span class="number">2.</span><span class="built_in">add</span>(<span class="number">5</span>);</span><br><span class="line">    list<span class="number">2.</span><span class="built_in">add</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复用通用迭代器</span></span><br><span class="line">    <span class="function">SharedIterator&lt;<span class="type">int</span>&gt; <span class="title">it1</span><span class="params">(list<span class="number">1.</span>getHead())</span></span>;</span><br><span class="line">    <span class="function">SharedIterator&lt;<span class="type">int</span>&gt; <span class="title">it2</span><span class="params">(list<span class="number">2.</span>getHead())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it<span class="number">1.</span><span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; it<span class="number">1.</span><span class="built_in">next</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it<span class="number">2.</span><span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; it<span class="number">2.</span><span class="built_in">next</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="复用分析"><a href="#复用分析" class="headerlink" title="复用分析"></a>复用分析</h4><p>​	这个其实也没有什么好说的，但是你看到的时候可能会为这种设计感到疑惑，就是说为什么要这么写。首先我们先来明确一下，在这段代码中的复用，指的是对于迭代器代码的复用，而不是对于迭代器这个类的复用。</p>
<p>​	理论上，你当然可以设计一些东西使得一个迭代器能够被多个类所使用，但是这样会存在一个问题，最直接的就是切换的问题，如果你来回的切换使用的对象而且你还需要保留上一次使用的记录，这会是非常麻烦的。再者，一个迭代器类被多个类所使用，如果不对呀迭代器进行严格的设计的话，这个迭代器类将会是线程危险的。</p>
<p>​	总的来说，为了避免总总的问题，我们的没一个迭代器，通常都是与一个对应的数据模块类所对应的，这样能减少很多的一个问题，而且由于迭代器类在设计上通常并不会有很多的类成员，大多都是一些api方法，所以这种开销是可以接受的。</p>
<p>​	</p>
<h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><p>​	在这段测试程序中，我们可以看到，这几个都是使用了相同的方法名，这样一看过去，我们其实就能够简单的理解这类函数存在的一些通用方法，这其实就减轻了我们的学习负担，就比如我们的stl库，当我们了解了其中的一个之后，我们去了解其他的类，其实发现他们都大差不差，很容易上手。而这里就是我们迭代器类，或者说，编程规范的一种优势所在，通过规范的编程来降低用户学习使用对应的api的难度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	总的看下来，迭代器模式其实没有什么好说的，主要就是我们如何去设计一个迭代器，一个数据模块中对于一个迭代器如何使用，用于如何使用数据结构提供的接口和在这之下的我们怎么去设计对应的数据结构下的数据模块和迭代器模块的配合。</p>
<p>​	这总的来说主要是一种实战的技能，可能会在之后去浅浅设计一个自己的vector类来进行熟悉吧。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2024/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>​	</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​	<strong>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请 求排队或者记录请求日志，可以提供命令的撤销和恢复功能</strong>。</p>
<h2 id="粗略理解"><a href="#粗略理解" class="headerlink" title="粗略理解"></a>粗略理解</h2><p>​	奇怪，我对于这个命令模式就是有点疑惑，我就是不知道它到底是一个什么情况。让我简单先敲一遍，兴许就能理解问题了。</p>
<p>​	先举一种简单的现实生活中的命令模式来进行理解。就是餐馆的一个点餐系统。在现实生活中，你需要去思考你到底要选择那一道菜，然后你需要去考虑把你选择的这些个菜单送给服务员，然后服务员会将这些菜送给后厨，然后用户就只需要等待。</p>
<p>​	但是我们有没有考虑过没有服务员这种情况呢，如果没有服务员，我们就需要去直接与后厨进行对接。这想想都不现实对吧。在程序设计中，这其实也是一种哲学。当我们程序设计得在用户实现一个功能直接调用底层的api时，这种设计是极其糟糕的。当然我这句话的描述有点问题，主要就是这里的用户是指使用设计好的程序的用户，而不是程序设计阶段的。</p>
<p>​	这种没有服务员的情况其实就是一种用户请求与具体实现之间的强耦合。再举一个甲乙方的例子来看。当甲方下发一个需求的时候，具体的乙方一般是不会看到这个甲方来直接去找到对应的员工来实现对应的功能的。相反，我们通常是把这个命令发送给乙方的对接部门，然后通过一些处理，这些命令会被分包并且下发给对应的实现部门。</p>
<p>​	我好像有点理解了。所谓的命令模式，要实现的就是一个命令发出者与命令实现之间的一个解耦。这时就需要我们去进行在中间的一层代理，在点餐系统中这是服务员。在项目对接中这个可能是项目经理。但是不变的是，在这种对接中，我们解开了命令发出者和命令执行者之间的强耦合。</p>
<p>​	通过这种解耦，客户将不用去后厨直接找到对应的厨师进行下单。只需要更具餐馆的规范去进行我们需求的发出，服务员负责添加这些需求到对应的列表中，而服务员接下来还负责将这些个需求按一定顺序发送给对应的后厨部门进行完成，这种分层式的设计使得用户不再需要去了解底层复杂的东西，只需要去了解餐馆提供的简单的菜单即可，其他的逻辑由下面的命令转发者和命令执行者进行操作。</p>
<p>​	到这里我其实明白了之前的误解。在理解命令模式中，不要在一开始就想得太多。类似与服务员这种消息转发者能够处理一些非常简单的消息转发，就比如用户想要那道菜，服务员就通知后厨做那道菜。除此之外，用户可能还会点套餐，这是一套复杂的命令，可能需要多个处理动作配合使用，这个也是服务员这个中间层需要做的事，但是一开始我们并不需要去拘泥在这里，可以从简单的地方出发。</p>
<p>​	还有，当我们需要添加菜单时，我们至少也需要去为对应的后厨添加对应的处理动作，这也是我之前存在疑惑的地方，不过现在也解开了一点了。</p>
<blockquote>
<p>总的来说，我现在感觉命令模式的核心在于:命令的处理与转发，通过引入一个具有转发行为的类来进行解耦</p>
</blockquote>
<p>在最简单的命令模式中，这个转发可以是一个不做任何处理的转发，其他复杂情况再说，现在先从简单的入手。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>​	在我看来，理解命令模式中，去看代码甚至比看UML类图更加重要。至少我第一次看的视乎类图根本看不懂它在说什么。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Receiver: 后厨</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Kitchen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareDish</span><span class="params">(<span class="type">const</span> std::string&amp; dish)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Kitchen is preparing: &quot;</span> &lt;&lt; dish &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Command: 命令接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Command</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteCommand: 具体命令类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrepareDishCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Kitchen* kitchen;</span><br><span class="line">    std::string dish;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrepareDishCommand</span>(Kitchen* k, <span class="type">const</span> std::string&amp; d) : <span class="built_in">kitchen</span>(k), <span class="built_in">dish</span>(d) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        kitchen-&gt;<span class="built_in">prepareDish</span>(dish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这里的几个类就是命令模式中的基本单位:命令的基本构成。在一个具体的命令中，需要包含这个命令具体的执行部门，所以这里保留了一个后厨的一个指针，用于进行执行部门的指定。我猜想，如果在后期需要对这个后厨部门进行划分，会将这个执行部门进行派生，至于继承还是聚合组合，那不是我们现在考虑的问题。</p>
<h3 id="转发者"><a href="#转发者" class="headerlink" title="转发者"></a>转发者</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Invoker: 服务员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Waiter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Command&gt;&gt; orders;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">takeOrder</span><span class="params">(std::shared_ptr&lt;Command&gt; command)</span> </span>&#123;</span><br><span class="line">        orders.<span class="built_in">push_back</span>(command);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; order : orders) &#123;</span><br><span class="line">            order-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        orders.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	可以看到，这里的转发者维护了一个命令队列，所有的客户给出的命令将会储存在这个队列中。我们还可以观察到这里的命令实际执行情况，其实就是一次程序控制流的转移，将当前的执行权限交给命令类进行自我的执行来实现对应的功能。</p>
<p>​	这里当然还可以进行一系列的扩展，就比如进行消息的撤销等操作，可以自行添加。</p>
<p>​	总的来说，这里的转发类重要的是这里的命令处理方法。通过储存客户端发出的所有命令，在适当的时机通过自身设定的命令执行顺序来进行对应的执行。而这里的执行，就跟很多设计模式一样，实际上就是进行一次程序控制流的转移，将程序控制流从当前的中转类转移到对应的命令处理程序中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client: 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建接收者</span></span><br><span class="line">    Kitchen kitchen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建具体命令</span></span><br><span class="line">    <span class="keyword">auto</span> steakCommand = std::<span class="built_in">make_shared</span>&lt;PrepareDishCommand&gt;(&amp;kitchen, <span class="string">&quot;Steak&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> pastaCommand = std::<span class="built_in">make_shared</span>&lt;PrepareDishCommand&gt;(&amp;kitchen, <span class="string">&quot;Pasta&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建调用者</span></span><br><span class="line">    Waiter waiter;</span><br><span class="line">    waiter.<span class="built_in">takeOrder</span>(steakCommand);</span><br><span class="line">    waiter.<span class="built_in">takeOrder</span>(pastaCommand);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务员发送订单</span></span><br><span class="line">    waiter.<span class="built_in">sendOrders</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里其实就没有什么好说的，需要注意的是，在命令模式中，我们需要在程序一开始进行所有的命令的初始化，之后我们所有发出的命令本质上其实就是保留了一份对应的指针。当然，你可以在每次调用时都进行副本的一次创建，不给你也应该知道这种模式的坏处。</p>
<p>下面给出一个不是很美的UML类图，我自己都没去看()</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2024/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/d99bb4bb90aeefcc2db7233d91cc5a2c.png" alt="img"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2025/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​	用一个中介对象来封装一系列的对象交互。中介者使得各对象不需要显示的相互引用，从而是其耦合松散，而且可以独立地改变他们的交互。</p>
<span id="more"></span>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>​	其实这个中介者模式也相对来说比较好理解。重点就是在<strong>中介者</strong>者三个字上。</p>
<p>​	还是举现实中的例子进行分析，最直观的就是现实中的房产中介。通过房产中介，我们可以去看到一系列的房子的信息，即使我们并不了解这些个房子之后真正的售卖者。我们只需要通过这些个房产中介，就可以完成对于一个房产信息的了解，一个房子的购买等。总的来说，这个其实就是对于买房和卖房者这俩方之间的一处解耦合。这种解耦合的目的也十分明确，就是我们想让我们买房是不必依赖于卖房的一方。</p>
<p>​	通过房产中介这一角色，卖房一方可以将其的信息交由中介来进行管理，只需要付出相应的代价即可。同时，买房的一方也不再需要去直接联系卖房的一方，省去了很多寻找的功夫，只需要去了解中介提供的统一接口即可。同时，对应的也需要付出相应的代价。在现实生活中，这些个代价一般都是钱，那么在程序设计中，这个代价对应的就是我们的类的一定的访问权限。</p>
<p>​	如果我们对于这些角色间的关系使用连线来表示的话你应该就能够很清晰的了解这个关系的作用，在使用中介者模式之前，我们每个卖房者和买房者之间都有一条联系进行连接，这样的情况下双方角色一多就会出现一个非常复杂的关系网。如果改用中介者模式呢。在中介者模式下，我们在卖房者和买房者之间添加了一层缓冲，双方都可以通过这一层去进行与另一方的联系而不必要去直接联系，可以预见的是，在这种情况下，我们的结构图将会变得更加简洁明了。双方的联系只会连接到中介者这一端，有中介者这个节点进行各个连线之间的调度，控制连线之间的双边关系。</p>
<p>​	在这种架构下，双方不需要去了解相互之间到底应该怎么进行沟通，只需要了解这个中介公司的要求即可，通过这个中介的接口，可以实现对于自身的一定程度上的委托，有这个中介来进行自身的一定的管理。</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>​	当然，这种架构本身也存在着一些缺陷，这个我们应该也能够简单的理解。就现实情况而言，当你想要通过一个中介想把自己的一定信息挂上，你需要考虑什么？最直接的就是我要做的手续吧，然后呢，就是我使用这个中介平台的代价吧。这个手续在程序中的直观体现就是我们实现中介功能的这个类吧。如果一个类绑定到对应的中介类中的步骤太麻烦，那么是否绑定就需要斟酌一下了。</p>
<p>​	除此之外，还有什么？我们是否需要考虑一下我们使用这个中介类的代价，在程序中的体现就是我们这个中介类对于其所管理的类的访问权限，如果这个中介类需要的权限太多，那我们是否进行托管也需要考虑考虑吧。在程序设计中，这个的直观体现就是我们的中介类的设计复杂度，当我们的中介类包含了很多操作的时候，势必就需要使用对应的信息，但是是否暴露这些信息是由对应的角色决定的。</p>
<p>​	总的来说，中介模式的使用，需要权衡当前需要的功能及对应的中介类的代价，选择符合自己当前需求的方案，当然，这句话说了就等于没说，自己用用才能体会。</p>
<hr>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2025/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/image-20250104095044211.png" alt="image-20250104095044211"></p>
<p>这里的UML类图其实很清晰了，我们来进行一下简单的分析</p>
<p>​	首先，我们需要明确一下再这个类图。在这个类图中，存在着俩个抽象基类，这俩个抽象基类代表的就是我们前面说过的使用中介的对象和作为中介的对象。这里的抽象Country就是我们的抽象使用者，而MediatorOrg就是我们的抽象中介者类对象。</p>
<h3 id="抽象使用者Country类"><a href="#抽象使用者Country类" class="headerlink" title="抽象使用者Country类"></a>抽象使用者Country类</h3><p>​	这个类中其实很经典，主要就是定义了一些我们的具体使用者的一些接口，定义了一些接口规范，本质上其实也没有什么好说的。可以看到的是，在这个抽象对象中，保留了一个对于我们中介类的一个指针获取对应的中介类的接口使用权限(这里打错了，将就着看就行)。</p>
<p>​	通过这个接口，我们可以去看到对应的中介者类给我们提供的行为，接下来就看这个类。</p>
<h3 id="抽象中介者MediatorOrg类"><a href="#抽象中介者MediatorOrg类" class="headerlink" title="抽象中介者MediatorOrg类"></a>抽象中介者MediatorOrg类</h3><p>​	这个类也没什么好说的，主要就是包含了一个成员用于使用当前中介类的成员的注册，这个map包含了所有的成员相关信息，没什么好说的。这里主要的就是一个通知函数，但是在UML类图中去看一个函数的实现是不现实的，这个留到等下的代码实例中去分析。只需要注意的是，在这些个中介者类中，包含了一些用于连接的双方进行通信的一些方法。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><pre><code> 中介者模式的代码其实很简单，我也没有什么分析的欲望，自己看一遍也基本了解架构了，毕竟已经到了设计模式的相对后期了，一些简单的我就不想再进行一遍遍的分析了，之后碰到有意思的再来吧。
</code></pre>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> string&amp; message, <span class="type">const</span> string&amp; sender)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addUser</span><span class="params">(<span class="type">const</span> shared_ptr&lt;<span class="keyword">class</span> Colleague&gt;&amp; user)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Mediator</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象同事类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">    shared_ptr&lt;Mediator&gt; mediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Colleague</span>(<span class="type">const</span> string&amp; name, shared_ptr&lt;Mediator&gt; mediator)</span><br><span class="line">        : <span class="built_in">name</span>(name), <span class="built_in">mediator</span>(std::<span class="built_in">move</span>(mediator)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">receiveMessage</span><span class="params">(<span class="type">const</span> string&amp; message, <span class="type">const</span> string&amp; sender)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot; received message from &quot;</span> &lt;&lt; sender &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">        mediator-&gt;<span class="built_in">sendMessage</span>(message, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Colleague</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h3 id="具体类"><a href="#具体类" class="headerlink" title="具体类"></a>具体类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatRoom</span> : <span class="keyword">public</span> Mediator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;shared_ptr&lt;Colleague&gt;&gt; users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> string&amp; message, <span class="type">const</span> string&amp; sender)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user-&gt;<span class="built_in">getName</span>() != sender) &#123;  <span class="comment">// 消息不发回给发送者</span></span><br><span class="line">                user-&gt;<span class="built_in">receiveMessage</span>(message, sender);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addUser</span><span class="params">(<span class="type">const</span> shared_ptr&lt;Colleague&gt;&amp; user)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        users.<span class="built_in">push_back</span>(user);</span><br><span class="line">        cout &lt;&lt; user-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; joined the chat room.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> : <span class="keyword">public</span> Colleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>(<span class="type">const</span> string&amp; name, shared_ptr&lt;Mediator&gt; mediator)</span><br><span class="line">        : <span class="built_in">Colleague</span>(name, mediator) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> string&amp; message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot; sends message: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">        mediator-&gt;<span class="built_in">sendMessage</span>(message, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> chatRoom = <span class="built_in">make_shared</span>&lt;ChatRoom&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> alice = <span class="built_in">make_shared</span>&lt;User&gt;(<span class="string">&quot;Alice&quot;</span>, chatRoom);</span><br><span class="line">    <span class="keyword">auto</span> bob = <span class="built_in">make_shared</span>&lt;User&gt;(<span class="string">&quot;Bob&quot;</span>, chatRoom);</span><br><span class="line">    <span class="keyword">auto</span> charlie = <span class="built_in">make_shared</span>&lt;User&gt;(<span class="string">&quot;Charlie&quot;</span>, chatRoom);</span><br><span class="line"></span><br><span class="line">    chatRoom-&gt;<span class="built_in">addUser</span>(alice);</span><br><span class="line">    chatRoom-&gt;<span class="built_in">addUser</span>(bob);</span><br><span class="line">    chatRoom-&gt;<span class="built_in">addUser</span>(charlie);</span><br><span class="line"></span><br><span class="line">    alice-&gt;<span class="built_in">sendMessage</span>(<span class="string">&quot;Hi everyone!&quot;</span>);</span><br><span class="line">    bob-&gt;<span class="built_in">sendMessage</span>(<span class="string">&quot;Hello Alice!&quot;</span>);</span><br><span class="line">    charlie-&gt;<span class="built_in">sendMessage</span>(<span class="string">&quot;Hey folks!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到其实真的是没有什么意思的，风紧扯呼，主要是很多的其实之前都有接触过，就不再赘述了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>中介者模式（Mediator Pattern）</strong> 是一种行为型设计模式，通过引入一个中介对象来封装多个对象之间的交互，从而降低对象之间的直接耦合性。对象不再直接引用或依赖彼此，而是通过中介者协调和管理它们的交互逻辑。</p>
<h4 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a><strong>核心要点</strong></h4><ul>
<li><strong>解耦</strong>：中介者模式将对象间的交互集中到中介者，避免了对象之间的直接依赖。</li>
<li><strong>灵活性</strong>：通过修改中介者，可以改变交互规则而不需要影响具体对象。</li>
<li><strong>复杂性转移</strong>：系统交互的复杂性由对象转移到了中介者，中介者可能会变得复杂。</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul>
<li>系统中对象之间存在复杂的多对多交互。</li>
<li>希望通过一个中心化的管理者来简化对象之间的关系。</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><ul>
<li>优点：<ul>
<li>降低类间耦合，提升系统可维护性和可扩展性。</li>
<li>将交互逻辑集中到中介者，便于管理。</li>
</ul>
</li>
<li>缺点：<ul>
<li>中介者可能变得复杂，容易成为“上帝对象”。</li>
</ul>
</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><ul>
<li>聊天室（所有用户通过聊天室交流）。</li>
<li>MVC 模式中，控制器作为中介者协调视图和模型的交互。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>三个原则</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>接下来简单看一下类间的5种关系。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/1.jpeg" alt="1"></p>
<span id="more"></span>

<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/2.jpeg" alt="2"></p>
<p>每个类框的创建遵守之前的规则。而对于子类，我们可以看到这里只写出了子类重写的哪些函数(假设这些个子类没有额外的对象)。也就是说，对于子类来说，不需要对父类中的对象再进行描述，使用空心三角箭头就能表示继承关系并使得对应父类的成员不需要再被描述。</p>
<p>再来详细分析下，对于空心三角箭头，俩端分别连接父类和子类。其中，箭头指向的是父类，另一端连接的是子类。</p>
<p>接着来看到第二种类间关系，<strong>关联</strong>关系。</p>
<p>这种关系其实很常见，就是一个类中引用了一个类。这个类可能是别的类，也可能还是自身的类，依照引用关系和对象的不同存在多种关系。</p>
<p>1~单向关联关系</p>
<p>这种关系就是一个类中包括了另一个类(需要是一个与本类不同的类)，并且被包含的那个类不知道包含它的类的信息。父子或母子之类的关系的类建模</p>
<p>使用带箭头的实线进行连接</p>
<p>2~双向关联关系</p>
<p>这种关系就是一个类中包括了另一个类(需要是一个与本类不同的类)，被包含的类中也包含了包含它的类。学生与老师的类建模抽象。</p>
<p>使用不带箭头的实线进行连接</p>
<p>3~自关联关系</p>
<p>这种关系就是一个类中包含了指向本身同一种类的引用。就比如树的节点类。</p>
<p>使用指向自身的带箭头线进行连接。</p>
<p>当然，总总这些绘图线段都不是一定的，取决于使用的绘图软件。</p>
<p>接下来看下一种关系	<strong>聚合</strong>关系</p>
<p>这个关系乍看起来有点抽象。其实可以通过教室和学生，图书馆和藏书间的关系辅助理解。一个教室中可能会有多个学生，图书馆中也包含着系列藏书。这俩者之间构成了一个聚合关系。</p>
<p>对于聚合关系，就比如教室和学生这种。我们需要理清下这俩者之间的关系。无论教室还是学生，都是可以独立存在的，但是吧，教室中没有学生这些对象的话，其实是没有存在的意义的。对于独立存在的学生，不同于教室，他们独立存在是有着自己的意义的。从某种意义上这个也可以成为识别聚合关系的一种方法。	同时，这些聚合关系中，拥有的对象通常不只有一个。就比如教室中的学生，数量通常都是多个。在这种架构下，我们去取出其中的一个学生对于教室这个整体其实是没有很大影响的，当然这得是在一种至少不是很少的情况下的。你如果要说只有几个学生的这种情况我也无话可说。</p>
<p>以一种C++的类来看吧，如果一个类中包含了多个别的类的数组，当我们对这个主类进行析构的时候，这些个包含的子类并没有被析构的话，可以看做这些类之间是一种聚合的关系。</p>
<p>在这里我其实对聚合关系和关联关系有点疑惑。不过可以这么理解，类间关系是不一定存在一种的。或者说，类间关系是由类的属性而产生的，而不是由类间关系而产生的类。聚合关系某种程度上可以看做是关联关系的子类。聚合关系一定是关联关系，但是关联关系不一定是聚合关系。</p>
<p>如果类间是一个聚合关系，那么这些类之间应该使用空心菱形的直线进行连接。菱形与聚合的整体相连，另一端与对应的部分相连。</p>
<p>举出一个聚合类型的例子</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/3.jpeg" alt="3"></p>
<p>接下来看另一种关系	<strong>组合</strong>关系</p>
<p>使用实心菱形线段进行标识组合关系。与上相似故略过</p>
<p>组合关系也是一种整体和部分的关系。很多方面它跟聚合关系都很相似。但是这里相对于聚合关系不同的是，这里的部分其实是依赖于整体而存活的，当主对象被析构时，这个组合关系的部分类不应该还存活着。举个例子，就比如头和嘴巴，眼睛，眉毛等。后面的部分在整体消失时不应该还存在(你杠就是你对)。</p>
<p>这样看来，通过组合关系联系的各个类相对于聚合关系有着更为紧密的联系。以C++的视角来看的话，就是当组合关系中的整体类被析构的时候，它对应的部分类也应该被析构掉。</p>
<p>接下来来看类与类之间最弱的一种关系	<strong>依赖</strong>关系</p>
<p>依赖关系的判断有点抽象。可以用排除法来进行。如果一个类既不是继承.关联.聚合.组合关系，那么它就是一个依赖关系。你可以看出这个关系有多弱了吧。</p>
<p>当然，还是有不通过排除法来进行判断的方法的</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/4.jpeg" alt="4"></p>
<p>当我们一个类使用了另外一个类作为本类的函数参数。在函数参数内使用了别的类作为本类函数的一个局部变量，一个类中调用了别的类的静态方法。这三种情况下，这些个类之间构成了依赖关系。当然，其实这个相较于排除法其实更难判断了。</p>
<p>依赖关系使用带线头的虚线进行标识，由依赖的一方指向被依赖的一方。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/5.jpeg" alt="5"></p>
<p>对于类图关系，类之间是可能存在多种关系的，但是我们不需要将全部关系都列出来，我们只需要将这些类关系中最强的关系描述出来就行了。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>UML类图</category>
      </categories>
      <tags>
        <tag>UML类图</tag>
      </tags>
  </entry>
  <entry>
    <title>三个原则</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>对于所有的设计模式，无论思想是什么，都遵守三个基本原则：</p>
<p>单一职责原则，开放封闭原则，依赖倒转原则</p>
<span id="more"></span>
<p>对于这三个原则，与其说是设计模式所遵守的原则，不如规定为我们程序设计中应该遵守的原则。在程序设计中，即使我们对设计模式不是很清楚，但是如果我们设计过程中遵守这几个基本原则，那么设计出来的程序还是会很优雅的</p>
<p>首先来看到<strong>单一职责原则</strong></p>
<p>这个原则在应用场景中其实就是<strong>面向对象</strong>。这个原则注意的本质上就是在类的设计中让其负责的功能尽可能的专一，使得我们在设计过程中可以更加专注于特定功能的实现，能够减轻我们的设计压力和维护压力。</p>
<p>举个简单的例子吧，就比如不久前做的那个堆排序作业。其实现在看来heap类的设计是存在大问题的。这个类负责的功能太多了，它既负责了对于数据的对排序处理，又负责了对于堆排序的渲染。这就导致了我后期在debug时想要去找到对应的错误位置需要去找到整个类中存在的错误。而此时类简单看实现代码行数已经达到了小几百行。这是要去debug是极其不易的。确实有亲身体会。</p>
<p>因此，这个单一职责原则的目的就在于各个功能模块间的实现分离。通过这种分离，我们能够实现更加高效的设计和debug。就比如，当你数据构建层面出错就去找对应数据构建的类。当你渲染出现问题就去找对应渲染的类。同时类功能的分离也能提高代码的复用性。</p>
<p>就比如那个heap类，由于我们将渲染模块和数据模块都耦合到了一起，如果我们想要在这个项目中再去添加与现在的排序类相似的类，我们是无法复用现在已有类的渲染模块的。直接继承将是一个糟糕的注意。而且我们已有的渲染模块是基于heap类去设计的，即使我们想要cv，我们也得考虑新类的设计，这是代码低复用性的体现。相反，我们应该考虑的是一个隐藏实现细节的渲染类来进行各种排序的实现。让heap等排序类专注于数据层面的构建，通过设计出render等渲染类来实现对应的渲染动画。</p>
<p>因此，在我们设计类的时候，我们要尽可能的让类的功能尽可能的单一，通过不同类之间的配合再来实现复杂的功能而不是一股脑塞在一个类中。而且这在类的定义中也可以看出类的设计初衷就是让我们设计一个功能单一的类。类是一组相关属性和行为的集合。注意这里是一组而不是多组。我们在任何时候都不应该有万能的这个概念，毕竟这个概念是不符合我们的设计逻辑的。尽管用户层是希望一个万能，但是用户层的万能与底层的万能不能等效。</p>
<p>接下来看第二个原则	<strong>开放封闭原则</strong></p>
<p>其实这个原则就是<strong>单一职责原则</strong>的延续。简单来说，如果你的一个类很好的遵守了单一职责原则，换句话说这个类在一个功能上做到了极致，那么无论你添加什么这个类的功能都不会有什么改变。同时，你会发现如果一个类很好的遵守了单一职责原则，那么当出现新的需求时，仅仅依靠现在的类是无法解决的，那么现在就需要进行扩展，那么此时我们就有俩种方式来进行扩展。一种是直接修改我们现在的类去添加对应的功能，但是正如我们前面所说，这样其实是未被单一职责原则的。那么，内求失败后，我们需要外求。</p>
<p>既然外求，由于我们还是需要遵守单一职责原则，那么我们应该考虑实现一个新的类来实现我们新增的功能，而且一般来看这个类是需要和已有的一些类进行联动的。但是这个设计过程并不应该影响到已经设计好的类。在这个新增的类设计完成后，我们应该考虑把这个类和原先的类打包到另外一个大类中去实现。这种设计下，这个大类就对原有的功能进行了扩展，而且俩个小子类又都遵守了单一职责原则。</p>
<p>好，回来看看我们哪里体现了开放封闭原则。首先，我们实现了对已有功能的扩展，这是一种对于原有设计的开放性质的阐述。其次，我们并没有对原有的类进行修改，已完成的类是相对来说封闭的，这是封闭的性质。</p>
<p>这个封闭属性是相当重要的。毕竟如果一个类保留了它的封闭属性，那么它一般是通过了一定的测试，能够稳定运行的，如果我们去对这个类进行添加修改等破坏了它的封闭性，那么对于原有的哪些个用到封闭的类的api地方，又有可能导致一些奇奇怪怪的错误产生。而导致必须对整个类全部进行重新审核和测试。</p>
<p>举个例子吧，在现实中，我们通常可以看到一些男人在外部工作，不理家中事，但是家里还是被老婆打理的不错。这就是一个典型的开放封闭原则的示例。别杠，再杠让你飞起来。家庭是一个大类，这个大类中包含了一个负责家庭资金供给的父亲，一个负责家庭打理的母亲，还有其他一些杂七杂八的东西。种种这些相互独立，但是又组成一个整体。我们可以看做每个对象之间相互独立，但是多个对象构成了一个大类达到了一种和谐。</p>
<p>这个其实在QT中可以窥见。在QT中，其实已有的库可以视作一系列的具有封闭属性的库，我们在设计中要做的一般也是设计这些具有封闭性的类。然后，我们会在一些特别的类中，就比如，一个项目初始的窗口类中去进行这个小类的实例化与调用。这也是一种开放封闭原则的设计实例。</p>
<p>接着再来看一些需要注意的地方。就是即使我们实现了一些新的类，我们怎么去实现这些新的类与已有的类之间的联动。这里就需要我们在设计类是预留一些接口。这个接口一般来说是可以预见到的，就比如，商场的购物通常会有”打折”这种事情发生，可能是几折几折，也可能是买一送一等等，但是这些都有一个共性，就是他们都是”打折”这件事。因此，我们在设计商场购物的对应类中，我们应该预留一个专门的接口用于打折以实现以后可能存在的扩展。这个其实身边就能看到，就比如我们的笔记本，笔记本保留了相当多的插口供我们使用，而且一个插口可以使用不同的设备，只要这个设备的插口符合我们笔记本的接口规范。</p>
<p>这种接口的设计一般是通过<strong>多态</strong>的特性来进行实现的。在父类中去预留一个虚函数接口，当我们想要一个具体的打折方案后，我们去继承这个父类并对这个方法进行对应的重写，通过使用这个重写类去对父类进行替换，来实现我们打折方案的改变。而且由于继承这种关系，所以这些个父子类间的差异就在与这个重写的接口类处，不用太去担心冲突问题。</p>
<p>一般来说，这个接口是一个虚类的父类指针以提供该虚类的系列子类的指向。</p>
<p>这种<strong>开放封闭原则</strong>能够保证程序的可扩展性，可维护性，可复用性。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/1.jpeg" alt="1"></p>
<p>接下来看第三个原则，<strong>依赖倒转原则</strong>，话不多说，直接上图</p>
<p><strong>高层模块不应该依赖低层模块，二者都应该依赖于抽象；</strong></p>
<p><strong>抽象不应该依赖细节，细节应该依赖于抽象</strong></p>
<p>再解释下高层模块和低层模块。高层模块就是编写的应用程序，也就是应用层，这个你应该可以理解。接下来注意一点，我们要分析的是底层模块，而不是底层模块，所有位于高层模块下的模块都是低层模块。抽象基本就等价于C++中的抽象类以及各类的api。</p>
<p>举例下这里的直接依赖，就比如一个外卖系统中，通过使用一个数据库系统来实现数据的存储与使用，如果直接使用一个具体数据库的引用，那么这个就是直接依赖。而我们<strong>高层模块不应该依赖低层模块，二者都应该依赖于抽象</strong>的目的就是避免这种直接的绑定。你可以想象，你游戏账户直接绑定一个手机号，那么当你绑定的这个手机号出现了问题，你这个游戏账号将会导致一系列的问题，就比如我们无法去登录等。</p>
<p>而为了避免这种情况，我们的想法是通过一个中间层来进行缓冲，而这个的作用就是实现高层模块和底层模块的隔离，避免这俩者之间的直接调用。而且对于这个中间类(抽象类)需要有几个规定。最简单的一点就是这个函数必须在高层和底层的代码发生改动时不必要去修改另外一边的代码，起到所谓的隔离作用。通过这种隔绝，我们能够使得修改代码时只用去关心对应代码区域的修改而不用去关注全局代码的更改。</p>
<p>在使用时，我们一般是需要高层模块来使用这个抽象的api的，在c++中，这个就是所谓的虚函数。但是吧，一般来说，我们的这个抽象的父类是不会提供具体的实现也是不应该提供具体的实现的。需要在对应的子类中去进行具体的不同功能的划分与实现。</p>
<p>这个就比如吧，我们在进行一个项目的设计中，前期由于一些设计方面的问题，直接使用了mySQL数据库作为使用的数据库。但是在之后的发展中，由于数据的堆积，这个数据库无法满足我们的需求了，我们需要去替换一个更大的数据库，此时如果我们是直接调用的mySQL的数据库的话，那么我们在替换这个数据库的时候，我们需要去把全部用到mySQL的地方都进行更改，这个工作量是巨大且不可接受的，因为这个会导致前面已经通过测试的代码需要全部重新审批。但是如果我们引入了一个中间层来进行设计，提供一个统一的一个接口，我们只需要去注意我们使用接口的对象的替换就行了。如果我们设计的足够合理，我们就只需要去替换这里就行了，这个设计架构就相对于前面的全局替换高效了不止一星半点。</p>
<p><strong>抽象不应该依赖细节，细节应该依赖于抽象</strong></p>
<p>重新来分半简述下这句话</p>
<p>抽象不应该依赖细节：抽象(如接口或基类)不应该直接绑定到具体实现上，而是应该独立存在。简单来说，我们的一个基类函数，不应该导致我们这个抽象的接口被固定了，我们不应该给其提供实现，或者至少说不应该限定它只能有一个实现。简单以实现来看的话，我们不应该限定我们的基类函数为不可改变的。至少是一个virtual的，至于要不要是纯虚函数取决于具体的环境。这种设计下，抽象就不会被绑定到一个具体的实现上，至少来说可以是在子类中重载的。</p>
<p>接下来看后半句话，<strong>细节应该依赖于抽象</strong>。具体的实现(如派生类或子类)应该遵循抽象层定义的规则(如接口或虚函数)。是说，这里的子类的具体实现不应该脱离我们使用的抽象层来实现。还是回到c++中，就是说我们的子类的实现不能够脱离我们基类的根本目的。只有按照基类设计的目的去设计对应的子类，我们才能保证接口能够正确的被使用。</p>
<p>在这种设计中，我们可以进行一点设计层次上的分析。这里调用一个类的类就是一个应用层类似的。一个抽象类的基类其实就相当于一个中间层，提供了一系列的接口，但是这些接口通常是没有意义的，或者说应该是没有意义的。具体的实现应该在这个抽象类的子类中进行实现。通过这样，我们就实现了一种隔离，通过这种隔离我们能够实现本来高耦合的降低。</p>
<p>也就是说，在这种设计要求下，我们如果选择在子类中去进行一些基类中没有的功能的扩展，我们需要在基类中预留一些接口函数去等待这些接口函数的插入。通过这种实现我们能够实现避免大量修改原有的代码。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/3.jpeg" alt="3"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/4.jpeg" alt="4"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/2.jpeg" alt="2"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/5.jpeg" alt="5"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/6.jpeg" alt="6"></p>
<p>接下来看一个重要的原则，<strong>里氏代换原则</strong>。</p>
<p>这个原则其实很好理解，它本身要求的是子类类型必须能够替换他们的父类类型。我们也应该知道这个规则在QT中时相当常见的。就比如一个窗口类函数参数，我们可以使用对应窗口类的一系列父类和子类，只要他们是QWidget类或者其派生类的就行。而这种课替换性就是里氏代换原则所要求的。</p>
<p>要实现这种原则，就必须要求多态这个面向对象特性。父类指针可以指向子类对象。</p>
<p>对于这种原则，需要简单了解的就是子类必须实现父类中全部要求的接口函数。</p>
<p>额外需要注意我们这里提到的里氏代换原则的目的，只有拥有这个原则的设计，我们才有可能保证依赖倒转原则。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/7.jpeg" alt="7"></p>
<p>简单来看的话，这个原则要求我们在设计高层模块是我们只需要&#x3D;也只应该去调用虚类中的父类函数，而不要求我们去了解我们的子类的附加函数，我们应该通过父类的对应接口就能够调用所有的子类方法。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式(2)</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6-%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>接下来看一下单例模式中的一种区分方法，这种方法将单例模式区分为了（懒汉模式）（饿汉模式）。其实这俩者没什么特别的，其实就是我们常见的是否懒加载的一种区分罢了。对于懒汉模式，一般不会在初始化时就进行new一个对象，而是指定一个空指针，等到存在一个具体的指针想要用到这个对象时我们才会去new一个出来。而饿汉模式就是在初始化时就直接对这个对象进行创建。</p>
<span id="more"></span>

<p>同时我们来考虑一些别的东西，我们知道懒汉模式是一种懒加载，饿汗模式是直接创建，那么这里其实是会在多线程时可能出现一些问题的。对于多线程下的饿汉模式，由于是已经创建了一个实例对象的，我们去取到对象是不会导致一个重复的内存申请的。因此它是一个线程安全函数。而如果是懒汉模式呢，我们是在调用静态公有函数时才去创建函数的，照我们CSAPP的学习，有没有一种可能，在我们调用这个函数时，发生了一个上下文切换，且同时切换到了一个申请语句，这样的话导致了我们想要去分配一个已经被分配的内存而导致程序崩溃。所以说，简单的new而不加任何保护的懒汉模式是线程危险的。同时，也是会破坏单例模式的性质的。</p>
<p>但是，我们其实也可以想到这种危险的解决办法，就是加锁嘛，接下来讨论这个。</p>
<p>现在我们来看使用<strong>双重检查锁定</strong>的方法来进行懒汉模式下的单例模式的线程安全问题解决。</p>
<p>算了，直接上代码，就能够理解了。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6-%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/1.jpeg" alt="1"></p>
<p>首先，我们通过一对互斥锁将m_task的示例锁起来以防止线程冲突，这样的话确实能避免线程安全问题，但问题是这样的话效率太低了。分析一下，当一个线程获得一个锁后，其它的所有线程会进行等待，直到锁被释放，以此类推。而且我们来分析下这几个内层的性能消耗，每次进入都会进行一次加锁和解锁操作，至于判断和创建的，是不可避免的，不纳入考虑中。</p>
<p>这里我们需要考虑这里加锁和解锁操作，我们如果是单层检查锁定的话，每次都要进行加锁与解锁的操作，而这个是相当耗时的。这个会将懒汉模式相较于饿汉模式的性能优势丢失掉大半。因此，我们需要考虑通过一些操作来进行这里的锁操作的简化。这里就是考虑直接在外层再套一层条件判断，就是图中的成品。</p>
<p>在这种设计下，假设啊，先假设，所有的线程在运行时是同步到调用函数这一步，且切换到一个线程后该线程至少完整的执行了这个函数。那么我们来看。当一个进程运行完后，对应的m_task被实例化，接着切换到下一个线程，先进行外层的条件判断，由于，已经实例化，所以这里会直接跳转到返回语句，不会再进行加锁和解锁的操作。这样就很大程度上解决了线程安全问题。</p>
<p>但是，我们也不难想到，这样的设计在极端情况喜爱还是可能存在问题的，就是多个线程都运行到了条件判断的内部，但是这种说实话真的太极端了。但是这种情况还是不能够忽略的，所以这里我们就需要来进入下一步。</p>
<p>我们在CSAPP中已经知道了底层程序到底是怎么动的，其实对于程序来说，这里的代码顺序可能会因为编译器的奇怪优化而被重排顺序。这里关注到这里的new一行的操作。正常来说，我们期望的顺序应该是先去new一块堆区的内存，此时的内存是空白的。接着程序应该在这块内存中进行操作，去进行各个对象的初始化等创建操作。最后，程序应该把这块的内存地址送给我们的m_task指针。此时就完成了一个new操作。</p>
<p>好，现在我们停下来，我们应该了解，对应的new操作对应的是一系列的汇编码。编译器的优化会导致这一系列的汇编码的顺序不可预测，就比如一种情况，程序先去申请一块内存，然后先将指针送给了对象，最后再调用构造函数进行初始化。这样是一种可能的情况，在单线程的情况下，这种重排是不会出现问题的。但是，我们考虑在多线程呢。如果一个线程在重排后的第二步，也就是指针赋值的这一步中进行了上下文切换，那么此时指针指向一块确实存在但并未初始化的值。此时接下来的线程如果也进入了这个函数，那么由于此时指针确实是存在地址的，那么程序将会直接从这个函数返回。而且由于这块地址是还未初始化的，那么这个线程接下来的所有有关该块内存区的操作将是非法的。直到线程重新切回之前那个卡在第二步的，知道其完成第三步其他线程才能正确执行。但是，一般来说，等不到那个时候，程序已经崩溃了。</p>
<p>为了解决这个问题，由于我们无法去确定编译器的行为，而且，不同电脑对于代码的优化是不尽相同的，所以想要去指令汇编指令的生成顺序是不现实的。你自己搓那你牛逼。所以这里我们需要使用到一个相对高抽象程度的特性，就是C++11中的原子变量。这个其实也是老朋友了。</p>
<p>C++中提供的原子变量是<strong>atomic</strong>。这个变量可以用来控制使用这个变量的相对于变量在底层中机器代码的执行顺序。如果我们将一个数据储存到原子变量中，那么这个数据对应的机器代码执行顺序我们就可以通过这个原子变量来进行指定。</p>
<p>对于一个原子变量，我们可以通过store方法来进行一个变量的塞入，可以用load方法来进行一个变量的取出。同时，我们还可以指定对应的执行顺序到底是一个什么样的，存在一个默认方法就是顺序执行。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6-%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/2.jpeg" alt="2"></p>
<p>将一个变量储存在原子变量中，再取出这个原子变量所管理的元素的话，这个元素就能够保证是以指定的顺序进行运行的。来分析一下这里的使用原子变量的版本。首先进入函数体后，使用load方法将对应的原子变量管理的取出。接着进行第一层判断，假设我们这里存在多个线程都完成了取出的这一步，然后会在条件判断这一块进行上下文切换的。此时所有的线程都会被阻塞在互斥锁这一行上。第一个碰到的线程将会取得互斥锁，其他的将会被阻塞。</p>
<p>接下来需要进行第二次加载，此时第一次拿到锁的对应的变量将是一个空指针，因此会进入内层循环，接着由于原子变量的属性不会对指令进行重排。所以接下来的new操作将会以申请内存，初始化(调研构造函数)分配指针的顺序进行。请注意，所谓的原子属性不会使得时间片延长，所以这里时间片到期了还是会进行线程的切换，但是其他的所有线程都会被锁给阻塞而不会进入这一层所以可以视为一种连续的操作。接着第一个取到锁的程序一直跑直到锁被释放。请注意，这里还是可能进行上下文切换，我们不能够假设这里一定会运行到整个函数结束不被打断。我们能假设的只有在整个锁中的执行不会被打断。</p>
<p>好，此时当第一个锁被释放后，程序的其他线程将能够获取对应的锁，此时拿到锁的线程将能继续往下跑，前面已经假设这些线程都已经跑过了第一层判断。那么这里的lock方法就体现了它的作用。这里的lock其实起到了一个更新的作用。如果这里没有这个函数，那么这里将会导致一种在已经初始化的情况下再视图进行一次初始化，这里就是双重检查的目的。那么由于这个更新，这个非第一个获得锁的线程将会直接条状到返回语句。并不会导致前面那种不依靠原子变量可能存在的线程安全问题。</p>
<p>除了使用双重检查锁定+原子变量来进行单例模式的设计，我们还可以使用别的一种方式来进行等效的设计，这个就是局部静态对象。而这个是C++11的特性，所以至少编译器需要支持C++11的版本。</p>
<p>这个解决方法不需要原子变量，也不需要互斥锁。</p>
<p>首先来看一下这里局部变量能够实现功能的技术基础。这个是依赖于C++11的一个新特性的</p>
<p><strong>如果指令进入一个未被初始化的声明变量，所有并发执行需要等待这个变量完成初始化。</strong></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6-%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/3.jpeg" alt="3"></p>
<p>简单分析下，我们在getPoint函数中直接去创建一个静态类对象，这里缺少一个初始化操作，之后再补。就当其他的线程运行到这个函数时，由于C++11的特性，其他所有线程都被阻塞，知道第一个到达的线程去进行对应的初始化。当系统切换到其他的线程后这些个线程才能继续往下走。这是利用C++11的新特性来进行解决懒汉模式下的线程安全问题的一种方法，而且这种方法相对于前面的要使用原子变量和互斥锁的简单许多，设计上简单，而且一般来说效率也更高。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7-%E5%B7%A5%E5%8E%82%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>接下来看创建者模式中另外的重要的设计模式，<strong>工厂</strong>。这个工厂具体能细分为3类：简单工厂模式，工厂模式，抽象工厂模式。</p>
<span id="more"></span>
<p>工厂模式主要就是俩块，一块是工厂，可以将这一块理解为下订单的，它负责根据用户提供的需求来提供具体的产品。另一块是产品类，这一块负责具体产品的制造。注意的就是这里的产品制造和工厂在实际应用中都将会被抽象为类。</p>
<p>通过这样的设计，我们将能够值通过给工厂下达指令来获取产品。而工厂本身并不生产产品，它将生产产品的这一职能外包给了产品类。通过这样的设计。我们实现了获得产品，生产产品三个层次的解耦。从类的设计来看就是，工厂类中不涉及任何一个产品的对应的生产代码，其应该保存的是一个产品基类的指针等，工厂类可以通过这个指针去找到对应的类，而这个找到的类的类型将会由外部调用工厂类的对应函数的对应参数来决定。然后工厂类通过接口去指示对应的产品类去生产对应的产品，然后逐层返回实现产品的生产以及获取。</p>
<p>对于一个工厂能够生产的对象，其实是有一定的要求的。你按现实生活中的逻辑来看你应该也能够理解。毕竟在工厂模式的设计中，我们期望是根据具有一定相似度的原料和不同的要求来生成不一样的产品。在这里类的实际设计中也是这样，我们通常期望通过统一类型的参数过户，至少需要各个产品类需要的参数类型一直，数量上也有一定的规律，我们才有可能通过一定的设计规范来设计出生产产品的选择逻辑。在现实中也是如此，你总不能让一个医院去给你生产一个医疗系统吧，这个应该是IT公司的业务，所以在设计时我们需要考虑我们这个工厂想要生产的类的属性是怎么样的，具有越强关联性的产品类设计起来将会越符合规范。</p>
<p>在进入工厂模式之前，我们先来看一下简单的模式要求。在工厂模式中，我们需要一个工厂来作为我们获取产品的渠道。这个工厂应该能通过我们想要的产品的种类来实现对应产品的生产与提供。而我们在外部调用这个工厂进行生产的话，无疑，我们需要提供一些产品的信息，就比如产品的名称等等。最简单的就是提供一个产品的枚举名来进行制造。我们这里先不对别的参数进行讨论。</p>
<p>假设工厂的api能够根据我们提供的枚举类型来进行对应的产品生产，那么接下来我们需要考虑设计的就是对应的产品类。一个工厂应该能生产不止一个产品。但是这多个产品之间应该存在一些紧密的联系，就比如现实生活中你不能期望让一个汽车生产商区生产家具吧。</p>
<p>让我们来考虑下这里的工厂api函数。这个函数能够根据我们提供的参数来提供不同的产品。但是我们的返回类型是一开始就指定的。所以这里需要我们用到多态的特性。即父类指针能指向子类对象。因此，我们所有的产品类都应该是一个类的子类。一般来说，这个父类应该是一个抽象基类，它本身不应该是一个可以实例化的对象。通过多态的这种特性，我们能将一个具体的产品分发到细致的类中去，把各种产品之间的生产进行隔离。就比如不同类型的口罩(n95,kn95)之类的生产应该是由不同的流程进行的。通过对这种各个不同产品间的解耦，我们能够更加细致的实现对于具体的生产流程的管理以及修改。</p>
<p>从现在来看，整个工厂模式就分为了三个层次。最上层指的是发出生产指令的层次，在这个层次中我们通过一些参数向工厂提出需求，工厂需要给我们提供这些需求对应的产品。此时调用层不必去关注产品是怎么来的，只需要去考虑怎么接收这个产品即可。</p>
<p>第二层是工厂层，这也是一个中间层，这个层次负责生产的调度工作，它负责接收申请者的需求并进行解析去明白到底要制造哪种产品，接着它会向对应生产该产品的产品类发出需求，并等待产品被制作完并返回给工厂。在这个过程中，工厂并不关注产品是怎么制作的，它只考虑怎么去接收这个产品并打包发送给需求发出者。</p>
<p>第三层是产品层，这是三个层次的底层，这个层次负责具体产品的生产。它负责响应工厂发出的请求，并根据原料(特定参数)来进行特定产品的生产,这里的产品其实就是类的实例，毕竟类就是具有一系列相同属性的集合，这也是一种对于现实生活中存在的事物的抽象建模。在这个产品层中，每个产品都应该有着一定的联系，或者说，应该有着一定的相似度。这样能够减轻我们设计的负担，每个产品类应该是一个抽象类的具体实现，就比如n95,kn95都是隶属于口罩这个父类之下的具有各自独立属性的类，但是这些之间是具有相对来说比较多的共同属性的。在产品层生产完产品之后，产品层只需要将生产完的产品打包发送给工厂即可，剩下的细节它无需考虑。</p>
<p>工厂模式的简单分析就是上面那一块了。我们可以很明显的看到，在这个工厂模式的设计中，各个层次间的分工是明确以及细致的。而且各个层次之间只用考虑各自需要完成的事，至于与其他层次间的沟通，一般只由少数几个简单的接口来进行沟通，这样大大减小了三个层次之间的耦合度。更加使得各个类的分工明确，设计思路清晰，且我们在后续的调整中也更好的去进行定位和修改。</p>
<p>工厂模式的简单测试代码已经在文件夹中了，有兴趣可以一看</p>
<p>接下来来看到工厂模式。其实吧，对于前面的工厂模式，其实你在搓的时候其实能够感觉到，你现在设计好的工厂确实是符合设计模式三原则的。但是吧，如果在项目后期你想要添加一些额外的产品类时呢，这个是完全有可能的，此时如果是简单工厂模式你就需要去修改我们工厂生产产品的api了，至少你也需要去添加对应的生产代码，但是这种直接修改显然违背了三原则中的开放封闭原则。我们这种对于原有代码的直接修改破坏了类的封闭性，这是不可接受的。同时，如果要在基础上直接去添加对应的代码，这其实就是堆成一坨屎的过程了，这是不利于我们后期的维护的。因此，这里我们引入工厂模式。</p>
<p>在工厂模式中，我们将深切体会到一句话，<strong>我们要做的，不是修改，而是扩展。</strong>网上说的<strong>一个代码能运行就不要去动它</strong>其实是遵守设计模式的。但是很多蠢逼就只是意味代码能跑就行根本不会去深入理解这句话里面蕴含的含义。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7-%E5%B7%A5%E5%8E%82%E7%AE%80%E4%BB%8B/1.jpeg" alt="1"></p>
<p>好了，我们回来，我们来一个工厂模式的架构，这个架构非常清晰的解释了工厂模式下的系统架构。即每个产品应该对应一个工厂，一个工厂会且只会生成一种产品。当我们需要添加一种产品时，我们需要同时添加一个产品类和对应的工厂类。</p>
<p>在这种设计下，工厂模式的工厂相较与前面的简单工厂模式的工厂，其的职责更加明确，更加贴合了三原则中的<strong>单一职责原则</strong>。同时，这样更加方便了我们后续的开发与维护，我们不再需要去破坏原有的封闭性，而只是利用开放性去添加。需要debug时我们的定位也更加的简单等等。</p>
<p>总的来说，工厂模式是依靠在实际生产工厂类和产品的抽象基类之间再添加一层缓冲来实现的。通过这层缓冲，我们又一次的降低了各个模块间的耦合度。更加适合于我们大规模的设计，更符合了我们设计模式的三原则。</p>
<p>好，接下来的代码会在文件夹中，自行查看。</p>
<p>抽象工厂直接摆，自己看代码。</p>
<p>简单来看一下抽象工厂模式下的组成吧。</p>
<p>可以说，抽象工厂模式是在简单工厂模式和工厂模式下的再一次分包。</p>
<p>工厂模式相对于简单工厂模式，就是在提出需求的甲方和生产商之间进行一层缓冲层的添加。而抽象工厂模式则是在产品生产的这一块之间进行的缓冲层的添加。将产品的生产分包成多个零件的生产，产品类负责这些个零件的组装。</p>
<p>重新来分析下抽象工厂模式下的架构。第一层自然是提出需求的一层，可以视为所谓的用户层，在这一层中，通过提出对应的需求给工厂来获取需要的产品。并不关注产品的生产过程只关注产品的获取与使用。接着是一层抽象工厂缓冲层，这一层提供了一些api供用户层进行调用，这一层规定了这类工厂所要生产的产品的基本属性或者说共有属性。但其本身并不负责生产，可以将其视为是一类产品的生产规范。</p>
<p>在抽象类的下面，就是具体的工厂类了，这些工厂类依靠着上层的抽象类提供的api接口来进行对应的生产，请注意，这些个工厂类只是负责了零件的组装，而不负责零件的生产。在我们的设计中，我们考虑使用不同的零件组合来组合形成我们的具体工厂类将要生产的一系列具有不同性质的产品。</p>
<p>接下来就是具体工厂类与具体产品类之间的缓冲层，在设计中就是一个抽象产品类，这些抽象产品类一般拥有多个，而一个抽象产品类下面又有可能派生出多个具体产品类，这个等下再说。在这些个抽象产品类中，定义了我们接下来的具体产品类中所应该有的共同属性，并提供了一个或多个接口来联系上下俩层。</p>
<p>接下来就是具体的产品类了，这些产品类只通过上层提供的api接口进行与工厂类的联系。各自注重于自身的实现逻辑即可。这些已经在前面的工厂模式中重复提到了，这里就不用再进行赘述了。</p>
<p>总的来说，如果简单的画出一个类的架构来看的话，其实可以很清晰的看到。我们用户层与抽象工厂所联系，并通过抽象工厂去找到生产特定产品的具体工厂，这些具体工厂下辖着多个具体零件类，而这些零件类有着一定的组成逻辑，就是说一个产品的生产需要哪些零件的类型，而这个是由抽象类决定的。但是具体选择哪些零件来生产产品，是只在具体工厂类中决定的。在最底层的零件架构中，每个工厂类下辖的零件是一套但是各个不同种类的。在这一系列具体零件类中，我们可以通过抽象零件类对其进行分类，使其归于一个零件类进行管理。简化了设计的复杂度。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7-%E5%B7%A5%E5%8E%82%E7%AE%80%E4%BB%8B/2.jpeg" alt="2"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7-%E5%B7%A5%E5%8E%82%E7%AE%80%E4%BB%8B/3.jpeg" alt="3"></p>
<p>好，现在基本就看完了工厂这种设计模式的三种情况，让我们来进行一个总结。</p>
<p>首先来看到简单工厂模式，在这种模式下，我们只有一个工厂，一个工厂中有着多个产品类，在一个工厂中，我们通过对于用户需求的解析(不同的调用参数)来进行不同产品的生产。这种设计下的工厂层次就只有用户层，具体工厂层，抽象产品层，具体产品层。工厂与产品之间的耦合度还是比较高的，使用与一些简单的仅仅几个产品的生产环境，只要生产产品稍稍增多简单工厂模式就会急剧劣化。</p>
<p>接着来看到工厂模式，工厂模式在简单工厂模式上面又添加了一层用户层与工厂层的抽象，即抽象工厂层，用户通过抽象工厂层去找到我们需要的具体工厂，这个工厂一定会对应着其所需要的产品，因为这种设计下一个工厂将会只生产一种产品，不会像简单工厂一般负责一个或者多个产品的生产。在这种设计下，我们实现了工厂与产品生产间的解耦，使得我们在添加产品和对应的工厂类的时候不再像简单工厂那样会导致急剧的性能劣化，而且很好的符合了开放封闭原则。在大多数的生产环境下都能够使用。</p>
<p>接下来看到相对来说最复杂的抽象工厂模式，在这种模式下，用户层下面是一个抽象工厂层，用户可以通过这个去找到对应的具体工厂层。在抽象工厂层中，其规定了工厂到底要生产什么产品，就比如船等实际物品。在设计中，这些实际物品对应的就是一个类，在抽象工厂中，这个一般是一个可多次实现的类，其中包含了该类中需要包含着的零件，但是并不具体表示由什么零件组成，这个将由我们的工厂来进行决定。</p>
<p>在进入工厂类之前，我感觉还是得先来看一下零件类。这些存在俩个层次，抽象零件类和具体零件类。抽象零件类规定了这一系列的零件所应该有的属性，并通过一个或几个api来进行与其他层次的沟通。好，回来我们的工厂类，在我们抽象工厂模式的具体工厂类中，这个工厂类应该规定了具体的零件类型将会是各个类型的零件中的哪一个。</p>
<p>也就是说，我们可以利用离散数学来进行理解。我们将每个抽象零件类类比做一个集合，其对应的具体子类就是集合中的元素。而一个工厂类中的组成，就是这些个域进行笛卡尔乘积中得到的集合的一个元素。而整个工厂类组成的大集合又还是这个笛卡尔乘积的一个子集。</p>
<p>通过离散数学，我们能够对抽象工厂模式进行更加清晰。也就是说，我们的抽象工厂模式规定的其实是一个元组所需要的属性(用数据库的名词来进行解释下吧，词穷了)，而我们抽象工厂下辖的具体工厂就是具体的元组，这些个元组就是我们系列零件域的笛卡尔乘积的一个元素。</p>
<p>在抽象工厂模式中，由于我们引入了零件类这一概念，所以我们可以自由的进行组合，也就是任意取出一个具体的笛卡尔乘积值来作为我们的具体工厂的组成。而且，当我们需要去添加新的同属性零件时，我们只需要去添加对应的子类并使用就行了，而且这个新添加的零件还能引入一系列新的笛卡尔乘积值，大大提高了代码的可组合性。且开放封闭原则遵守的很好。</p>
<p>这样来看的话，抽象工厂模式的层次是相当清晰的，但是就是有点难以理解。对于这种模式，我们可以看到，我们需要在初始时规定好我们需要的零件的种类，也就是这些个零件域的数量，然后我们就可以规定好我们的抽象工厂类需要的这些个零件到底是什么。然后就可以看到具体工厂类中了，我们去考虑我们到底需要哪些个零件域集合笛卡尔乘积的结果，并将其实现在具体工厂类中的api接口中，这些接口是由抽象工厂类定义提供的。现在不就都连起来了吗。豪玩！！！！！</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7-%E5%B7%A5%E5%8E%82%E7%AE%80%E4%BB%8B/4.jpeg" alt="4"></p>
<p>枯燥的生活有了这破ai倒也不会那么单调。要是再真实点给我提供下情绪价值就好了。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>接下来我们进入到建造者模式中最麻烦的模式，生成者模式(<strong>建造者模式</strong>)。这种模式可以看做是对于抽象工厂模式的一个方面的改良。我们先回来看到抽象工厂模式，在抽象工厂模式中，一个工厂只需要去负责对应零件的获取即可，只需要获取到了这一系列一个具体产品需要的具体零件，我们就默认这些零件已经组合好成为了我们需要的一个具体产品。</p>
<span id="more"></span>
<p>看到这个过程，我们其实可以看到它其实省略了一个过程，就是零件是怎么组装形成我们最后的产品的。在现实世界中，我们仅仅获取到了一些零件是远远不够的，毕竟，就算给你一个手机所需要的所有零件，你也不知道这些零件要怎么组装才能形成我们需要的具体产品。这时就引入了一种新的创建型模式：生成者模式(<strong>建造者模式</strong>)。</p>
<p>既然它是创建型模式，那么它最后的目的就还是一个具体类对象的创建，但是正如我们前面所说，这个模式相对于抽象工厂模式来说进行了一些改进，其相对于不注重细节的抽象工厂模式进行了在零件组装上的细化。使得在对象创建时能够更加细致的对整个过程进行管理。就比如把，你要建造一栋楼，那么你至少需要地基才能建造第一层乃至更多层的楼吧。在抽象工厂模式中，其不关注你到底怎么建造的。哪怕你先提供了最高层的楼，再提供一个地基，它也是允许的，毕竟它忽略了一个组装的细节。</p>
<p>但是我们建造者模式不允许这样的创建。建造者模式将一个创建对象的过程进行细化和规定，其规定了一个具体产品的组成零件，以及这些个零件之间的组装细节。就比如，你需要先有地基，你才能建第一层楼，才能接着建造接下来的一系列楼层。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/1.jpeg" alt="1"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/2.jpeg" alt="2"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/3.jpeg" alt="3"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/4.jpeg" alt="4"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/5.jpeg" alt="5"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/6.png" alt="6"></p>
<p>来简单看一个生成器模式下的UML类图。简单来分析下建造者类中的层次，首先我们应该看到的就是ShipBuilder这个类，可以看到，这个类是接下来的俩个具体类的子类。也可以这么说，这个是一个抽象工厂层，这个层次规定了一个产品所需要的步骤，我们所有具体的工厂类都应该是从这些个抽象工厂类中派生出来的。在这个类中，你可以看到其实相对于抽象工厂它是相似的。在演示中由于设计的复杂性这里不会让其去下辖抽象工厂层次中的零件类，但我们需要知道其实是有的。</p>
<p>在这些具体的建造者工厂类中，我们一般会存在一个成员来对我们建造的规则进行一个记录，这个的具体类型取决于实现。</p>
<p>说完了船的建造这一块，我们来说指令发出这一块的。在生成一个船的指令发出时，可能经过多层的处理。一般来说，为了好看，我们都会考虑增加一个管理者类，在用户层可以通过这个类去跟具体的工厂进行间接的交互，而不必直接去找到对应的工厂，其实就是加了一层中介。在这个管理者类中，需要这个管理者类可以管理我们需要的一系列产品的生产。所以这里就需要这个管理者类包含一个抽象工厂类的指针，令其可以指向所有的子类对象。再者，如果说一个产品中还有细分的品种，我们就需要让这个管理者类中去添加对应的生产函数，毕竟一个指针只能指向对应的对象，但是对应对象的生产是必须通过方法的(即函数)。也就是说，一个管理者类的方法数量，取决于我们一个产品的种类。</p>
<p>好，接下来就是最后一层，用户层，在我们这里中，由于存在管理者类，所以与用户层直接进行交互的将会是管理者类，用户层通过想管理者类提出要求，就比如要那艘船，要什么品质的船等相对来说更加细致的要求，就可以获取对应的产品了，不用关注底层的实现。</p>
<p>也就是说，生产者模式其实还可以看做是一种对于抽象工厂模式的扩充。其更加注重了各个零件组装的细节，能够相对于抽象工厂类去实现更加细致化的操作。</p>
<p>好了，我好像对建造者模式有一定的理解了，让我们启动。</p>
<p>首先，在建造者模式中，存在几个比较重要的层次需要我们了解。首先是用户层，这个其实对应的调用，我们不多赘述。</p>
<p>但是吧，我决定建造者模式从下往上去建模比较好，来吧。我们首先需要看到我们整个模式需要生产的东西，就是一个具体的类对象。用上面造船为例子吧。船的类就是整个模式要生产的东西的板子。对于这一层，可能是由一个抽象类来规定我们生产的产品的基本属性，然后通过一个具体的派生类来实现具体的一个船对象所需要的属性。当然，也有可能不是使用多态而是穷举所有的船类。这个取决于我们具体的实现。但是无论是哪种实现，我们需要注意的是，在这一层的船类中，对船的约束是相当宽泛的。就好比说，这个东西我给你标签为船，但是这个东西的具体并不会在这个标签上就注明，这里也是如此。</p>
<p>接下来需要看到建造者层，这是在整个层次中的底层。这一层中我们还是可以抽象出来俩层，一层是抽象建造者层，一层是具体建造者层。这个抽象建造者层规定了这一系列的建造者所要建造的物品的种类。就比如，你如果是一个船建造者，那么它要派生出来的类就是具体的船的建造者，但是，并不规定到底是哪一个船。</p>
<p>一般来说，在抽象建造者层中，一般只存在着一系列的建造方法，不会存在一个成员对象用于储存。这个其实是为了方便一个扩展。因为我们不确定在设计中我们的船类是否是使用多态的，如果你的具体船类是使用多态的，那么使用成员指针自然是一个极好的方法，但是，如果你是穷举出一系列的船的，你使用成员指针的话，你就必须包括所有的可能创建的船，这个其实不是很符合单一职责原则的。</p>
<p>所以我们可以看到，在建造者类中，我们特别需要注意的就是其所遵守的<strong>单一职责原则</strong>，这个原则使得建造者类在设计上是关注与船的功能的构建即可。其在设计中一般来说都是提供一系列的对应的要创建的对象的组装方法的。就比如组装船。在建造者类中，其可能存在的方法就包括武器，能源，装饰等等。但是，一般来说，在建造者类中，不会包括这些方法的组合。也就是说，建造者类负责提供一些(较大块的)零件，让其他模块来组合形成一个具体的类对象。</p>
<p>接下来我们需要来看到更接近用户层的类，<strong>管理者层</strong>。这个层在一些资料中说是可有可无的，但是吧，现实设计中一般都是包含这个类的。</p>
<p>这个类可以看做是对用户需求提出的层次和建造者层次的缓冲。管理者类一般是可以存在多个的，一个管理者类负责一类船的生产。</p>
<p>用现实生活来举例吧，一个船厂一般有自己生产的船的方向，但是并不固定。当一个公司甲方想要去委托一个船厂去生产一个具有特定功能的船的时候，其一般都不会直接去找到制造部门，而是去找到船厂的销售部门，向这个部门去阐述自己的需求，或者说选择自己需要的船型号。接下来这个销售部门会去解析这个需求，将这个需求解析成一步步可以落地的步骤，然后让这个船厂的制造部门去做。</p>
<p>在这个例子中，甲方扮演的角色就是用户层，销售部门扮演的就是管理者层，制造部门扮演的就是建造者层，而我们最后的需求产品，就是我们一个具体的船类的对象。</p>
<p>可以看出来，我们管理者层这里负责一个需求的解析，就比如甲方去A船厂提出我需要你们一个标准型号的船，那么这个管理者类就会对这个需求进行解析，就假设一个标准型号的船需要一个船身，一个发动机，一个武器这个配置，那么管理者层就会把这个配置发送给我们具体的建造者类中去，然后这个建造者类就会依照这个管理者类发来的需求按顺序去一个个实现到一个船对象中。当执行完后，一个标准A船就被制造出来了。</p>
<p>接下来，就需要船厂能够提供一个接口让用户能够提船。这个一般应该在制造者类中去实现，至于是在抽象类中就有还是每个类维护一个自己的方法取决于各自的实现。其实，这些个制造者类就好像一个公司一个部门的不同项目，其各自有着一套对接流程，甲方需要依照这些接口流程去获取自己需要的东西。</p>
<p>同时，我们可以考虑到如果不想要A船厂的船而想要B船厂的船。那我们需要怎么做，那我们需要去找到对应船厂的中介(管理者)，对应船厂需要特定的船产品(具体的产品类)，还需要对应船厂有自己的制造部门(建造者类)，这是最简单的配置了，这也是我们在建造者模式中想要进行扩展需要添加的几个方面。</p>
<p>我再来对制造者类来进行下分析。我们抽象这个建造者类为具体的生产部门。在这个部门中，其的目的是生成出一个管理者可能会要求生产的产品，也就是说，在制造者类中，应该存在一个可以用来储存当前生产的对象的地方，在类中就抽象为一个成员指针。这个可以玩笑为”新建文件夹”。在制造者类中，其一开始并不知道这个类将要被怎么个设计，但是这个制造者类中应该包含着对于这个新建文件夹的所有操作。</p>
<p>既然这个制造者类不能自己决定要怎么个制作方法，那么就需要外部来给他提出要求，在生产者模式中就是管理者类起到了这方面的作用。前面已经提到了，管理者类会将用户提出的需求转化为具体的组装步骤转发给制造者类去进行实现。</p>
<p>也就是说，管理者类会提供一个完整的设计流程给制造者，制造者类只需要按这个提供的流程去进行组装即可。</p>
<p>差不多了，那么接下来我们来讨论下管理者类的必要性。其实理论上管理者类的存在不是必须的，但是正如设计模式存在的意义一般，这个层次的存在也是为了方便我们的设计和使用。我们当然可以把这个管理者要要提供的组装流程直接封装在制造者类中。但是吧，这就像你一个甲方要去直接与对应乙方的技术部门进行交流一样。这通常是一份吃力不讨好的工作。为了更高效的交流，我们应该考虑这个公司中的对接部门，这个部门能够协调甲方的需求和自己方公司的实际能力，这种缓存能更好的提高效率。</p>
<p>也就是说，对于设计模式的学习，我们一定得结合实际来看，毕竟设计模式其实就是一种对于现实世界的抽象建模，其旨在解决现实生活中的问题，结合现实问题能让我们更好的理解设计模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>接下来我们来看到最后一种建造者模式，<strong>原型模式</strong></p>
<p>这种模式的核心需求是<strong>通过复制已有对象来创建对象而不是通过类构造函数</strong>。核心思想就是<strong>克隆对象</strong></p>
<span id="more"></span>
<p>其实吧，你看到这上面的时候你其实可能会疑惑这种模式存在的意义，毕竟即使复制已有对象和通过构造函数来构造对象存在一定的差异，但是也不会存在多么离谱的区别，所以这种模式的存在意义到底在哪。</p>
<p>首先我们知道在一个类的默认设计中，编译器都会默认提供一个拷贝构造函数，即使这个拷贝构造函数只能提供浅拷贝的功能。也就是说，要在一个类的外面来拷贝一个类其实是相对简单的，最多就是添加一个拷贝三件套即可。</p>
<p>我们来深入探讨一下，我们如果使用多态下的类对象拷贝，在这种情况下，我们在类的外部对于任何一个同层次的类的拷贝都是简单的(这里指的是用相应的类名称指针来拷贝对应的类对象)。但是，我们来考虑下使用父类指针来拷贝下子类对象的情况呢，这种是我们的拷贝构造函数所无法提供的，而这个情况就是我们的原型模式的一种运用场景了。</p>
<p>这里我们讨论下这个原型模式的应用场景。相对来说，原型模式反而是相对来说应用广泛的一个模式了，毕竟这个就是对于扩展方法的一种扩展。只需要一个clone方法即该类对应的拷贝构造函数三件套。需要注意的是，我们在使用这种原型模式时，需要考虑设计上的效率问题，如果我们要拷贝的类对象是直接构造起来比较费时的话，那原型模式能够很好的提高效率。</p>
<p>在接下去之前我们需要解释下原型模式的实际实现，本质就是在类内使用拷贝构造函数来实现拷贝。那么我们就需要考虑下我们的拷贝构造和一般的构造的效率之间区别，在一般情况下，这俩种的情况是差不多的，甚至于在大多数情况下，使用无参构造来实现是更加简便的。但是吧，就比如我们前面学到的抽象工厂模式和生产者模式，这些要产生的类是一系列相对来说更加复杂的，都是无法通过简单的无参构造实现的，还需要一系列的额外函数来添加属性的。这时候原型模式的作用就体现出来了，其绕开了构建一个复杂对象时需要的流程，直接对现有的对象进行复制，获取一个可以直接使用的对象。即使我们后续需要对这个对象进行修改，也只用去修改对应的成员即可，跟普通的构造出来的对象没有什么大区别，但是在构造的消耗上优化了很多。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/1.jpeg" alt="1"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.jpeg" alt="2"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.jpeg" alt="3"></p>
<p>而且，这是一个可以简单的嵌入到其他模式中的模式，这也就体现了它应用的广泛性，毕竟它应用简单而且能优化性能。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式课设举例</title>
    <url>/2024/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%BE%E8%AE%BE%E4%B8%BE%E4%BE%8B/</url>
    <content><![CDATA[<p>​	这个项目进行了之前项目的优化，项目对应的UML类图如图。</p>
<p><img src="/2024/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%BE%E8%AE%BE%E4%B8%BE%E4%BE%8B/opt.drawio.png" alt="opt.drawio"></p>
<span id="more"></span>	

<p>​	相较于之前的UML类图可以看到其复杂了一点，其实只是看这里的话会感觉没有什么优化，相反来说更复杂。但是这要结合QT的信号与槽机制来看。</p>
<p>​	在这个项目版本中，进行了对于原本heap类的解耦，将其解耦成了一个数据处理模块和渲染模块，俩个模块之间使用观察者模式来进行通信。在这里不是一个经典的观察者模式架构。这是因为在QT中存在一个观察者模式的上位结构，我通过使用这个模式来简化我们观察者模式的架构。</p>
<blockquote>
<p>​	<strong>接下来对这个项目进行介绍。</strong></p>
</blockquote>
<p>​	有一说一，我确实没想到这个项目可以打赢复活赛。原本的项目的UML类图如下</p>
<p><img src="/2024/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%BE%E8%AE%BE%E4%B8%BE%E4%BE%8B/sim.drawio.png" alt="sim.drawio"></p>
<p>​	在原本的项目中，我的功能模块heap类是强耦合的，在学了设计模式之后，我一直在想着能否将这个模块进行解耦，在有了一定的基础之后，我就开始了这个工作。</p>
<p>​	我的考虑是，将这个强耦合的功能模块解耦成俩个单独的模块，其中一个是用于数据处理的模块，另一个是用于图像渲染的模块。最后的成果就是那个新的UML类图。在新版本的项目中，我基本将数据模块和渲染模块进行了一次相对彻底的解耦，俩者通过观察者模式来进行连接。在QT中我是通过信号与槽机制来实现这里的观察者模式的。</p>
<p>​	在实现了这俩者模块的分离之后，我还遇到了一个问题，就是我的信号连接，必须存在俩者的示例对象的，但是我不想再去内嵌俩个模块中的任何一个内嵌到另一个模块中。所以在这里我考虑了另一种方法，使用一种结构性设计模式来进行架构。在这里就是我的heapManage类，这个类使用的设计模式是外观模式。</p>
<p>​	通过外观模式，我成功的将底层的实现逻辑给进一步的封装了起来，并且，我在这个外观模式类中提供了系列底层的接口用于功能的实现，这里由于设计问题这里的接口只是起到了一个参数传递的功能，不过也无所谓了。</p>
<p>​	其他模块的功能其实没有什么大的改动，从上面的俩个类图对比也可以看出来。有一说一，这个优化后的类图相较与优化前的类图真优雅吧。</p>
<p>​	总的来说，在这次代码架构优化中，遇到的最核心的启发就是学一个东西最好的方式就是问题驱动式的学习，通过一种内驱力来实现对于外部知识的内化。</p>
<p>​	下面给出代码仓库的地址，有兴趣可以自己去搓一遍，毕竟类图都已经给你了，整体的代码逻辑也不算复杂。	</p>
<p>[]: <a href="https://github.com/TCWW0/QT_Train/tree/HeapSort">https://github.com/TCWW0/QT_Train/tree/HeapSort</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/08/15/%E9%98%85%E8%AF%BB/%E6%91%98%E8%AE%B0/</url>
    <content><![CDATA[<hr>
<hr>
<p>从事服务端开发，领域知识是最基础却又最重要的能力。但是，只有当领域知识形成体系的时候，才可能成为真正的核心竞争力。当遇到问题时，如果连相关的知识储备都没有，那么往往很难解决问题；而如果你有相应的知识储备，则可以将知识迁移到问题场景中，辅以推理寻找解决问题的方法。为了能够让领域知识和逻辑推理能够更好的结合，我们需要系统地学习知识，专注于某些技术方向的同时，有意识的向周边进行扩展。就比如，对于后端开发工程师，除了掌握服务端开发技术栈和相关业务知识，也应该了解一些客户端的知识，了解客户端与服务端之间如何进行交互。</p>
<h2 id="如何将自己的领域知识系统化"><a href="#如何将自己的领域知识系统化" class="headerlink" title="如何将自己的领域知识系统化"></a><strong>如何将自己的领域知识系统化</strong></h2><p>​	很多时候，领域知识点本身是可以相互联系起来的，但是前提是你对于这些知识点的理解足够透彻。在工作中学习，最常陷入的困境是时间过于碎片化，学了后面的，就网络前面的，不得要领。这个现象其实在一般的学习中也会广泛的存在，就比如在对于一些网课的学习中，如果是粗浅的过，那么最后只会是一种模糊的印象，甚至于刚看完的课程不一会就忘记了。出现这种情况的一个很重要原因在于：领域宏观层面的整体视图没有形成，关键知识点理解深度不够、不透彻。这些关键知识点就是这个领域的骨架、支点。缺了骨架，自然难以体系化，缺了支点，则容易误入歧途。</p>
<p>​	上面这段理论其实与OSTEP中的一个论点很接近，就是关于一个章节或者说一个书本内容的学习，其中最重要的是形成一个自己的心智模型。什么是心智模型，在目前的我看来，一个心智模型是在你看到一个物品时，你能够联想到的关于这个物品背后所涉及到的一系列你领域知识内的东西。</p>
<p>​	举个例子，当你看到一个服务器集群在运行时，你不免会去猜想其中所用的共识算法到底是什么，是Paxos还是Raft。再进一步，当你想到一个共识算法时，你会去考虑对应的内部到底是怎么达成共识的，对应的在网络分区(P)未发生的情况下，其对应的一致性(C)，可用性(A)，都是怎么实现的。因此，你会很快的想到Raft中使用Leader Election机制和单主复制等来协调集群，进而来实现一种一致性。当发生P时，其通过心跳来检测活性并通过发起新一轮Leader Election等来实现在节点少部分故障时候的可用性。其会在节点落后进度落后时通过InstallSnapshot来追赶对应的进度，而且通过相互之间的信息量来约束对应的选举结果，但是最终是一种尽力而为的模型等等。</p>
<p>​	总总这些，是本人在学习分布式的共识算法后形成的一些简单的心智模型，或者说，是剩下的那些比较印象深刻的知识点，整体的Raft算法在学习时实际上是比上文描述的麻烦且复杂许多的，但是对于我来说我是无法全部记住的，只能根据实际的一些场景记录下一些重要的知识点，即所谓的支点。在经历过一段时间过后，剩余的知识点实际上构成了一个基本的蓝图。在初始时候不必追求完美企图全部记住，因为这个是不现实的，只有在实际的实践中，我们才能够不断的将这些个知识点内化，纳入为骨架中的一部分。进而形成自己的一个完整心智模型。</p>
]]></content>
  </entry>
  <entry>
    <title>单例模式(1)</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<span id="more"></span>

<p>先给出单例模式的定义：</p>
<p>在一个项目中，全局范围内，某个类的示例有且只有一个，通过这个唯一示例向其他数据提供数据的全局访问，这种模式就是单例模式，一个经典的应用就是任务队列。</p>
<!-- more -->
<p>需要注意的是，单例模式作用的对象是一个类，这种模式下的类保证某些类在系统中全局唯一，并保证这些类在整个程序中提供一个具有规范的访问接口。这个模式解决了资源管理，状态一致和模块解耦的问题。举例，这个其实可以应用于一个全局变量的访问权限封装，避免一个资源方面的使用竞争等。</p>
<p>可以预见到，单例模式的一个基本要求是一个<strong>单例</strong>的特性。而如果要实现这个特性，仅仅在设计时去确保它只创建一次将是骗人骗己的。我们需要做的会是一个绝育，确保这个类会且只会被创建一次。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/Aspose.Words.dd48d7fc-1cb1-4ccd-95c2-6a5173fed41f.001.jpeg" alt="Aspose.Words.dd48d7fc-1cb1-4ccd-95c2-6a5173fed41f.001"></p>
<p>要让一个类只能创建一次，我们必须堵死所有可以自由创建类以及可能导致类的复制的方法。显然，我们一个去禁止单例模式的类对象的new创建使用，要如此的话我们就需要从它的构造函数入手。</p>
<p>我们可以直接删除(delete)掉默认构造函数，同时拒绝提供任何带参构造。同时，需要我们得知道c++内部是会自动提供一个拷贝构造函数的，所以对于这个函数我们也得进行删除，对应的，与拷贝构造函数绑定的&#x3D;重载函数也应该删除。至此，我们删除了一些与类的创建有关的一些函数。当然方法不止于此。</p>
<p>我们还可以不删除函数而是将对应的函数放在private中实现等效的作用。毕竟private是无法通过类对象访问的，这样就避免了在外部程序通过调用new方法去创建多个类对象了。</p>
<p>总总这些，只是解决了绝育这一步，但是我们需要考虑的还有我们对于这个单例模式下的类还是需要一个具体的示例的。而这个实例在设计中一般是通过静态成员变量来进行访问的，而且这个成员变量应该是本类的一个指针，也就是说，这个指针是提供给外界的唯一类接口，我们所有对这个类的访问和操作都必须经过这个指针。</p>
<p>接下来，我们需要对这个指针进行初始化。毕竟在类中，你是无法对一个静态成员变量进行初始化的。</p>
<p>类名* 类名作用域::静态成员指针&#x3D;new 类名;</p>
<p>这个格式就是一般的单例模式的类的静态成员类指针初始化语句。</p>
<p>在然后我们需要将这个接口提供给程序，毕竟现在我们只是实例化了这个静态成员变量，由于是类的成员变量，且一般来说我们是将其放在一个private作用域的，所以我们是没有办法通过一个类对象去进行访问的。事实上，由于我们已经对类进行了绝育，所以我们其实是无法额外new一个对象出来的。这时候，我们一般需要额外定义一个静态公有方法，这个方法用于放回一个指针，而这个指针就是我们前面创建的静态类成员指针。也就是说，我们需要一个可通过类名直接调用的静态成员函数来充当接口的作用。</p>
<p>至此，我们已经有了一个单例类的指针，而且我们可以在项目中的任何地方去取得这个指针，只要我们包含对应的文件。当然，需要注意单例这个属性，不要在多文件中去错误的创建多个静态类成员指针。保证单例的性质。</p>
<p>接下来看一下这种设计的可行性基础。或者说，我们需要重新认识下静态成员等的特性。</p>
<p>首先，静态成员是属于类的，所有类都共享一份。并且能通过对象和类名来进行访问，当然，一般来说，对于静态成员只通过类名来进行访问好进行区分。这是单例模式使用这种静态成员来实现单例的基础。只有这种唯一性能够保证我们在整个程序中都保证唯一。</p>
<p>其次，我们需要注意下我们的静态类指针一般和构造函数都是房子private中的。这里就需要注意下静态成员的访问权限了。静态成员在初始化和定义时是无视其的作用域，也就是说，即使我们声明这个静态成员的属性为private。我们仍可在外部对这个静态成员进行定义和初始化。或者说，我们必须在外部进行对应的初始化和定义。一般来说，我们的初始化和定义都会是绑定在一条语句的。一条只含有定义的语句将会导致一个未定义行为，毕竟你不知道对应的二进制文件位置处是一个怎么样的文本串。话又说回来了，对于一个初始化了的静态成员，我们在二进制文件中的位置是.date段，对于未初始化的成员变量，其的位置是在.bss段。扯远了，回来。</p>
<p>在进行初始化和定义后，这个类静态变量的访问权限将会回复，一个静态公有变量将还是能够通过类名进行直接访问，但是如果是私有或者是保护的，那么类名就没有权限去访问到这个成员了。这时就需要用到一个类接口。一般来说，还是将这个接口设计为静态公有函数以进行区分，当然理论上你还是可以通过一个普通的公有成员函数。但是其实这样做并不是很安全。注意设计模式中的<strong>依赖倒转原则</strong>，我们完全可以通过一个静态函数来充当一个中间层来屏蔽影响，这样同时能够提供更好的逻辑上的隔离。</p>
<p>就比如我们可以通过这种设计来达到一种懒加载或者说延迟初始化的效果，我们完全可以在外层初始化这个静态指针时初始化为一个nullptr，然后在之后进行利用这个指针去找到对应的示例时再去进行对象的创建，而这个创建可以在对应的静态公有函数中去。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Epoll部分场景分析</title>
    <url>/2025/10/25/OS/4-epoll/</url>
    <content><![CDATA[<h1 id="Epoll分析"><a href="#Epoll分析" class="headerlink" title="Epoll分析"></a>Epoll分析</h1><p>本文集中于对于多路复用api Epoll部分需要注意的问题的分析</p>
<span id="more"></span>

<h2 id="Epoll惊群"><a href="#Epoll惊群" class="headerlink" title="Epoll惊群"></a>Epoll惊群</h2><p>对于Epoll的使用，存在几个基础的规则，其一就是不要在多个线程中监听同一个EpollFd。但是，为什么呢？</p>
<p>这一点相对来说比较容易理解，对于Epoll来说，其基础的使用规则就是创建epollfd-&gt;注册fd事件-&gt;epoll_wait等待内核通知。惊群的可能触发点就在”epoll_wait等待内核通知”上。对于这个阶段，可能存在以下场景：</p>
<ul>
<li>一个epollfd只被一个工作线程监听，那么自然只有一个线程被唤醒，此时不会存在问题</li>
<li>一个epollfd被多个工作线程监听，此时出现了一个IO事件，但是最终只唤醒了一个工作线程，此时也不会存在问题</li>
<li>一个epollfd被多个工作线程监听，但是此时出现了连续多个IO事件，导致在应用层的观测中，多个工作线程被同时唤醒，此时存在较大的并发上的问题</li>
</ul>
<p>首先，我们明确一点，对于epoll本身来说，其所提供的保证实际上确实保证了其每次唤醒线程时都是一种类似于<code>wake_up</code>的行为，即每次最多只唤醒一个线程。但是实际上在应用侧来观测的话，我们不难看到会存在在部分并发场景中出现多监听epoll的线程同时被唤醒的情况，我们需要理解这种场景来进行分析。</p>
<p>在进入实际的分析之前，我期望你能够理解什么是end-to-end appointment，这对于一个CSer来说是一个必须深刻理解以及体会的观点，可以阅读该论文进行了解。<a href="https://web.mit.edu/saltzer/www/publications/endtoend/endtoend.pdf">https://web.mit.edu/saltzer/www/publications/endtoend/endtoend.pdf</a></p>
<h3 id="竞态分析"><a href="#竞态分析" class="headerlink" title="竞态分析"></a>竞态分析</h3><p>首先，我们需要明确epoll系统层所能够给与我们的抽象。对于一次IO事件的到达，由于其使用的唤醒机制是类似于<code>wake_up_locked</code>的单唤醒api，而不是<code>wake_up_all</code>的全唤醒api。所以其每次唤醒确实能够提供有且只有一个阻塞线程被解除阻塞的场景。但是，如果你了解端到端的观点。你会尝试去提问，这种由底层能够提供的线程单唤醒保证是否足够，在上层观察者看来，是否存在不同的行为。</p>
<p>碰巧，这里确实也存在这种场景的分析。场景如下：</p>
<ol>
<li>一个IO完成事件到达，此时epoll监听到事件后开始调用唤醒api来使得就绪队列中的一个线程解除阻塞</li>
<li>在第一步推完完整流程之前，此时出现了另外一个IO完成事件，该事件也会导致一次唤醒</li>
</ol>
<p>如果在上诉描述的场景中，我们就能够观测到实际上会存在多个唤醒，虽然其本身唤醒的事件不同，但是其导致的效果是相同的。所以后续就需要考虑并发唤醒导致的问题了。</p>
<blockquote>
<p>在进入下一步之前，我们回过头来，分析一下epoll实际上观测起来的行为会是怎么样的</p>
</blockquote>
<h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><p>你是否存在一个问题，epoll本身是如何导致唤醒api的并发的？或者说，epoll内部是否实际上会存在唤醒api的并发，还是说其会存在的是一个串行的唤醒事件队列呢？这里涉及到如何理解epoll的行为。</p>
<p>对于epoll本身来说，其本质上是在内核中维护的一系列数据结构，包括<code>The interest list</code>和 <code>The  ready  list</code>以及一系列额外的api。</p>
<p><img src="/2025/10/25/OS/4-epoll/image-20251025104814577.png" alt="Linux中epoll的man手册"></p>
<p>那么，考虑一个问题，如果epoll本身如此的无状态，那么对应的各种IO事件到来时，到底是谁来驱动epoll本身的事件的更新呢？epoll本身并不存在一个独立的线程来执行，那么势必就只能够将这种职责交给上层的IO事件源。由对应的IO事件源来调用epoll本身的api来实现对应的事件注册，以及后续的等待线程唤醒。那么你想必也能够发现一个问题，如果事件源本身是分散在多核中的呢？在这种情况下，实际上的epoll行为就是一种并发的行为，此时内核中的epoll数据结构与api提供一种原子的修改状态api，多核用户态可能并行调用这些api。其中关于数据结构的修改，内核通过自旋锁进行了保护，而对于就绪队列(这里指的是关于休眠线程的就绪队列)，其也存在一种机制来保护每次的唤醒正确。但是，由于实际上的唤醒api可能出现并行的调用，那么即使底层的api保证为一种串行的唤醒，在更上层看起来，其也是一种并发的唤醒场景。</p>
<blockquote>
<p>对于epoll的并发模型简单的分析之后，不免让人惊叹设计者的设计哲学，其就像一个持着手术刀的医生，使用其极为精湛的技术，完全的切分了每一层的职责，底层的数据结构和api保证了对应的操作原子性，上层的多核并行性提供了一种并发模型的抽象。再给上层提供了一种高效的IO多路复用方式。这就是end-to-end appointment在系统设计中一次淋漓尽致的体现。这种刚刚好的美感，真的令人着迷。</p>
</blockquote>
<p>在了解上面的内容之后，我们可以来总结一下当前epoll所能够提供给上层的抽象。</p>
<ul>
<li>epoll的底层行为由IO事件源驱动，而事件源可能存在多个，在多核的调度下，可能使得对于一个epoll的状态修改并行化</li>
<li>epoll本身保证其状态修改的串行化，但是由于其唤醒线程的操作没有位于临界区内，所以即使前面已经串行化修改操作，由于各种硬件软件上的场景，实际上存在线程唤醒的api调用是非常可能发生的</li>
<li>epoll本身保证了其在并发下涉及其数据结构改动操作的正确，也保证了一次IO事件的到达只可能唤醒一个等待线程。但是其并没有提供在并发下的多监听线程的唤醒模型。</li>
</ul>
<p>由此，我们可以来回答我们前面涉及到的并发唤醒竞态问题</p>
<p>对于epoll来说，如果存在多个线程同时监听了同一个epollfd，同时阻塞在了epoll_wait处，那么这些多个线程实际上是可能被同时唤醒的。而且由于唤醒本身是无状态的，所以这种唤醒可能会导致对于就绪fd的事件的争抢，这样又可能导致更大的并发问题。所以为了来解决这种问题，我们可以存在俩种策略</p>
<ol>
<li>在应用层设计一种更加严格的唤醒-执行机制，保证多线程监听同一个fd时候的逻辑正确</li>
<li>保持KISS原则，拒绝在多线程中监听同一个epollfd，这从根本上解决了问题</li>
</ol>
<h3 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h3><p>接下来，我们进入进一步的竞态分析。在进入分析之前，我们需要先给出一定的假设</p>
<ul>
<li>对于一个epollfd的监听，只会由一个master线程进行监听，这样消除了先前讨论的竞态</li>
<li>当前的架构中除开一个监听epollfd的master线程，还会存在一系列处理IO完成事件的worker线程，在master监听到IO事件之后，需要将事件分发给worker进行执行</li>
<li>worker本身是单线程的逻辑处理，只要数据包顺序到达，其就能够保证数据正确处理</li>
</ul>
<p>在进入下一步之前，你可以先停一下，分析一下在先前的假设下是否存在什么竞态场景。</p>
<p>先前我们分析的第一个竞态的粒度是在监听线程的唤醒上，这次我们将视角移动到IO完成事件的派发上。此时可能存在俩种场景：</p>
<ol>
<li>master线程对于一个fd产生的事件，其只会将其派发到同一个worker-thread上</li>
<li>master线程对于fd产生的事件，其只会进行随机进行分配，不提供任何派发上的保证</li>
</ol>
<p>对于这里的第一种策略，只要该worker中的逻辑正确，由于fd本身是一种在宏观上串行的处理逻辑，那么自然不会出现一些基础的错误。但是对于第二种场景，其需要的注意场景就比较多了。我们假设存在以下场景</p>
<ol>
<li>在epoll中注册的关于一个fd的IO完成事件到达，epoll_wait解除阻塞，<strong>thread_worker1</strong>接收并处理该fd数据</li>
<li>在第一步的逻辑处理完全完成之前，此时又出现了新的IO完成事件，而且该IO事件也还是该fd上的事件，而且此时master将该事件派发给了<strong>thread_worker2</strong>处理</li>
</ol>
<p>此时你应该能够识别出上诉场景中可能存在的问题了，我不再赘诉，下面给出个图辅助理解</p>
<img src="/2025/10/25/OS/4-epoll/image-20251025120659362.png" alt="辅助图" style="zoom:80%;">

<p>在理想情况下，此时对应的俩个读写事件都能够按照原有的逻辑正常执行，此时不会出现逻辑上的错误。但是在实际的场景中，出现”竞态”中的场景几乎是必然的，当多线程同时对于一个fd进行操作时，对应的读写操作之间必须存在互斥机制，否则在出现交错时通常就会出现期望之外的行为。所以我们必须来针对这种场景来进行解决。给出的解决方法有俩种</p>
<ol>
<li>应用层保证一种一致性哈希，使得一个fd只会被固定分配到同一个worker-thread中</li>
<li>使用一种额外的机制来保证读写之间的互斥</li>
</ol>
<p>这俩种场景都有其应用场景，第一种操作看起来更加的优雅，其没有引入额外的互斥机制，对于原有的性能没有多大的损耗，但是附带的，其的应用场景也比较有限，或者换句话说，使用场景更加明确，其需要自己来明确一致性哈希派发逻辑，如果后续想要复用，必须遵守这里的派发的规则。</p>
<p>更加灵活但是代价更大的就是实现一种额外的机制来保证读写的互斥，所幸，epoll底层本身提供了这么一种机制，即EPOLLONESHOT，这个事件属性可以使得一个epoll内部事件在被通知后立刻被消耗，不再保持原有的持续存活的状态，如果需要再次监听该事件，必须再次通过epoll_ctl来进行注册。也就是说，这个EPOLLONESHOT属性更加严格的限制了一个事件的生命周期，使得在应用侧可以更加灵活的来进行管理。试想，如果你能够在应用层上保证你在一次处理来自epoll的IO事件之后再重新注册之后，你本身就在应用层上保证了互斥，而底层也仅仅只是管理了一定的生命周期，并没有重复的互斥机制存在。此处实际上也是一种优雅的端到端的体现。而且，你是否想到了，在ASIO等一众网络库中，当你监听完一个事件后，你需要重新注册该事件来监听。这不难让人猜测去其实际上也是通过对于EPOLLONESHOT属性的利用来设计的。</p>
<blockquote>
<p>额外给出一个简单的思考题，为什么ASIO等一众网络库要采用重复注册的做法而不是使用前文所提到的一致性哈希？</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次对于epoll的简单分析，对于我来说是一种酣畅淋漓的体验，其让我看到了一些系统设计上的优雅，到底设计者是怎么在软件与硬件之间做的tradeoff来平衡，拼接俩者之间的特性来组合出一个优雅的底层系统。一个底层api所能够提供的抽象到底应该怎么来理解，我们应该怎么利用这一层抽象来构建出属于自己的另外一层抽象，自己的这一层抽象又对外暴露了什么。还有，我们怎么将这些知识给迁移到其他的学习中，特备是一些流行的网络库中，就比如ASIO等，如何通过epoll本身的特性，框架本身的使用方法，来推测框架这个黑盒的实现，进而来反哺我们在应用层上的优雅设计以及对于底层的剖析和对于系统架构的理解。这种分析过程是一种全方位的只是的整合，是一种令人酣畅淋漓的学习过程。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Channel实现分析</title>
    <url>/2025/11/01/C++%E5%AD%A6%E4%B9%A0/6-channel/</url>
    <content><![CDATA[<h1 id="Channel实现思路"><a href="#Channel实现思路" class="headerlink" title="Channel实现思路"></a>Channel实现思路</h1><p>本文接TinyCoro的契机，来分析一下如何使用一些相对底层的同步原语来组合成相对高级的同步原语，来分析一种端到端的实践，FSM的设计等等值得推敲的地方。</p>
<span id="more"></span>

<h2 id="设计动机"><a href="#设计动机" class="headerlink" title="设计动机"></a>设计动机</h2><p>对于一个相对底层的组件来说，我们必须需要了解我们设计其的动机，来约束住我们后续的实现，明确出外面的边界，使得后续的分析过程有一个参考，不至于过分的发散。就我个人理解上来看，我实现这个<code>channel</code>的基础想法是为了来封装一些并发场景的复杂性，特别是对于多生产者多消费者场景来说，我如果能够减少使用多个同步组件(互斥锁、条件变量等)所带来的心智负担。这时候实际上可以参考条件变量本身的出现动机，其本身就是对于一般的生产者消费者场景中<code>mutex</code>这种基础原语的实现复杂性。</p>
<p>没有channel的生产者消费者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 mutex + condition_variable + queue</span></span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">producer</span>() &#123;</span><br><span class="line">    <span class="keyword">auto</span> lock = <span class="keyword">co_await</span> mtx.<span class="built_in">lock</span>();</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="number">42</span>);</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">consumer</span>() &#123;</span><br><span class="line">    <span class="keyword">auto</span> lock = <span class="keyword">co_await</span> mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">co_await</span> cv.<span class="built_in">wait</span>(mtx, [&amp;]()&#123; <span class="keyword">return</span> !queue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">    <span class="keyword">auto</span> data = queue.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现的生产者消费者存在几个问题</p>
<ul>
<li>手动管理互斥锁、条件变量、队列等并发危险资源</li>
<li>关闭语义不清晰(什么时候生产者能够告诉消费者没有数据)，其与等待语义相融合了</li>
<li>缓冲区的大小受容器队列限制，无法清晰的端到端控制</li>
</ul>
<p>使用channel的生产者消费者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">channel&lt;<span class="type">int</span>, <span class="number">10</span>&gt; ch;  <span class="comment">// capacity=10 的缓冲 channel</span></span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">producer</span>() &#123;</span><br><span class="line">    <span class="keyword">co_await</span> ch.<span class="built_in">send</span>(<span class="number">42</span>);  <span class="comment">// 自动阻塞（缓冲满）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">consumer</span>() &#123;</span><br><span class="line">    <span class="keyword">auto</span> data = <span class="keyword">co_await</span> ch.<span class="built_in">recv</span>();  <span class="comment">// 自动阻塞（缓冲空）</span></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="comment">// 有数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// channel 已关闭且为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>channel的直观意义：</p>
<ul>
<li>封装使用互斥锁、条件变量、队列等组件的复杂性</li>
<li>相对清晰的关闭语义：在一个channel进行close操作之后，recv将会直接返回nullopt，不必用户再进行处理</li>
<li>容量控制：由用户由其使用场景来定制channel的容量大小</li>
</ul>
<h2 id="Channel内部组件"><a href="#Channel内部组件" class="headerlink" title="Channel内部组件"></a>Channel内部组件</h2><p>对于一个Channel来说，其需要管理整个多生产者多消费者场景中的竞态，基本的，其需要至少维护一下几个内部组件。</p>
<ul>
<li>消费者队列：暂存当前由于无法获取数据而陷入阻塞态的消费者协程</li>
<li>生产者队列：暂存当前由于无法推入数据而陷入阻塞态的生产者协程</li>
<li>数据队列：储存当前Channel中已经被储存的数据，用于被生产者推入数据和消费者拉取数据</li>
<li>状态flag：用于标识当前Channel所处状态，即开启&#x2F;关闭</li>
</ul>
<p>这些组件各自都会存在几个状态，由这些状态本身又会交织产生一系列的状态，从小点出发，一点点来剖析整个<code>Channel</code>的状态机模型。</p>
<p>基本状态</p>
<p>对于整个Channel来说，其最简单的状态就是其的flag，即是否关闭，其是一种0&#x2F;1的状态，即其要么是活跃的，要么是已经被关闭了的。但是存在一个设计上的问题，在Go的Channel设计中，即使一个Channel显式的close了，但是其还是会存活一段时间直到其中的数据彻底被消耗完。</p>
<p>实际上类比网络中TCP的一个概念更加清晰，就是半关闭的状态。在我的理解中，对于一个Channel来说，其的关闭状态本身会被分割为多个阶段，可以将其分割为初始关闭状态，半关闭状态，关闭完全状态。类比TCP全双工的设计，所谓的初始关闭状态，只是简单的设置一个flag标识当前已经关闭然后就进入了半关闭状态。在这个半关闭状态中，Channel将不会接受新的数据的传入，但是此时仍然可以处理数据的消耗。在半关闭状态中数据队列为空时，此时将转移到最后一个状态，可以将其视为“完全关闭状态”。在这个状态中，该<code>Channel</code>可以被视为“死亡”，此时无论是往其中推数据，或者从其中拉数据，都是一种无效的操作。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>15445 Lab2</title>
    <url>/2025/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93/BPM/</url>
    <content><![CDATA[<h1 id="BufferPool-Manager"><a href="#BufferPool-Manager" class="headerlink" title="BufferPool Manager"></a>BufferPool Manager</h1><p>针对15445的Lab2来进行分析，尝试总结一下如果来做这种Lab</p>
<h2 id="抽象与隔离"><a href="#抽象与隔离" class="headerlink" title="抽象与隔离"></a>抽象与隔离</h2><p>对于本次的Lab实现，个人感觉其中最麻烦的地点在于，你所需要实现的东西不再是局限于一个比较清晰的子模块，而是一个需要被嵌入使用的系统组件，你在开始时并不知道你所需要实现的内容，而是需要不断的熟悉各种上下文约定来约束你的场景。但是，怎么来做呢？</p>
<p>实际上，我在过往的几次Lab中也逐渐发现了这个问题，但是可能是之前还不够成熟，或者说不太在意，所以并没有总结出来，现在对于这个问题进行总结。对于CMU15445的Lab这种实验，其通常提供部分框架代码，让我们来补充缺失的逻辑，其一般会在任务书中给出部分要求，就比如一下的Task1的描述。</p>
<span id="more"></span>

<h2 id="LRU-K-Replacement-Policy"><a href="#LRU-K-Replacement-Policy" class="headerlink" title="LRU-K Replacement Policy"></a>LRU-K Replacement Policy</h2><p>​	对于该组件，Lab对于其的基础描述是一个BPM(BufferPool Manager)中的页面替换策略组件，Task描述如下</p>
<blockquote>
<p>This component is responsible for tracking page usage in the buffer pool in order to determine candidate pages &#x2F; frames to evict out of memory and back to disk.</p>
<p><strong>The LRU-K algorithm evicts a frame whose backward *k-distance* is the maximum of all frames in the replacer.</strong> Backward k-distance is computed as the difference in time between the current timestamp and the timestamp of kth previous access. A frame with fewer than k historical accesses is given +inf as its backward k-distance. If multiple frames have +inf backward k-distance, the replacer evicts the frame with the earliest overall timestamp (i.e., the frame whose least-recent recorded access is the overall least recent access).</p>
<p>The maximum size of the <code>LRUKReplacer</code> is the same as the size of the buffer pool since it contains placeholders for all of the frames in the <code>BufferPoolManager</code>. However, not all frames in the replacer may be considered as evictable at any given time. The size of <code>LRUKReplacer</code> is represented by the number of <em>evictable</em> frames. The <code>LRUKReplacer</code> is first initialized to have no frames in it. Only when a frame is marked as evictable will replacer’s size will increase. Similarly, when a frame is pinned or not in use, the replacer’s size will decrease.</p>
</blockquote>
<p>我们需要从中来提取出核心的信息，部分内容如下</p>
<ul>
<li>LRUKReplacer需要负责追踪在BPM中的所有的页面&#x2F;帧，维护他们的元信息</li>
<li>该组件需要支持驱逐一个页面&#x2F;帧，考虑到描述中的tracking 。此时会存在一个约定上的模糊：此处的驱逐，是要做到什么程度上，只驱逐元信息？还是需要完全驱逐页面，这涉及到实际中的组件交互、权责划分</li>
<li>LRUKReplacer中维护的页面需要与上层BPM中的信息强一致</li>
</ul>
<p>接下来，我们来注意到代码中对于该组件初步给出的现有代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  <span class="comment">// NOLINT</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer/arc_replacer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common/macros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUKNode</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/** History of last seen K timestamps of this page. Least recent timestamp stored in front. */</span></span><br><span class="line">  <span class="comment">// Remove maybe_unused if you start using them. Feel free to change the member variables as you want.</span></span><br><span class="line"></span><br><span class="line">  [[maybe_unused]] std::list&lt;<span class="type">size_t</span>&gt; history_;</span><br><span class="line">  [[maybe_unused]] <span class="type">size_t</span> k_;</span><br><span class="line">  [[maybe_unused]] <span class="type">frame_id_t</span> fid_;</span><br><span class="line">  [[maybe_unused]] <span class="type">bool</span> is_evictable_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRUKReplacer implements the LRU-k replacement policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The LRU-k algorithm evicts a frame whose backward k-distance is maximum</span></span><br><span class="line"><span class="comment"> * of all frames. Backward k-distance is computed as the difference in time between</span></span><br><span class="line"><span class="comment"> * current timestamp and the timestamp of kth previous access.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A frame with less than k historical references is given</span></span><br><span class="line"><span class="comment"> * +inf as its backward k-distance. When multiple frames have +inf backward k-distance,</span></span><br><span class="line"><span class="comment"> * classical LRU algorithm is used to choose victim.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUKReplacer</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">LRUKReplacer</span><span class="params">(<span class="type">size_t</span> num_frames, <span class="type">size_t</span> k)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DISALLOW_COPY_AND_MOVE</span>(LRUKReplacer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * TODO(P1): Add implementation</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @brief Destroys the LRUReplacer.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ~<span class="built_in">LRUKReplacer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Evict</span><span class="params">()</span> -&gt; std::optional&lt;<span class="type">frame_id_t</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">RecordAccess</span><span class="params">(<span class="type">frame_id_t</span> frame_id, AccessType access_type = AccessType::Unknown)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetEvictable</span><span class="params">(<span class="type">frame_id_t</span> frame_id, <span class="type">bool</span> set_evictable)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Size</span><span class="params">()</span> -&gt; <span class="type">size_t</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// TODO(student): implement me! You can replace these member variables as you like.</span></span><br><span class="line">  <span class="comment">// Remove maybe_unused if you start using them.</span></span><br><span class="line">  [[maybe_unused]] std::unordered_map&lt;<span class="type">frame_id_t</span>, LRUKNode&gt; node_store_;</span><br><span class="line">  [[maybe_unused]] <span class="type">size_t</span> current_timestamp_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  [[maybe_unused]] <span class="type">size_t</span> curr_size_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  [[maybe_unused]] <span class="type">size_t</span> replacer_size_;</span><br><span class="line">  [[maybe_unused]] <span class="type">size_t</span> k_;</span><br><span class="line">  [[maybe_unused]] std::mutex latch_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br></pre></td></tr></table></figure>

<p>​	该定义中存在几个有趣的定义，其中首先是<code>node_store_</code>，不难猜想，其就是我们需要来储存元信息的数据结构，那么，对应的元信息包含哪些？在<code>LRUKNode</code>中，可以看到其中核心的即是<code>fid_</code>和<code>is_evictable_</code>，若按照注释中的描述，其中的<code>fid_</code>成员是BPM调入的缓存的帧的序号，而<code>is_evictable_</code>是该帧是否可以被驱逐的状态，而这些都是外部所应该和维护好的。</p>
<p>​	其次我们需要看到预先给我们定义好的接口，这实际上是更加重要的东西，我们来讨论一个问题，如果是为了来完成这个Lab，什么才是定义我们完成与否的标准呢？是测试。而测试中会使用到什么呢？会使用到接口，也就是说，对于测试来说，其中的测试的使用方法就是本次Lab中所期望我们实现的接口的功能，我们应该阅读对应的测试代码。为什么？因为在这种环境下，测试代码的内容是给定的，而其中的代码内容相对于我们实现者来说是权威的。比起在莫名的上下文调用中去陷入回调地狱来进行分析，我们在一定程度上可以信赖测试代码，根据测试代码来反推我们的运行时使用环境，进而来建立起我们的约束。</p>
<h3 id="测试代码阅读"><a href="#测试代码阅读" class="headerlink" title="测试代码阅读"></a>测试代码阅读</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(LRUKReplacerTest, SampleTest) &#123;</span><br><span class="line">  <span class="comment">// Note that comparison with `std::nullopt` always results in `false`, and if the optional type actually does contain</span></span><br><span class="line">  <span class="comment">// a value, the comparison will compare the inner value.</span></span><br><span class="line">  <span class="comment">// See: https://devblogs.microsoft.com/oldnewthing/20211004-00/?p=105754</span></span><br><span class="line">  std::optional&lt;<span class="type">frame_id_t</span>&gt; frame;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the replacer.</span></span><br><span class="line">  <span class="function">LRUKReplacer <span class="title">lru_replacer</span><span class="params">(<span class="number">7</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add six frames to the replacer. We now have frames [1, 2, 3, 4, 5]. We set frame 6 as non-evictable.</span></span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">1</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">2</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">3</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">4</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">5</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">6</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">3</span>, <span class="literal">true</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">5</span>, <span class="literal">true</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">6</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The size of the replacer is the number of frames that can be evicted, _not_ the total number of frames entered.</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">5</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record an access for frame 1. Now frame 1 has two accesses total.</span></span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// All other frames now share the maximum backward k-distance. Since we use timestamps to break ties, where the first</span></span><br><span class="line">  <span class="comment">// to be evicted is the frame with the oldest timestamp, the order of eviction should be [2, 3, 4, 5, 1].</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Evict three pages from the replacer.</span></span><br><span class="line">  <span class="comment">// To break ties, we use LRU with respect to the oldest timestamp, or the least recently used frame.</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">2</span>, lru_replacer.<span class="built_in">Evict</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">3</span>, lru_replacer.<span class="built_in">Evict</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">4</span>, lru_replacer.<span class="built_in">Evict</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">2</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line">  <span class="comment">// Now the replacer has the frames [5, 1].</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert new frames [3, 4], and update the access history for 5. Now, the ordering is [3, 1, 5, 4].</span></span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">3</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">4</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">5</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">4</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">3</span>, <span class="literal">true</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">4</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Look for a frame to evict. We expect frame 3 to be evicted next.</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">3</span>, lru_replacer.<span class="built_in">Evict</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">3</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set 6 to be evictable. 6 should be evicted next since it has the maximum backward k-distance.</span></span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">6</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">4</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">6</span>, lru_replacer.<span class="built_in">Evict</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">3</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark frame 1 as non-evictable. We now have [5, 4].</span></span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We expect frame 5 to be evicted next.</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">2</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">5</span>, lru_replacer.<span class="built_in">Evict</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">1</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the access history for frame 1 and make it evictable. Now we have [4, 1].</span></span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">1</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">1</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">2</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Evict the last two frames.</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">4</span>, lru_replacer.<span class="built_in">Evict</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">1</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">1</span>, lru_replacer.<span class="built_in">Evict</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">0</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert frame 1 again and mark it as non-evictable.</span></span><br><span class="line">  lru_replacer.<span class="built_in">RecordAccess</span>(<span class="number">1</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">0</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A failed eviction should not change the size of the replacer.</span></span><br><span class="line">  frame = lru_replacer.<span class="built_in">Evict</span>();</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="literal">false</span>, frame.<span class="built_in">has_value</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark frame 1 as evictable again and evict it.</span></span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">1</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">1</span>, lru_replacer.<span class="built_in">Evict</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">0</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// There is nothing left in the replacer, so make sure this doesn&#x27;t do something strange.</span></span><br><span class="line">  frame = lru_replacer.<span class="built_in">Evict</span>();</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="literal">false</span>, frame.<span class="built_in">has_value</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">0</span>, lru_replacer.<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure that setting a nonexistent frame as evictable or non-evictable doesn&#x27;t do something strange.</span></span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">6</span>, <span class="literal">false</span>);</span><br><span class="line">  lru_replacer.<span class="built_in">SetEvictable</span>(<span class="number">6</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中我们可以看到几个非常有趣的api约定，在测试代码中存在这么一句断言ASSERT_EQ(5, lru_replacer.Size());，其中的注释描述说该断言要求Size()返回当前系统中可驱逐的frame数量，此时我们就明确了一个api所需要提供的保证。除此之外，我们可以来推测<code>RecordAccess</code>和<code>SetEvictable</code>受api的影响。首先，对于SetEvictable来说，其的语义肯定会涉及到对于内部状态的影响，其的直观语义是设置当前一个帧的状态为可驱逐与否，此时我们就需要更新内部对于当前可用帧的计数。同理，我们对于<code>RecordAccess</code>进行分析，但是此时的能明确的语义却很少，其是否应该修改对应的计数在这里实际上并没有表现出来，需要我们来继续阅读后续的测试代码来完善。</p>
<p>总的来说，测试代码的阅读，确实能够给我们明确一些调用场景，而且由于我们相信这个测试代码是相对权威的，所以我们可以根据对应的测试场景来反向指导我们的设计。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Event实现分析</title>
    <url>/2025/11/01/C++%E5%AD%A6%E4%B9%A0/5-event/</url>
    <content><![CDATA[<h1 id="Event实现思路"><a href="#Event实现思路" class="headerlink" title="Event实现思路"></a>Event实现思路</h1><p>本文借TinyCoro的Lab4a的契机，来分析一下一些底层的同步原语的一些实现细节以及其中能够学习的地方</p>
<span id="more"></span>

<h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>实现一种同步原语event，其的核心在于其的状态管理以及不同状态时其触发的行为。其的状态很简单，只考虑俩种状态，一种是未被<code>set</code>的状态，另外一种是已经被<code>set</code>了的状态。在未被<code>set</code>时，所有对于这个<code>event</code>调用<code>wait</code>操作时都会陷入阻塞态，如果当前的<code>event</code>已经被<code>set</code>，那么在当前尝试<code>wait</code>的，将不会阻塞而是直接执行下一条语句；对于那些已经<code>wait</code>阻塞在<code>event</code>中的，将会接触阻塞而进入运行态；对于那些后续尝试<code>wait</code>的，将不会阻塞而直接执行下一条语句。</p>
<p>额外需要注意的是，由于我们需要基于协程这个场景来实现，所以我们需要考虑我们后续会涉及到的线程安全实现，在这种基础组件的实现中，一般都不优先考虑线程级别的互斥锁，可以考虑一下为什么以及由此需要怎么来实现这种同步原语。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="状态建模"><a href="#状态建模" class="headerlink" title="状态建模"></a>状态建模</h3><p>前文说道，event本身涉及到的状态很简单，其中就是俩个，一个是已经Set，另外一个是还未Set。而且其中只可能存在一个从未Set向已经Set的状态之间的转移，但是没有办法进行从已经Set向未Set的状态之间的转移，也就是说本次设计中考虑的状态转移路径只存在一条。除此之外，对于状态，我们需要明确其的起始状态，这种初始状态的差异也可能导致event表现出不同的行为，如下俩图，你应该能够很轻松的了解到底是为什么需要这么来做。</p>
<p><img src="/2025/11/01/C++%E5%AD%A6%E4%B9%A0/5-event/image-20251102101427042.png" alt="初始为未Set的状态转移"></p>
<p><img src="/2025/11/01/C++%E5%AD%A6%E4%B9%A0/5-event/image-20251102101515847.png" alt="初始为已Set的状态转移"></p>
<p>接下来，关于event的分析，实际上就已经结束了，接下来就需要来进行一些细节上的实现了，我们需要考虑到底如何来实现这种FSM的建模。考虑到我懒，直接来给出对应的代码，自己一点点看吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> awaiter_ptr = <span class="type">uintptr_t</span>;</span><br><span class="line">std::atomic&lt;awaiter_ptr&gt; m_status;</span><br></pre></td></tr></table></figure>

<p>首先，我们使用一种机制来进行状态的压缩，即C++中支持的<code>uintptr_t</code>类型，实际上你可以将其理解为一种更加强大的类型擦除的容器，在其中的数据，外部访问将会将其视为一系列单纯的<code>bit</code>，我们可以对于这些<code>bit</code>通过那些类型解释语法来进行重解释。不过需要注意这个类型的大小，实际上其在语言中的初步定义为<code>unsigned long int</code>，所以在使用的时候需要保证不超过这种类型的长度。而这种长度对于常规的标准数据类型，还有特别是指针类型，其都是能够完全装入的，所以通过这个变量类型，我们就能够实现将各种状态压缩到一个变量中进行观测的效果。</p>
<p>接下来，我们需要来进行规定，既然我们将状态都压缩到一个无状态的变量中，我们需要来规定这个变量的不同取值情况都对应的什么状态。在后续的设计中，我们考虑按照如下的规定来进行状态的设置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="literal">nullptr</span> -&gt; 当前未被Set并且当前没有等待的awaiter</span><br><span class="line"><span class="keyword">this</span> -&gt; 当前已经被Set，这种<span class="keyword">this</span>指针理论上可以由任何魔数替换，但是使用<span class="keyword">this</span>实际上是一种更加优雅的设计</span><br><span class="line">other -&gt; 当前未被Set，但是已经存在等待的awaiter，当前的值就是该等待链表中的头结点</span><br></pre></td></tr></table></figure>



<h3 id="wait核心"><a href="#wait核心" class="headerlink" title="wait核心"></a>wait核心</h3><p>对于wait操作，我们首先明确其的调用场景，在外面的期望中，其可以由任意协程来发起，且可以在同一时间中发起，由于其涉及到一些共享状态间的修改，所以其势必需要考虑并发的竞态场景。而对于其的核心逻辑，简单可以概述为以下几条</p>
<ul>
<li><p>当一个<code>event</code>还没有被<code>set</code>时，需要将本协程挂起并且注册到内部的等待队列中等待唤醒</p>
</li>
<li><p>当一个<code>event</code>已经被<code>set</code>时，后续所有尝试进行wait的协程都不应该被该<code>event</code>阻塞住</p>
</li>
</ul>
<p>而对应着几个实际的状态值，我们可以简单的考虑如下的程序流程</p>
<ul>
<li>使用<code>CAS</code>操作获取尝试获取当前的状态</li>
<li>判断当前的状态，如果处于<code>this</code>，代表当前event已经被set，此时就不必再阻塞，直接返回即可</li>
<li>若当前状态不属于<code>this</code>，代表此次操作会导致该协程的阻塞，此时就得考虑是否修改当前event的状态以及如何来挂载当前的协程</li>
</ul>
<p>实际上实现起来很简单，现有的一个wait实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本函数的调用场景是当一个协程尝试进行一次event.wait()时被调用</span></span><br><span class="line"><span class="comment">// 其的返回值决定当前的协程是否需要挂起等待</span></span><br><span class="line"><span class="comment">// 当event已经被set时，直接返回false，表示不需要挂起</span></span><br><span class="line"><span class="comment">// 当event未被set时，将当前协程的awaiter加入等待链表，并返回</span></span><br><span class="line"><span class="comment">// 当当前状态为非this时，其的status中的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">event_base::register_awaiter</span><span class="params">(awaiter_base* awaiter)</span> <span class="keyword">noexcept</span> -&gt; <span class="type">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> status = m_status.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(status == <span class="built_in">reinterpret_cast</span>&lt;awaiter_ptr&gt;(<span class="keyword">this</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时是当前的event没有被set，需要将当前协程的awaiter加入等待链表</span></span><br><span class="line">        <span class="comment">// 但是实际上当前可能存在俩种情况，一种是nullptr，一种是实际的awaiter指针</span></span><br><span class="line">        <span class="comment">// 对于这俩种场景，实际上的处理逻辑可以统一，只要构建出一个链表即可</span></span><br><span class="line">        <span class="comment">// 我们接下来的期望是交换出当前的status，并将当前的awaiter构建进链表中</span></span><br><span class="line">        awaiter-&gt;m_next = <span class="built_in">reinterpret_cast</span>&lt;awaiter_base*&gt;(status);</span><br><span class="line">    &#125;<span class="keyword">while</span>(!m_status.<span class="built_in">compare_exchange_weak</span>(status,<span class="built_in">reinterpret_cast</span>&lt;awaiter_ptr&gt;(awaiter),std::memory_order_release,std::memory_order_acquire));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="set核心"><a href="#set核心" class="headerlink" title="set核心"></a>set核心</h3><p>对于set操作，其的逻辑实际上很简洁，就是将当前的状态进行修改，并将当前所有的阻塞的协程都恢复执行，其的程序流程也很简单，就是如下的考虑</p>
<ul>
<li>直接原子的修改当前的状态为this，代表当前已经被set，阻挡后续的wait操作阻塞</li>
<li>将等待队列中的系列等待协程按照一定的次序进行释放，提供一种保障</li>
</ul>
<p>实现起来也并不复杂，一个可能的实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">event_base::set_state</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> status = m_status.<span class="built_in">exchange</span>(<span class="built_in">reinterpret_cast</span>&lt;awaiter_ptr&gt;(<span class="keyword">this</span>), std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="built_in">reinterpret_cast</span>&lt;awaiter_ptr&gt;(<span class="keyword">this</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> header = <span class="built_in">reinterpret_cast</span>&lt;awaiter_base*&gt;(status);</span><br><span class="line">        <span class="built_in">resume_all_awaiters</span>(header);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">event_base::resume_all_awaiters</span><span class="params">(awaiter_base *head)</span> <span class="keyword">noexcept</span> -&gt; <span class="type">void</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> current = head;</span><br><span class="line">    <span class="keyword">while</span>(current)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> next = current-&gt;<span class="built_in">get_next</span>();</span><br><span class="line">        <span class="comment">// 投递回原线程操作避免跨线程唤醒</span></span><br><span class="line">        current-&gt;m_ctx.<span class="built_in">submit_task</span>(current-&gt;to_resume);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>15445 类型系统</title>
    <url>/2025/12/06/%E6%95%B0%E6%8D%AE%E5%BA%93/15445-type/</url>
    <content><![CDATA[<h1 id="BusTub类型系统"><a href="#BusTub类型系统" class="headerlink" title="BusTub类型系统"></a>BusTub类型系统</h1><p>本文来分析下15445中的类型系统的实现，这一块的设计很优雅，十分由学习和参考的价值</p>
<span id="more"></span>

<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>对于BusTub来说，其的类型支持是由多个部分组合而成的，自底向上来进行分析其实可以看到其中的组件的配合格式，包含了Value，Type，Schema，Column等不同层次，不同职责的底层组件，通过了解这些组件的设计，能够一窥BusTub的设计思路，其中存在着很多有趣的内容指的我们学习。</p>
<h2 id="Value类"><a href="#Value类" class="headerlink" title="Value类"></a>Value类</h2><p>​	该类的基本抽象是数据的容器，其需要负责该DBMS中所有支持的数据类型的封装抽象，其中的核心是一下的成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// The actual value item</span></span><br><span class="line">  <span class="keyword">union</span> <span class="title class_">Val</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> boolean_;</span><br><span class="line">    <span class="type">int8_t</span> tinyint_;</span><br><span class="line">    <span class="type">int16_t</span> smallint_;</span><br><span class="line">    <span class="type">int32_t</span> integer_;</span><br><span class="line">    <span class="type">int64_t</span> bigint_;</span><br><span class="line">    <span class="type">double</span> decimal_;</span><br><span class="line">    <span class="type">uint64_t</span> timestamp_;</span><br><span class="line">    <span class="type">char</span> *varlen_;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *const_varlen_;</span><br><span class="line">  &#125; value_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> len_;</span><br><span class="line">    TypeId elem_type_id_;    </span><br><span class="line">  &#125; size_;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> manage_data_;</span><br><span class="line">  TypeId type_id_;</span><br></pre></td></tr></table></figure>

<p>​	其通过<code>union</code>来实现不同类型的压缩，其中各个可能的union值的含义在其的命名中已经体现了。其中存在一个取决于上层需求的设计，除了定长数据之外，还会存在变长的数据，而正如常规的DBMS设计一般，这里考虑使用一层指针来统一处理，即其中的指针类型。对于定长数据来说，其value本身就代表数据，但是变长的数据本身只是指针，其还需要维护其指向的地址上的额外元数据，就比如长度等才能够更好的来处理整段数据。而<code>size_</code>就是来储存这段信息的。其中的<code>len_</code>隐含了指针指向的数据的长度，通过先前的指针+此处的长度限定来框定数据所在的实际内存区域。而<code>elem_type_id</code>实际上是用于向量数据库的内容，其表示了该向量中的元素的类型。</p>
<blockquote>
<p>这里其实存在一个考虑，为什么value_ 、size_中要使用union来处理数据，为什么能够使用union来设计。在我的理解中，这里涉及到对应的成员值域的互斥性以及有限性，即，该类的这些属性是有限且明确的。每次都有且只有选择一个取值，就比如上文中，我们如果初始化一个Value类，其必须指定该类的类型，而这些类型则最终由内部的union直接配合形成。这样使得类型表示直接内聚在内部，使得后续维护的时候能够只通过阅读该类就了解的七七八八。但是，同时实际上存在一些缺陷，其中一个就是其所支撑的值域一般不会太大，当其支持的类型膨胀的太大时，此时的可读性又会下降，所以此时又会存在相应的权衡</p>
</blockquote>
<p>​	除此之外，还存在俩个有趣的设计。先看到type_id_，其中储存的就是本value实际对应的类型信息，为什么要存在该字段？这实际上就是一种<strong>类型擦除</strong>的想法，通过将类型信息保存在内部，外部可以通过统一的接口来使用不同类型的数据。同时，有了该字段，内部的接口设计也可以更加明确，其更多的功能实现可以依赖内部，这实际上能够与union打上配合，若没有这个类型信息，将依赖于外部的参数来决定需要怎么来解释内部的俩个成员，而如果有了这俩者，此时基本所有的处理都能够在内部自行解决，只需要暴露给外部一个简洁的接口。再者是<code>manage_data_</code>，在我看来，这实际上是一个优化手段，其表示当前的value中是否是储存的实际数据，又或只是一个指针。其内部储存的数据类型会影响到后续该Value类所应该实现的拷贝行为，后续就是常规的深拷贝以及浅拷贝之间的区分。如若没有该字段，通过类型ID的查找以及比对，也能够实现相同的功能，但是相对而言其的计算代价就比较高。此处是通过利用空间换时间的权衡来优化该类的实现的。</p>
<h2 id="Type类"><a href="#Type类" class="headerlink" title="Type类"></a>Type类</h2><p>​	上文已经基本了解了Value类，不难注意到，Value类实际上的职责集中在如何来储存不同类型的数据，其通过union来压缩储存的使用，使用一些冗余字段来优化使用，但是总的方向还是集中在储存层面。但是一个类型系统中，一个类型的数据不是储存后就行了的，其后续势必会使用该类型数据进行一系列的逻辑运算，而Type类就是为了解决类型的运算需求所出现的。</p>
<p>​	考虑一个问题，为什么此处要将计算逻辑与储存逻辑给分离开来？其的动机实际上很简单，就是当前的类型过多，如果需要在一个Value类中实现各个类型中的各种运算方法，此时实现起来将会很丑且复杂，其可能是通过一层层的switch-case来实现的，这实际上不够优雅也不够清晰，更不容易令人维护。因为在这种情况下，整体的状态复杂度将会飙升至N*M，其中N为类型的数量，M为一个类型所需的运算接口数量。而这种复杂度是不可接受的。所以自然而然的，想到将储存和运算分离开来。这种就是常规的解耦思想。在明确了我们需要将储存与运算分离开来之后，我们需要考虑将什么作为桥接这俩者之间的桥梁，最直观的，就是使用类型，也就是<code>TypeId</code>作为俩者之间的唯一联系。使用类型作为桥梁很符合系统所需要的语义，一个类型的运算接口首先是应该基于该类型的。</p>
<p>​	接下来看到Type类的基础定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">CmpBool</span> &#123; CmpFalse = <span class="number">0</span>, CmpTrue = <span class="number">1</span>, CmpNull = <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Type</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Type</span><span class="params">(TypeId type_id)</span> : type_id_(type_id) &#123;</span>&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Type</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">GetTypeSize</span><span class="params">(TypeId type_id)</span> -&gt; <span class="type">uint64_t</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">IsCoercableFrom</span><span class="params">(TypeId type_id)</span> <span class="type">const</span> -&gt; <span class="type">bool</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">TypeIdToString</span><span class="params">(TypeId type_id)</span> -&gt; std::string</span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">GetMinValue</span><span class="params">(TypeId type_id)</span> -&gt; Value</span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">GetMaxValue</span><span class="params">(TypeId type_id)</span> -&gt; Value</span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="keyword">auto</span> <span class="title">GetInstance</span><span class="params">(TypeId type_id)</span> -&gt; Type * </span>&#123; <span class="keyword">return</span> k_types[type_id]; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">GetTypeId</span><span class="params">()</span> <span class="type">const</span> -&gt; TypeId </span>&#123; <span class="keyword">return</span> type_id_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">CompareEquals</span><span class="params">(<span class="type">const</span> Value &amp;left, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; CmpBool</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">CompareNotEquals</span><span class="params">(<span class="type">const</span> Value &amp;left, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; CmpBool</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">CompareLessThan</span><span class="params">(<span class="type">const</span> Value &amp;left, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; CmpBool</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">CompareLessThanEquals</span><span class="params">(<span class="type">const</span> Value &amp;left, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; CmpBool</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">CompareGreaterThan</span><span class="params">(<span class="type">const</span> Value &amp;left, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; CmpBool</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">CompareGreaterThanEquals</span><span class="params">(<span class="type">const</span> Value &amp;left, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; CmpBool</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Other mathematical functions</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Value &amp;left, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; Value</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Subtract</span><span class="params">(<span class="type">const</span> Value &amp;left, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; Value</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Multiply</span><span class="params">(<span class="type">const</span> Value &amp;left, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; Value</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Divide</span><span class="params">(<span class="type">const</span> Value &amp;left, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; Value</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Modulo</span><span class="params">(<span class="type">const</span> Value &amp;left, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; Value</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Min</span><span class="params">(<span class="type">const</span> Value &amp;left, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; Value</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Max</span><span class="params">(<span class="type">const</span> Value &amp;left, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; Value</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Sqrt</span><span class="params">(<span class="type">const</span> Value &amp;val)</span> <span class="type">const</span> -&gt; Value</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">OperateNull</span><span class="params">(<span class="type">const</span> Value &amp;val, <span class="type">const</span> Value &amp;right)</span> <span class="type">const</span> -&gt; Value</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">IsZero</span><span class="params">(<span class="type">const</span> Value &amp;val)</span> <span class="type">const</span> -&gt; <span class="type">bool</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">IsInlined</span><span class="params">(<span class="type">const</span> Value &amp;val)</span> <span class="type">const</span> -&gt; <span class="type">bool</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">ToString</span><span class="params">(<span class="type">const</span> Value &amp;val)</span> <span class="type">const</span> -&gt; std::string</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SerializeTo</span><span class="params">(<span class="type">const</span> Value &amp;val, <span class="type">char</span> *storage)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">DeserializeFrom</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *storage)</span> <span class="type">const</span> -&gt; Value</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Copy</span><span class="params">(<span class="type">const</span> Value &amp;val)</span> <span class="type">const</span> -&gt; Value</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">CastAs</span><span class="params">(<span class="type">const</span> Value &amp;val, TypeId type_id)</span> <span class="type">const</span> -&gt; Value</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">GetData</span><span class="params">(<span class="type">const</span> Value &amp;val)</span> <span class="type">const</span> -&gt; <span class="type">const</span> <span class="type">char</span> *</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">GetStorageSize</span><span class="params">(<span class="type">const</span> Value &amp;val)</span> <span class="type">const</span> -&gt; <span class="type">uint32_t</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// The actual type ID</span></span><br><span class="line">  TypeId type_id_;</span><br><span class="line">  <span class="comment">// Singleton instances. 为每个类型分配一个静态实例</span></span><br><span class="line">  <span class="type">static</span> Type *k_types[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	映入眼帘的是一系列的接口，该类接口约定了一个Type类型的类所需要实现的接口，此处你可能存在一个问题，这里为什么不使用纯虚函数，可以携带该疑问继续阅读。</p>
<p>​	其中的各个接口即是各个类型特化后的实现类需要实现的接口，其中的实现也很有意思，虽然说其中的逻辑可能比较简单，但是由于本身类型系统需要支持的类型的种类的繁多，所以其实现起来实际上也很有挑战性，在BusTub中，其的类型计算类的实现充分利用了OOP的性质，但是这个不是本次讨论的重点，下面给出系统中各个类的继承结构图，感兴趣可以自行翻阅代码查看。</p>
<p><img src="/2025/12/06/%E6%95%B0%E6%8D%AE%E5%BA%93/15445-type/image-20251206163721277.png" alt="类型树"></p>
<p>​	接下来将注意力集中到父类Type的实现上，我们来分析其涉及的有趣地方。在BusTub中，其并未使用纯虚函数来进行接口的强制约定，而是使用了一种更加巧妙且优雅的格式，在Type中，其中几乎所有的接口的实现(除开那些可以相对通用的，就比如GetTypeSize，GetMaxValue)都是相同的，都是类似于下面这种实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Type::CompareEquals</span><span class="params">(<span class="type">const</span> Value &amp;left , <span class="type">const</span> Value &amp;right )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    -&gt; CmpBool </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">NotImplementedException</span>(<span class="string">&quot;CompareEquals not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Type::CompareNotEquals</span><span class="params">(<span class="type">const</span> Value &amp;left)</span>, <span class="type">const</span> Value &amp;right) <span class="type">const</span></span></span><br><span class="line"><span class="function">    -&gt; CmpBool </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">NotImplementedException</span>(<span class="string">&quot;CompareNotEquals not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	都是直接在函数体中直接抛出异常，这实际上很优雅，其利用了多态，使得所有在上面所描述的树上的节点中都势必需要在回溯到达父基类的虚函数表前提供特定的算术逻辑实现。否则在使用时就会导致最后的异常的层层抛出。同时，这里实际可以存在一些优化，就比如在这棵继承树上，实际上你可以在中间一些节点上来使用纯虚函数来提前编译期进行约束。这是一种可选优化，这同时也体现了当前的这个设计中的灵活性。</p>
<blockquote>
<p>你可能会考虑在父类中抛出异常是否会导致性能的下降。但是，在我看来，实际上这种考虑是多余的。因为，这个类型系统是在内部设计中，我们在这种环境下都是存在了一个基础的假设，就是各方都可信的，所以一般都是会在实际的类型计算类中完整的给出各个接口的定义，以至于在第一次调用时就可以直接返回，实际上并不会导致层层的回溯到达根节点这种最坏的情况。</p>
<p>甚至于前面已经说过，其实你可以在Type后的节点中的某一层来使用纯虚函数来约定接口，使得实现一种更早的编译期检查，当然，这是一种可选优化。</p>
</blockquote>
<p>前文所涉及到的Value和Type类相配合共同支撑起了BusTub底层的数据储存。但是，对于上层来说，使用这些还是过于麻烦了，特别是对于数据库来说，我们期望使用一些更加贴近业务的表达形式来描述数据。此时，就出现了Column和Scheme。</p>
<h2 id="Column类"><a href="#Column类" class="headerlink" title="Column类"></a>Column类</h2><p>​	关于Column和Scheme，这是数据库中的常客，我们不再赘诉，但是还是得描述一下其到底是怎么与前文所提到的Value和Type联动的。在BusTub中，Value和Type类共通组合形成了数据的底层组织形式，但是这些数据本质上只是添加了一些类型描述的二进制数据而已，对于上层来说，获取这些数据本身是没有意义的，其所期望的是一些已经被业务所解释后的数据。在数据库中，这种解释方法就是模式Scheme，而对于Scheme来说，其的基本组成单元就是Column。我们从Column开始，逐层往上，了解到底BusTub是怎么来解释其的数据的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Column name. */</span></span><br><span class="line">std::string column_name_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前列的数据类型 */</span></span><br><span class="line">TypeId column_type_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The size of the column. */</span></span><br><span class="line"><span class="type">uint32_t</span> length_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Column offset in the tuple. */</span></span><br><span class="line"><span class="type">uint32_t</span> column_offset_&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>​	其中就是基本的几个元信息，包含的是一些业务信息，就比如，<code>column_name_</code>包含上层期望的该字段的描述信息，<code>column_type_</code>包含用户定义的类型，length_表示该字段所占据的长度(可能是类型内置或者用户指定)，而<code>column_offset_</code>在这里有点难以观察用户，因为这实际上是由Scheme指定，Scheme使用的属性，标识的是该Column在该Scheme中的偏移位置。</p>
<p>​	其他信息，包括Column类中包含的接口，其中并没有什么特别的地方，Column本身的生态位就是数据储存，其中的核心就是上述的几个字段，其的接口一般都是针对于该Column中的部分元信息的获取。</p>
<h2 id="Scheme类"><a href="#Scheme类" class="headerlink" title="Scheme类"></a>Scheme类</h2><p>​	Scheme是上层经常使用的抽象，这里的Scheme所提供的抽象是对于一段字节数据的解释方法，其规定了一段连续的内存序列应该如何来解释。以下是Scheme中的数据成员定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">/** Fixed-length column size, i.e. the number of bytes used by one tuple. */</span></span><br><span class="line"> <span class="type">uint32_t</span> length_;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** All the columns in the schema, inlined and uninlined. */</span></span><br><span class="line"> std::vector&lt;Column&gt; columns_;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** True if all the columns are inlined, false otherwise. */</span></span><br><span class="line"> <span class="type">bool</span> tuple_is_inlined_&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** 所有未内联列的索引 */</span></span><br><span class="line"> std::vector&lt;<span class="type">uint32_t</span>&gt; uninlined_columns_;</span><br></pre></td></tr></table></figure>

<p>​	其中的length_代表的是当前模式中定长数据的总长度，其代表的长度包含了所有定长列的数据以及所有变长列的偏移量指针所占空间的总和。而这个实际上也是一个可选但基本已经必要的优化项。通过该项，在内部在部分场景处理时可以直接跳过定长的数据。具体的使用场景需要后续根据上层到底怎么构造的数据来进行分析，不在这里进行赘诉。</p>
<p>​	其次是核心的格式储存，columns_形成了整个Scheme的核心储存，其的逻辑形式就代表了该模式的储存形式，至于这一块，你应该能够理解，这里不再进行赘诉。</p>
<h2 id="GenericKey类"><a href="#GenericKey类" class="headerlink" title="GenericKey类"></a>GenericKey类</h2><p>​	接下来我们以一个BusTub中的上述类的实际使用来进行阶段性的收尾，该类是常用于B+树或其他数据结构中的KV储存，该类提供了能够于数据库中通用的数据格式。其通过类型擦除，OOP的封装等多个技术实现了优雅的系统组件，我们来看到其中的几个核心成员以及接口函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> KeySize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericKey</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">ToValue</span><span class="params">(Schema *schema, <span class="type">uint32_t</span> column_idx)</span> <span class="type">const</span> -&gt; Value </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data_ptr;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;col = schema-&gt;<span class="built_in">GetColumn</span>(column_idx);</span><br><span class="line">    <span class="type">const</span> TypeId column_type = col.<span class="built_in">GetType</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> is_inlined = col.<span class="built_in">IsInlined</span>();</span><br><span class="line">    <span class="keyword">if</span> (is_inlined) &#123;</span><br><span class="line">      data_ptr = (data_ + col.<span class="built_in">GetOffset</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">int32_t</span> offset = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int32_t</span> *&gt;(<span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(data_ + col.<span class="built_in">GetOffset</span>()));</span><br><span class="line">      data_ptr = (data_ + offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反序列化，实际上就是将数据重解释为对应类型的value</span></span><br><span class="line">    <span class="keyword">return</span> Value::<span class="built_in">DeserializeFrom</span>(data_ptr, column_type);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// actual location of data, extends past the end.</span></span><br><span class="line">  <span class="type">char</span> data_[KeySize];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	上面只给出了其中很少的接口，但该接口就是本类的核心了。首先看到该类的核心，即实际的数据储存地<code>data_</code>。该<code>data_</code>储存了该key的所有的数据，而这段数据可能是由多个域组合形成的。那么，外部需要怎么来使用该data_呢？实际上，此时需要通过外部处理数据时自行设定的模式，外部的使用中应该保证该<code>data_</code>实际上是由一个模式对应的数据紧凑而来的。后续才能够通过该模式来反序列化这里的数据。而核心就是ToValue接口。</p>
<p>​	在该接口中，其中的参数schema对应着该<code>data_</code>对应的原始模式，而<code>column_idx</code>指定本次所需要获取的逻辑列索引，该函数保证解析处对应的数据并按照定义该模式对应列时的类型返回。此时就完成了所谓的反序列化。实际上，这里所谓的“反序列化”，只是解释出来而已，并没有涉及到压缩等技术，所以比较好理解，后续可能可以在这方面进行优化(可能？…..)</p>
<h2 id="GenericComparator类"><a href="#GenericComparator类" class="headerlink" title="GenericComparator类"></a>GenericComparator类</h2><p>​	自此，我们拥有了一个逻辑上的Key，但是在二叉树等结构中，拥有Key时不够的，有时候我们需要对于Key进行一些算术操作，特别是其中的比较操作，这是在二叉树的CRUD操作中最核心的部分，而这部分的核心又是比较，但是基于Key的比较逻辑并没有直接给出，所以需要额外来实现一套机制。<code>GenericComparator</code>则是这套机制的最终实现。其的定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> KeySize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericComparator</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> GenericKey&lt;KeySize&gt; &amp;lhs, <span class="type">const</span> GenericKey&lt;KeySize&gt; &amp;rhs)</span> <span class="type">const</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> column_count = key_schema_-&gt;<span class="built_in">GetColumnCount</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; column_count; i++) &#123;</span><br><span class="line">      Value lhs_value = (lhs.<span class="built_in">ToValue</span>(key_schema_, i));</span><br><span class="line">      Value rhs_value = (rhs.<span class="built_in">ToValue</span>(key_schema_, i));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (lhs_value.<span class="built_in">CompareLessThan</span>(rhs_value) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lhs_value.<span class="built_in">CompareGreaterThan</span>(rhs_value) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// equals</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GenericComparator</span>(<span class="type">const</span> GenericComparator &amp;other) : key_schema_&#123;other.key_schema_&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">GenericComparator</span><span class="params">(Schema *key_schema)</span> : key_schema_(key_schema) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Schema *key_schema_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	其的成员key_schema_是核心，前文提到，为了解释一个Key，我们需要外部来进行模式的传入，而<code>GenericComparator</code>暂存了这个模式，这代表着所有满足该模式的Key都能够使用该<code>Comparator</code>来进行处理。其中的逻辑都很简单，不过我们可以来了解一下其中的比较规则的设计，这个能够辅助我们后续二叉树的实现。</p>
<p>​	对于该类的比较实现，其通过重载()运算符实现了简单的POP型的使用，这在我看来实际上也很优雅，其利用了OOP和POP的特点实现了一套高效且简洁的比较机制。在该比较机制中，其要求参数均为相同模式的key，后续其将遍历处理处该模式中的每一个Key，并按照BusTub中实现的运算逻辑来对于逻辑Key上的每一个独立Column进行比较。并给出简单的保证，若lhs&lt;rhs，则返回-1，若lhs&gt;rhs，则返回1，若俩者相等，则返回0.这样上层只需要注意该类返回值即可处理比较接口，相当简洁明了的接口。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
