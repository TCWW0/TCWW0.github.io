<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>QLineEdit</title>
    <url>/2024/12/20/QT%E6%8E%A7%E4%BB%B6/1-QLineEdit/</url>
    <content><![CDATA[<p><em>该文档进行QT中的QLineEdit控件的介绍</em></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>QLineEdit属于QT中一种常用的输入控件，用于用户层与数据层之间的交互</p>
<span id="more"></span>

<h2 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h2><p><em>在QLineEdit中，允许我们对于输入格式进行规定，其中一种很经典的模式就是掩码</em></p>
<p>其中存在着几种模式，简单介绍下</p>
<blockquote>
<p>QLineEdit属于输入插件，用来实现单行录入。支持几种录入模式。</p>
<p>Normal表示正常录入,录入的信息会显示在QLineEdit上。</p>
<p>Password表示密码录入的方式，录入的信息不显示QLineEdit，只是通过黑色圆点显示。</p>
<p>NoEcho 表示不显示录入信息，类似于Linux输入密码时，显示的是一片空白。</p>
<p>PasswordEchoOnEdit 表示在输入的一刹那可以看到字符，但是立刻变为不可见的黑色圆点显示。</p>
</blockquote>
<p>位于QT的官方英文文档可以自行查看，这里给出GPT的中文翻译掩码文档</p>
<img src="/2024/12/20/QT%E6%8E%A7%E4%BB%B6/1-QLineEdit/rules.png" alt="rules" style="zoom:80%;">

<p><img src="/2024/12/20/QT%E6%8E%A7%E4%BB%B6/1-QLineEdit/moreRules.png" alt="moreRules"></p>
<p>我们可以使用这些字符的多种排列组合来进行我们掩码的设计</p>
<p>对于GPT给出的语言，有些地方可能有点疑惑，我们来进行一下分析：</p>
<blockquote>
<ol>
<li><h5 id="必须输入"><a href="#必须输入" class="headerlink" title="必须输入"></a>必须输入</h5><p>​	这个没什么好说的，就是这个掩码在的位置上必须输入对应要求的字符</p>
</li>
<li><p><strong>允许使用但不要求使用</strong></p>
<p>​	这个指的是这个位置上可以输入数据也可以不输入数据。但是如果你要输入数据，</p>
<p>那么你输入的这个数据就必须是我们要求的数据。就比如<strong>a</strong>,对于这个占位符在的地方，</p>
<p>要么直接略过，要么就输入A-Z,a-z的字母。</p>
</li>
</ol>
</blockquote>
<p>​	</p>
<p>由上面，我们来举出一个例子，不进行赘述了，自行搓码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString ip=<span class="built_in">QString</span>(<span class="string">&quot;000.000.000.000;_&quot;</span>);</span><br><span class="line">   QString mac=<span class="built_in">QString</span>(<span class="string">&quot;HH:HH:HH:HH:HH:HH&quot;</span>);</span><br><span class="line">   ui-&gt;ipEdit-&gt;<span class="built_in">setInputMask</span>(ip);</span><br><span class="line">   ui-&gt;macEdit-&gt;<span class="built_in">setInputMask</span>(mac);</span><br></pre></td></tr></table></figure>

<p><em>题外话，QT的官方英文文档确实多且杂，还好现在有大模型可以减轻这方面的阅读压力啊</em></p>
<p>除了限定我们的输入格式之外，QLineEdit还提供了我们输入时的显示格式等一系列功能</p>
<p>这里我们只说明下对应的输入显示功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ui-&gt;pwdEdit-&gt;setEchoMode(QLineEdit::Password);</span></span><br><span class="line">   <span class="comment">//ui-&gt;pwdEdit-&gt;setEchoMode(QLineEdit::PasswordEchoOnEdit);</span></span><br><span class="line">   <span class="comment">//ui-&gt;pwdEdit-&gt;setEchoMode(QLineEdit::Normal);</span></span><br><span class="line">   ui-&gt;pwdEdit-&gt;<span class="built_in">setEchoMode</span>(QLineEdit::NoEcho);</span><br></pre></td></tr></table></figure>

<p>QT中提供了4种输入格式，分别就是上面的四个宏，都可以在对应的帮助文档中查询到，这里不进行赘述</p>
<p>直接给出GPT的翻译，简单看一下功能即可</p>
<p><img src="/2024/12/20/QT%E6%8E%A7%E4%BB%B6/1-QLineEdit/editRules.png" alt="editRules"></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote>
<p><em>回过头来看，使用掩码来直接规定输入格式其实在一定程序上限制了程序</em></p>
<p><em>因此，我们需要考虑一种具有更强的扩展性又很规范的格式来规定我们的输入</em></p>
<p><em>在QT中，正则表达式就是其中的一种</em></p>
</blockquote>
<p>在这里，我们并不深入去了解正则表达式的格式，我直接贴出GPT翻译后的规则</p>
<p>其实，正则表达式这种具有严格规定的模式设计起来很麻烦，</p>
<p>但是现在我们可以直接使用GPT去为我们生成对应的正则表达式，所以啊，善用工具吧</p>
<p><img src="/2024/12/20/QT%E6%8E%A7%E4%BB%B6/1-QLineEdit/regularRule.png" alt="regularRule"></p>
<p><img src="/2024/12/20/QT%E6%8E%A7%E4%BB%B6/1-QLineEdit/regularRule2.png" alt="regularRule2"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QRegularExpression <span class="title">regex</span><span class="params">(<span class="string">&quot;^[\\w\\.-]+@[\\w\\.-]+\\.[a-zA-Z]&#123;2,&#125;$&quot;</span>)</span></span>;</span><br><span class="line">QRegularExpressionValidator* validator=<span class="keyword">new</span> <span class="built_in">QRegularExpressionValidator</span>(regex,ui-&gt;emailEdit);</span><br><span class="line">ui-&gt;emailEdit-&gt;<span class="built_in">setValidator</span>(validator);</span><br></pre></td></tr></table></figure>

<p>如上，这就是一个GPT辅助生成的正则表达式，我只要理解了这些个到底是一个怎么个使用情况，</p>
<p>对于生成正则表达式这种吃力不讨好的工作就可以交给大模型来完成。</p>
<p><em><strong>话毕，溜溜球</strong></em></p>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT对话框</title>
    <url>/2024/12/20/QT%E6%8E%A7%E4%BB%B6/2-QTDialog/</url>
    <content><![CDATA[<p>​	<em><strong>在该博文中，我们将会进行一些QT对话框的了解</strong></em></p>
<p>​	<em>在本文中，将基于QT的api进行简单的了解，不会进行深入</em></p>
<h1 id="颜色对话框"><a href="#颜色对话框" class="headerlink" title="颜色对话框"></a>颜色对话框</h1><p>​	<img src="/2024/12/20/QT%E6%8E%A7%E4%BB%B6/2-QTDialog/colorDialog.png" alt="colorDialog"></p>
<span id="more"></span>

<p>​	上面这个对话框就是我们QT控件中自带的颜色对话框样式。</p>
<h4 id="对话框类名-QColorDialog"><a href="#对话框类名-QColorDialog" class="headerlink" title="对话框类名:	QColorDialog"></a>对话框类名:	<code>QColorDialog</code></h4><h4 id="构造函数所需参数"><a href="#构造函数所需参数" class="headerlink" title="构造函数所需参数:"></a>构造函数所需参数:</h4><p>​		1~<em>QColor颜色宏</em>	使用任意一个颜色宏以指定打开对话框时的默认颜色</p>
<p>​		2~<em>QWidget</em>指针*	使用任意一个<em>QWidget</em>类型类对象，将颜色对话框挂载到该窗口</p>
<h4 id="一些简单性质："><a href="#一些简单性质：" class="headerlink" title="一些简单性质："></a>一些简单性质：</h4><blockquote>
<p>​		<em>对于这个对话框，右下角会有俩个默认的和[Cancel]按钮。对于这俩个按钮，当	我们选择完或者自定义完我们的颜色并按下按钮后，这个颜色对话框将会被关闭，在默认	情况下，只有你站在最后关闭窗口是使用按钮，最后窗口的颜色属性都会被保存。否	则，还是只会保存上一次设定的颜色值，没有就是默认的颜色属性。</em></p>
<p>​		<em>我们可以使用QColorDialog类的currentColor方法进行获取这个颜色的属性，当然可	能看不懂它的输出。</em></p>
</blockquote>
<p>​		</p>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT布局</title>
    <url>/2024/12/27/QT%E6%8E%A7%E4%BB%B6/3-QT%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="QT布局"><a href="#QT布局" class="headerlink" title="QT布局"></a>QT布局</h1><p>​	QT中的大部分都是都是api，基本只要只要这东西的基本功能，再去用个几次，就能够比较熟练的运用了。至于布局，QT中的布局中存在三种方式，<strong>水平布局，垂直布局，栅格布局</strong>。</p>
<p>​	<span id="more"></span></p>
<h2 id="UI设置"><a href="#UI设置" class="headerlink" title="UI设置"></a>UI设置</h2><h3 id="布局控件"><a href="#布局控件" class="headerlink" title="布局控件"></a>布局控件</h3><p>​	如其他大部分的图形化控件一样，布局这种在UI设计师文件中也直接给集成好了，我们可以直接去拖动进行使用。而且一般来说吧，布局这种东西也一般只会在设计师文件中进行使用，需要使用代码去进行设计的情况其实不多，毕竟不好直观的控制它。</p>
<p>​	对于这些个控件的介绍，其实没什么好说的，只要是会用就行，所以我们这里主要来讲几个控件的使用。</p>
<p>​	首先，QT中ui文件的侧边栏中就可以找到我们所有的可以使用的控件，在这些个控件中，布局属于Layouts一栏中。</p>
<p><img src="/2024/12/27/QT%E6%8E%A7%E4%BB%B6/3-QT%E5%B8%83%E5%B1%80/1.png" alt="1"></p>
<p>​	上面这三个分别是Vertical Layout（垂直布局），Horizontal Layout（水平布局），Gird Layout（表格布局），Form Layout（表格布局），</p>
<p>​	其实我在这里对于这些布局控件是很难以描述的，所以还是得依靠自己去进行控件的使用去进行熟悉，虽然我也没有资格说这话就是了，我自己都对于这些个布局的使用不熟悉。</p>
<p>​	</p>
<h3 id="弹簧控件"><a href="#弹簧控件" class="headerlink" title="弹簧控件"></a>弹簧控件</h3><p>​	在常规的布局使用中，我们会存在一些问题，就是由于布局内部的自动调整，所以我们对于一些布局给我们生成的样式进行自行调整，我也不好描述，但是只要你自己亲手用过布局那你应该知道我在说什么。这时就需要我们去使用一个额外的控件去进行控制。在QT中，这系列控件就是下面这俩个Spacers控件</p>
<p><img src="/2024/12/27/QT%E6%8E%A7%E4%BB%B6/3-QT%E5%B8%83%E5%B1%80/3.png" alt="3"></p>
<p>​	这俩个存在的目的就是对于我们的布局进行一定的占位操作，通过这种占位我们可以实现一些我们布局的调整。说起来还是很抽象是吧，我们来上演示。</p>
<p>​	这里就没有给出没上这个控件前的演示了，主要是忘了。</p>
<p><img src="/2024/12/27/QT%E6%8E%A7%E4%BB%B6/3-QT%E5%B8%83%E5%B1%80/2.png" alt="2"></p>
<p>​	从图中，我们其实可以很清晰的看到这些个控件的布局效果，这里就不详细进行分析了，毕竟对于QT这种面向api编程的，去详细的了解它的底层并没有意义，主要是我也不知道，不然以我这发散思维不知道又能给我扯到哪里去。</p>
<p>​	对于这个弹簧形状的控件，我们还需要了解它的一个重要属性，就是调整它的形状，这个是在页面右下角的<strong>属性编辑器</strong>那里。</p>
<p><img src="/2024/12/27/QT%E6%8E%A7%E4%BB%B6/3-QT%E5%B8%83%E5%B1%80/5.png" alt="5"></p>
<p>​	在这个编辑器中，我们可以对于弹簧的一些属性进行设置，其中最常用的其实就是对于弹簧的宽度和高度进行设置，如果我们想要把这种设置福鼎下来，我们还需要去设置对应的sizeType为Fixed，这样的话我们一调整对应的数值，我们的ui界面上就能够有对应的改动。</p>
<p>​	这里还是没法多说，毕竟太抽象了，自己多动动手吧。</p>
<blockquote>
<p>​	坏了，对于这种面向api编程的东西，我烂尾了，我暂时不会再写这一类的东西了，毕竟这些实在是太无聊了，之后我看看视频跟着过一遍然后自己理解就行了，大家自求多福吧。</p>
</blockquote>
<h2 id="溜溜球"><a href="#溜溜球" class="headerlink" title="溜溜球"></a><strong>溜溜球</strong></h2>]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库介绍</title>
    <url>/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/0-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>​	在这一个分类中，将记录我的数据库学习过程，主要是个人在学习15-445网课的思考，敬请期待吧，没什么好说的，让我们开始吧。之后有什么要补充的将会在这篇文章中进行补充(如果没忘的话)。</p>
<span id="more"></span>



<p>​	首先，我需要对自己在modernSQL中体验到的一个感觉现说一下。</p>
<p>​	在一开始时会有很多的概念，这种东西会很消耗你的激情。此时我们需要有些东西来进行补充，而我认为的最好的补充方法就是进行一些手操，最直接的，就是去使用mySQL的mySQL Workbranch去手搓一个，无论简单还是复杂。</p>
<p>​	我体验下来的一个最直接感觉是，无论是什么数据库操作软件，命令行也好，图形化也好，最重要的其实是它底下的那个数据库，只要知道了对于的数据库。那么我们接下来进行的任何对这个数据库进行的查询，插入等等操作，都是一些对我们自己技能的进一步的封装，同时也是对于该软件的一步步api的了解罢了。正如QT框架一般。</p>
<p>​	需要注意的是，在该次学习中，书籍中的中级SQL和高级SQL并没有进行学习，这俩个章节主要是提高对于SQL使用的熟悉，但是这次学习主要的侧重是对于底层原理的了解，所以在这里先跳过，在之后有机会再回来学习。</p>
<p>​	对应的是，在15445的网课之中，对于SQL语句的学习也仅仅只有一节课进行一些简单的了解而已，之后就进入到了关系代数等的学习了。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>QEventFilter</title>
    <url>/2024/12/29/QT%E6%8E%A7%E4%BB%B6/4-eventfiliter/</url>
    <content><![CDATA[<blockquote>
<p>​	在接下来的QT中，我将会是一个相对无厘头的形态，属于是看到哪学到哪，并且大部分时间不会搓代码，只在之后使用一俩个相对不错的项目来进行熟悉。</p>
</blockquote>
<span id="more"></span>

<h1 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h1><p>QT中存在着一系列的系统供我们使用，信号与槽系统就是其中最出名的一个，同时，事件机制也是一个相当重要的系统。</p>
<p>​	</p>
<p>​	事件系统中相当重要的是一套函数:<em><em>event(QEcent</em> pevent)</em>*</p>
<p>​	QT中通过这套函数来进行事件的传递，我们这里不进行一些详细的分析，只进行一些简单的介绍，主要是我自己也不是很了解这东西。</p>
<p>​	</p>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><blockquote>
<p>​	在QT中，基本所有的类都存在着一套继承下来的event机制函数，通过这套函数，可以去使用QT的事件机制。</p>
</blockquote>
<p>​	首先来看一些比较经典的事件函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyEdit::keyPressEvent</span><span class="params">(QKeyEvent * event)</span></span></span><br></pre></td></tr></table></figure>

<p>​	这里的MyEdit是我们继承的LineEdit类，而这里的函数是我们对于父类的keyPressEvent函数的重写，通过这个重写，我们可以自定义处理我们的这个事件的行为。这个没什么好说的。</p>
<h3 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h3><p>​	<strong>主要是来我们事件的传递机制。</strong></p>
<p>​	在这里，我们其实是对于QLineEdit进行了一次继承的封装，那么，如果从设计模式来看的话，这里其实类似于一种由继承实现的装饰模式。在这个装饰类中，我们可以去使用对应的父类的事件函数来进行重写来添加我们的行为。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyEdit::keyPressEvent</span><span class="params">(QKeyEvent * event)</span></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;MyEdit key press event&quot;</span>;</span><br><span class="line">    QLineEdit::<span class="built_in">keyPressEvent</span>(event);</span><br><span class="line">    event-&gt;<span class="built_in">ignore</span>();    <span class="comment">//将这个事件往上抛</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在这种装饰下，本来的话当我们想要去使用一个QLineEdit控件的时候，其的对应的事件会直接传递给我们的控件基类去进行处理，而我们这里继承了该类并且重写了对应的事件处理函数，这就意味着我们为我们的基类信号处理行为添加了一层代理，所有的信号将会优先通过这个接口，而不是基类的接口。</p>
<h3 id="包装"><a href="#包装" class="headerlink" title="包装"></a>包装</h3><p>​	在这里，你如果没有使用基类的方法，那么你会发现它只是一个日志输出。所以，我们可以使用C++11的特性去进行父类方法的使用，这样的话我们就能够同时使用原有的控件的功能了，这样的话，其实又像极了设计模式中的外观模式。添加了一层额外的包装，这层包装与原来的包装形成了一套更加复杂的系统。但是，我们不必要去了解这上下的层次关系，只需要去关注于当前的设计即可，优秀啊。</p>
<h3 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h3><p>​	需要注意的是，在QT的事件机制中，当一个事件被处理之后，它会被自动的标记为已处理，并且不会再继续地去场传递。但是有时候我们希望我们的这些个事件可以被父对象给进行处理，这时候我们就需要使用我们的Event类的ignore函数。</p>
<p>​	通过这个函数，我们可以把这个事件重新标记为一种还未被处理的状态，然后这个事件就能够被父对象给进行接受了。以此类推，整个事件链条都支持这种处理方式。</p>
<p>​	也就是说，这种处理方式其实还是使用了设计模式的行为性设计模式的责任链模式的。</p>
<h4 id="事件传递与责任链模式"><a href="#事件传递与责任链模式" class="headerlink" title="事件传递与责任链模式"></a><strong>事件传递与责任链模式</strong></h4><p>Qt 的事件传递机制本质上可以视为一种 <strong>责任链模式</strong>，因为：</p>
<ol>
<li>事件的默认处理方式：<ul>
<li>事件被目标对象的事件处理函数捕获。</li>
<li>如果事件被标记为 <code>accepted</code>，则不再继续传递。</li>
</ul>
</li>
<li>通过 <code>ignore()</code> 实现传递：<ul>
<li>调用 <code>event-&gt;ignore()</code> 可以将事件标记为未处理。</li>
<li>未处理的事件会沿着父对象链向上传递，直到找到可以处理的对象，或最终丢弃。</li>
</ul>
</li>
</ol>
<h2 id="阶段归纳"><a href="#阶段归纳" class="headerlink" title="阶段归纳"></a>阶段归纳</h2><p>​	也就是说，QT的事件机制其实可以看做是一种责任链模式的高级应用。在这些个责任链上，基础的消息就是我们的事件。而这些个责任链的传递起始点，就是我们的用户层。第一个处理用户发出的事件的，就是我们对于一些类的额外实现。如果没有，那么就是我们的系列控件类，以此类推。</p>
<p>​	让我们来重新归纳下这个责任链条。在这个责任链条上，每一种类都是责任链条上的一个处理者。整个责任链条的起始点就是我们的用户层面，我们发出的总总行为动作就是这个责任链条上传递的信息，这些责任链条的构成其实就是我们的一种父子关系的一种体现。可以这么说，每个责任链条上的节点的上一层节点都是他的父对象。注意，不是对应的继承的父对象，而是绑定的父对象。</p>
<p>​	这个责任链条上，每一层的节点代表的是一个大类，就比如我们的QLineEdit，这个会是对应的使用的原本的QLineEdit的链条上的一个环节。而如果是我们自己实现的MyEdit，这个会是我们另一个使用这个MyEdit对象的链条上的另一个节点，这俩者之间是不一定相交的。</p>
<h3 id="特殊处"><a href="#特殊处" class="headerlink" title="特殊处"></a>特殊处</h3><p>​	我们再来对这个责任链条上的节点进行一些分析，需要注意的是，这些</p>
<p>责任链条上对于事件的处理是有一定的逻辑的。所有的事件当它到达我们的对应的层级时，它会先被我们这个节点上的event函数进行分析并且处理，如果可能，这个信号还会被继续分发到更下层的处理函数中进行处理，以此类推，这些事件处理可能存在多个层次，但是总的来说一般只有event和具体的event处理这俩个层次。</p>
<p>​	还有，对于事件的处理，这俩个都会进行接受，但是否进行对应的操作，取决于这个事件中的一个特殊属性。姑且可以把这个属性称之为是否已处理。在进入任何一个event处理函数后，这个对应的事件都会被标记为已处理的，如果已经被标记为以处理，那么这个事件将不会被传递到这个链条的任何一层，哪怕是同一层的更深处也是一样。</p>
<h3 id="event和深层函数处理"><a href="#event和深层函数处理" class="headerlink" title="event和深层函数处理"></a>event和深层函数处理</h3><p>​	event是一个节点层次的一个相对来说更接近时间发出者的一个层次，在这个层次中，其控制了这个信号接下来的具体流向，其返回一个bool值，如果我们在这个函数处理后返回了一个true，就代表着这个信号已经处理完毕，接下来这个信号将不会被任何处理函数所接收。如果我们这个函数最后返回了一个false，那么这个函数还是会被接下来的下一层次的节点所进行解析。</p>
<p>​	但是，这里简单的返回true和返回false有时并不能满足我们的需求，因为这种返回是不会使得函数实现原有的功能的，要实现我们原有的功能，就需要去在这个event函数中去使用C++11中的新特性，去调用对应的事件处理函数。</p>
<p>​	我们一种常见的用法就是在我们的return语句中去进行对应的父类事件处理函数的调用，毕竟这些个事件处理函数都是一个受保护的状态，我们可以通过对应的操作去进行使用，就比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyEdit::event</span><span class="params">(QEvent *pevent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保证重写的是当前类的函数</span></span><br><span class="line">    <span class="keyword">if</span>(pevent-&gt;<span class="built_in">type</span>() == QEvent::KeyPress)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;my edit event&quot;</span>) &lt;&lt; Qt::endl;</span><br><span class="line">        <span class="comment">//return false;</span></span><br><span class="line">        <span class="comment">//在一层的event函数返回false就代表着这个类的这个信号处理结束</span></span><br><span class="line">        <span class="comment">//返回true标志处理好了，接下来会传递但不会继续处理</span></span><br><span class="line">        <span class="comment">//返回false会继续向下一层进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  QLineEdit::<span class="built_in">event</span>(pevent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	需要注意的是，在在这里面，其实就是进行了一次控制流的更改，将当前流转向对应的事件处理流中，等到全部处理完成后返回这个event才会继续去判断这个是否还要继续去往上层去传递。</p>
<p>​	也就是说，这种流的转向其实是用于我们当前event函数中去进行特定额外的信号处理的机制的。</p>
<p>​	接下来我们来时候一下这种流的转向会遇到的一种有趣的情况。</p>
<p>​	在我们的event函数中调用注入**QLineEdit::event(pavent);**函数后，这个函数会去进行对应的函数的调用，有趣的是，这里产生的效果却是我们重载的事件处理函数的效果。</p>
<p>​	目前来说这几个函数对我们来说都是黑盒，但是我们不难猜测，这是运用了多态的一种特性。在整个事件处理链条的层次中，每个层次中的事件处理函数只会存在一个。如果我们对于事件处理函数进行了重载，那么这个处理函数就会去替换原有的函数的位置，全部的事件处理函数都遵守这个规则。所以，我们如果需要去进行额外的添加，我们还需要做的是在重载的事件处理函数中去使用原有的事件处理方法去进行这个节点的行为的填充。这种又是一种装饰模式的体现。</p>
<p>​	</p>
<blockquote>
<p>接下来给出一个GPT的总结版本</p>
</blockquote>
<h2 id="GPT归纳版本"><a href="#GPT归纳版本" class="headerlink" title="GPT归纳版本"></a>GPT归纳版本</h2><hr>
<h3 id="事件机制与责任链模式"><a href="#事件机制与责任链模式" class="headerlink" title="事件机制与责任链模式"></a>事件机制与责任链模式</h3><ol>
<li><strong>事件的责任链传递</strong>：<ul>
<li>事件从用户层发起，沿着父对象关系形成的链条逐级向上传递。</li>
<li>每个对象是责任链上的一个处理节点，具有决定是否处理该事件的权利。</li>
</ul>
</li>
<li><strong>父对象 vs. 父类</strong>：<ul>
<li>父对象是通过 <code>QObject::setParent</code> 或构造函数参数指定的对象，形成实际的对象层级关系。</li>
<li>父类是继承层级中的基类，与责任链无直接关系。</li>
</ul>
</li>
<li><strong>节点上的事件处理逻辑</strong>：<ul>
<li>事件到达一个节点时，优先调用该节点的 <code>event</code> 方法。</li>
<li>如果未处理（返回 <code>false</code>），则事件继续向上层节点传递。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="event-函数的深度解析"><a href="#event-函数的深度解析" class="headerlink" title="event 函数的深度解析"></a><code>event</code> 函数的深度解析</h3><ol>
<li><strong><code>event</code> 的双层处理机制</strong>：<ul>
<li><strong>第一层</strong>：<code>event</code> 函数负责高层次的事件分发，比如识别事件类型。</li>
<li><strong>第二层</strong>：更具体的事件处理函数（如 <code>keyPressEvent</code>）完成细化逻辑。</li>
</ul>
</li>
<li><strong>流控制</strong>：<ul>
<li>返回 <code>true</code>：事件被标记为已处理，不再传递。</li>
<li>返回 <code>false</code>：事件未处理，继续向上层或同层其他处理器传递。</li>
</ul>
</li>
<li><strong>保留原功能的方式</strong>：<ul>
<li>调用基类的 <code>event</code> 或具体的事件处理方法（如 <code>QLineEdit::event</code>），保留该类原有的事件处理逻辑。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="多态与装饰模式的结合"><a href="#多态与装饰模式的结合" class="headerlink" title="多态与装饰模式的结合"></a>多态与装饰模式的结合</h3><ol>
<li><strong>多态性</strong>：<ul>
<li>当调用 <code>QLineEdit::event(pevent)</code> 时，实际上调用的是 <code>MyEdit</code> 的重载实现（如果存在）。</li>
<li>这是 C++ 中多态特性的体现，通过虚函数机制确保子类对基类行为的覆盖。</li>
</ul>
</li>
<li><strong>装饰模式的体现</strong>：<ul>
<li>在子类的 <code>event</code> 方法中，通过调用基类的 <code>event</code>，在其基础上添加额外逻辑，形成装饰模式的效果。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="示例补充"><a href="#示例补充" class="headerlink" title="示例补充"></a>示例补充</h3><p>可以扩展现有代码的注释，进一步强调核心逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyEdit::event</span><span class="params">(QEvent *pevent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断事件类型</span></span><br><span class="line">    <span class="keyword">if</span> (pevent-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;my edit event&quot;</span>) &lt;&lt; Qt::endl;</span><br><span class="line">        <span class="comment">// 处理自定义逻辑，但不阻止事件向下传递</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 返回 false 表示未完全处理，允许后续处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类的事件处理逻辑，保留 QLineEdit 原有行为</span></span><br><span class="line">    <span class="keyword">return</span> QLineEdit::<span class="built_in">event</span>(pevent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>你已经很好地总结了 Qt 事件机制与相关设计模式的核心思路。可以进一步结合代码实践，验证如下几个问题：</p>
<ul>
<li><strong>事件传递</strong>：在某节点标记为已处理后，观察事件是否会继续传递到父对象。</li>
<li><strong>多态行为</strong>：通过不同的继承与重写组合，探究多态在事件处理中的实际效果。</li>
</ul>
<h2 id="事件过滤器"><a href="#事件过滤器" class="headerlink" title="事件过滤器"></a>事件过滤器</h2><blockquote>
<p>​	在QT中的事件处理机制中，还存在着一个相当重要的机制，就是我们的过滤器机制。通过这个机制，我们可以对于一个用户发出的事件进行过滤，没错，就是你想的那种过滤。</p>
</blockquote>
<h3 id="使用事件过滤器的步骤"><a href="#使用事件过滤器的步骤" class="headerlink" title="使用事件过滤器的步骤"></a>使用事件过滤器的步骤</h3><ol>
<li>继承 <code>QObject</code> 并重写 <code>eventFilter</code> 方法：<ul>
<li>事件过滤器需要继承自 <code>QObject</code> 并实现 <code>eventFilter()</code> 方法。</li>
<li><code>eventFilter()</code> 接收两个参数：目标对象和事件本身。</li>
</ul>
</li>
<li>安装事件过滤器：<ul>
<li>通过 <code>installEventFilter()</code> 方法，将事件过滤器安装到目标对象上。</li>
</ul>
</li>
</ol>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEventFilter</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断事件类型</span></span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">            QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Key pressed:&quot;</span> &lt;&lt; keyEvent-&gt;<span class="built_in">text</span>();</span><br><span class="line">            <span class="comment">// 返回 true 阻止事件继续传播，返回 false 允许传播</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 事件被拦截</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> QObject::<span class="built_in">eventFilter</span>(watched, event);  <span class="comment">// 调用基类处理其他事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget w;</span><br><span class="line">    MyEventFilter *filter = <span class="keyword">new</span> <span class="built_in">MyEventFilter</span>();</span><br><span class="line">    w.<span class="built_in">installEventFilter</span>(filter);  <span class="comment">// 将事件过滤器安装到 QWidget 上</span></span><br><span class="line"></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件过滤器的作用"><a href="#事件过滤器的作用" class="headerlink" title="事件过滤器的作用"></a>事件过滤器的作用</h3><ul>
<li><strong>拦截和修改事件</strong>：比如，你可以拦截按键事件，修改或阻止某些特定的按键。</li>
<li><strong>监听多个对象的事件</strong>：事件过滤器可以安装到多个对象上，统一处理这些对象的事件。</li>
<li><strong>事件传播控制</strong>：通过返回 <code>true</code> 或 <code>false</code>，你可以控制事件是否继续传递，或是否被完全阻止。</li>
</ul>
<h3 id="事件过滤器的优缺点"><a href="#事件过滤器的优缺点" class="headerlink" title="事件过滤器的优缺点"></a>事件过滤器的优缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li>可以在不改变目标对象的情况下，灵活地处理事件。</li>
<li>适用于需要跨多个对象进行事件监听或处理的场景。</li>
</ul>
<h3 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h3><p>​	不难猜想到，这个事件过滤器其实是我们事件链条上的一环。再者，在这个链条上，这个事件过滤器的优先级甚至于要高于event函数的，所有的事件都需要先通过这个事件过滤器去进行一次过滤，所有返回true的事件将会被拦截。在经过我们的事件过滤器后，如果我们还想要在本层次中去进行对应的事件处理，我们需要使得这些个事件在最后在这个层级中能够返回false被event函数所接收。</p>
<p>​	对于一个经过事件处理器的事件，如果最后这个事件过滤器对这个事件的处理返回值是true，就代表这个事件被拦截了，如果返回false，那么这个事件就会被传递到对应的这个层次上的event中去进行后续的处理。当然，我们在这里还可以进行进一步的过滤，就比如再次的去调用另一个事件过滤器，但是总体来说处理逻辑都是一样的。</p>
<p>​	现在就可以对于这个节点的层次逻辑进行进一步的填充，所有的事件，都会先经过当前节点的事件过滤器去进行识别，当经过这个事件过滤器并且返回值是false后，这个事件将会被分发到event中去进行我们上面已经分析过的处理，这俩者之间没有一个紧密的联系。俩者之间的耦合度相当低使得我们可以只专注于当前事件过滤器的设计。</p>
<p>​	需要注意一点的是，事件过滤器的安装需要一个事件过滤器指针，这个指针可以有多种情况，最简单的就是去定义一个通用的事件过滤器，所有的都可以使用这个事件过滤器，如果我们是在一个类中去进行了我们事件过滤器函数的重写。如果我们想要安装这个重写的事件过滤器，需要注意的是，我们只需要去在对应的install函数中去传入这个对象的指针即可。</p>
<blockquote>
<p>事需缓图，欲速不达也。</p>
<p>得找个时间去练练手，今天就先到这，溜溜球。</p>
</blockquote>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern SQL</title>
    <url>/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL-/</url>
    <content><![CDATA[<h1 id="Modern-SQL"><a href="#Modern-SQL" class="headerlink" title="Modern SQL"></a>Modern SQL</h1><h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL-/image-20250217233059625.png" alt="image-20250217233059625"></p>
<span id="more"></span>	

<p>​	需要注意的是，一个数据库系统中是存在着多个组件的，比较简单的理解的话。一个系统首先需要包括几个用来进行操作的语言。</p>
<p>其中包括的几种语言有:**数据操作语言(DML)，数据定义语言(DDL)，数据控制语言(DCL)**。</p>
<p>​	对于这三种语言，我们在这里进行一个相对简单的接触即可。</p>
<ul>
<li><strong>数据操作语言（DML）</strong>：用于操作数据库中的数据。常见的DML命令包括<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>，这些命令帮助我们从数据库中查询数据、插入新数据、修改现有数据或删除数据。</li>
<li><strong>数据定义语言（DDL）</strong>：用于定义和管理数据库中的结构，例如表、视图、索引等。常见的DDL命令包括<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>等，用来创建、修改或删除数据库的结构。</li>
<li><strong>数据控制语言（DCL）</strong>：用于控制数据库的访问权限。常见的DCL命令有<code>GRANT</code>（授予权限）和<code>REVOKE</code>（撤销权限），它们允许数据库管理员控制哪些用户可以访问哪些数据。</li>
</ul>
<p>​	</p>
<hr>
<p>​	粗略来看，DML就是对于数据库中存在的数据可以进行的一些查询，修改等操作。是直接作用于数据层面的。而DDL是对于数据库中数据的架构的规划语言，是作用于结构层面的。而DCL直观来看其实就是对于来自不同请求的权限控制。</p>
<blockquote>
<p>加下来将会进入一些聚合操作，查询操作等的了解</p>
</blockquote>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>​	在SQL中，存在着一些相对特殊的函数，这些函数以一系列的数据为输入，然后输出一个值。这些函数一般被称为聚合函数。</p>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL-/image-20250218000909195.png" alt="image-20250218000909195"></p>
<p>​	上图中就是一些比较常用的聚合函数，函数的功能也比较简单，这里就没必要进行深入，等之后进入一些更加复杂的应用场景时可以来回顾一下。简单了解下这几个函数的功能即可。</p>
<ul>
<li>AVL(col)根据输入的值去计算平均值后返回，需要输入值能够被计算。</li>
<li>MIN(col)根据输入的值去查找最小值并返回该值</li>
<li>MAX(col)根据输入的值去查找最大值并返回该值</li>
<li>SUM(col)根据输入的值去计算总和并返回</li>
<li>COUNT(col)根据输入的值去返回这些值中非空值的个数</li>
</ul>
<blockquote>
<p>在进入下一步之前，我们默认你已经了解最基本的数据库查询操作，即一个由selete子句，from子句，where子句组成的基本查询操作，如果不知道，还是先回去看书吧。</p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote>
<p>​	聚合函数还存在一些使用上的限制，或者说，一些特性需要了解</p>
</blockquote>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL-/image-20250220192249828.png" alt="image-20250220192249828"></p>
<h4 id="使用位置"><a href="#使用位置" class="headerlink" title="使用位置"></a>使用位置</h4><p>​	聚合函数只能在select子句中进行使用，并且使用聚合函数后select子句输出的内容将会是对应的聚合函数功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(1+1+1) AS cnt </span><br><span class="line">FROM student </span><br><span class="line">WHERE login LIKE &#x27;%@cs&#x27;</span><br></pre></td></tr></table></figure>

<p>​	额外注意一下，这里的as关键字起到一个名称替换的效果。这里的like关键字起到字符串匹配的一个效果，具体的等下再讲。</p>
<h4 id="去除重复项"><a href="#去除重复项" class="headerlink" title="去除重复项"></a>去除重复项</h4><p>​	部分聚合函数也可以使用关键字<strong>distinct</strong>来去除重复项</p>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL-/image-20250220193434153.png" alt="image-20250220193434153"></p>
<p>​	使用方式也很简单，就是在对于的聚合函数里面加上<strong>distinct</strong>关键字，如上图中的使用。</p>
<p>​	额外需要注意的是，正如上图中指出，不是所有的函数都支持<strong>distinct</strong>关键字的，毕竟有时候distinct关键字的含义与一些聚合函数的功能之间存在一些歧义，应该是在设计上就进行了这些的摒弃。</p>
<h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><p>​	聚合函数中使用的参数也存在着一些限制。官方来说</p>
<p>​	出现在<strong>select子句</strong>中但没有被聚合的属性只能是出现在<strong>group by子句</strong>中的属性。换句话说，任何没有出现在<strong>group by子句</strong>中的属性如果出现在<strong>select子句</strong>中，那么它只能作为聚合函数的参数作为使用。</p>
<p>​	这句话应该配合实例来辅助理解。</p>
<p>​	<img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL-/image-20250223174226964.png" alt="image-20250223174226964"></p>
<p>​	</p>
<p>​	首先，我们需要明白一个<strong>group by</strong>子句所能带来的作用。通过一个group子句，数据库可以吧对应的表根据子句中的元素列出为多组，其中每一组都是对应的子句中出现的元素。</p>
<p>​	然后我们来看到select子句所能带来的作用，该子句能够将对应的表中的数据进行操作来输出一个新表。那么，我们前面已经通过group by子句将这些元组分为若干个组了，此时我们如果想要加上一个没有任何限制的元素在select子句中，那会出现什么。很自然想到的是，这个将会出现一系列的元素没有一个对应的元组给它匹配到，而这个是我们所不想看到的。这也是这么一种设计的原因。</p>
<p>​	接下来我们再来看到这种设计中使用聚合函数将会出现的结果。当我们进行了group by子句进行分组后，我们如果想要正确的输出一个表，我们需要为每个分组后的新元组都提供对于的元素进行构建。也就是说，我们的select操作应该是基于分组后的各个子元组集合的。这也是为什么对于那些个没有出现在group by子句中的元素需要我们去进行聚合函数的原因，只有通过聚合，我们才能通过一组值来输出一个值用于一个元组的构建。</p>
<p>​	也就是说，还是跟前面一样，我们的select子句中就是最后的新表中的目标元素的集合。一个查询语句中如果出现了group by子句，那么对应的select子句中没有使用聚合函数的元素就是我们分组的依据，其他的使用聚合函数的则是我们目标新组中需要的元素。</p>
<p>我很喜欢GPT对于我这段话总结出来的几句话。</p>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL-/image-20250223175701845.png" alt="image-20250223175701845"></p>
<hr>
<h3 id="Having子句"><a href="#Having子句" class="headerlink" title="Having子句"></a>Having子句</h3><h4 id="生效时机"><a href="#生效时机" class="headerlink" title="生效时机"></a>生效时机</h4><p>​	接下来看到一个与聚合函数具有较强关联的一个语句，having子句。这个子句与where子句有点相像。都是对于已有元组的一种条件筛选。</p>
<p>​	在之前的学习中，我们了解到where子句其实是对于整个查询操作中原始表的一个过滤。这个过滤操作是紧跟在from子句之后的。在这个过滤之后才会去进行接下来的一系列查询操作子句的进行。那么，这里就存在一个问题了，由于这个where语句的时机，所以我们其实是无法使用这个where子句去进行分组后的过滤的。毕竟，这个group by子句发生的时机是位于where子句之后的。</p>
<p>​	但是对于这种分组后过滤的操作，这种操作映射到现实生活中是非常常见的。就比如，你希望知道一个初中学校7年级中平均分最高的班级。那么此时只有where子句是无法满足我们的要求的。此时设计者就引入了一个新的子句，having子句。这个子句的功能与where子句基本相同，区分他俩的主要特征就是俩者发生的时机。正如前文所说，一个having子句能够对于分组后的结果在进行筛选。不难推测having子句的发生时机就是位于group by子句之后。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>假设你有一个销售表 <code>sales</code>，包含 <code>region</code>（地区）和 <code>sales_amount</code>（销售额）两列。如果你想按 <code>region</code> 分组并计算每个地区的总销售额，同时只返回总销售额大于 1000 的地区，查询可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT region, SUM(sales_amount) AS total_sales</span><br><span class="line">FROM sales</span><br><span class="line">GROUP BY region</span><br><span class="line">HAVING SUM(sales_amount) &gt; 1000;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>GROUP BY region</code> 将数据按地区分组。</li>
<li><code>SUM(sales_amount)</code> 计算每个地区的总销售额。</li>
<li><code>HAVING SUM(sales_amount) &gt; 1000</code> 对每个分组的总销售额进行筛选，只保留销售额大于 1000 的地区。</li>
</ul>
<h4 id="简单归纳"><a href="#简单归纳" class="headerlink" title="简单归纳"></a>简单归纳</h4><p><strong><code>HAVING</code> 子句</strong>：用来过滤 <strong>分组后的结果</strong>（在 <code>GROUP BY</code> 后），它针对分组后的数据进行筛选。换句话说，<code>HAVING</code> 过滤的是每个分组的聚合结果。</p>
<p>​	在实际应用中，我们可以看到事实上基本全部的having子句中都是聚合函数的一些条件限制，这个其实很好理解。毕竟前面我们已经说过了having子句就是用来进行分组后的条件筛选的，而分组后的分组依赖项本来就不应该被用来进行筛选，我们应该筛选的是每个分组的对应属性，体现在查询语句中的就是对应的select子句中使用聚合函数中的系列项。因此，在Having子句中看到这些个聚合函数也就不奇怪，或者说，理所应当了。</p>
<p>​	特别需要注意一点，对于having子句来说，其的执行顺序是位于select子句之后的。我们可以看到在上面的示例中我们在select子句中去对于sales_amount进行了一个as别名的替换。但是我们在having子句中没有进行使用，这个其实也很好理解。毕竟这个其实就是对于执行顺序的一个应用。此时的别名对于子句还是不可见的，因此自然无法使用。</p>
<p>​	接下来贴一个查询语句中各个语句的执行顺序图</p>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL-/image-20250223203933254.png" alt="image-20250223203933254"></p>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL-/image-20250223203948918.png" alt="image-20250223203948918"></p>
<p><img src="/2025/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/1.0-modernSQL-/image-20250223204022012.png" alt="image-20250223204022012"></p>
<p>未完待续，由于篇幅过长，分割放送，下一部分看字符串操作。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern SQL-NESTED</title>
    <url>/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.2-modernSQL(nested)/</url>
    <content><![CDATA[<h1 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h1><p>​	有一说一，modernSQL的内容是真的多，甚至于我都不想继续了，不过这些其实都还无所谓，毕竟现在也还只是停留在理论阶段，还没有开始真正的上手。</p>
<p>​	在之前我们接触到的都是一些单个查询语句的情况，但是有时候这种单层的结构不能满足我们的需求。自然而然，多层也就是嵌套查询也就出现了。这种查询方式其实很好理解。就是将一个查询语句的输出作为另外一个查询语句的一个子句的输入。在格式上表现出来的其实就是一个查询中包含着另外的查询。通常情况下，这种架构下的查询语句很难优化。而且一般来说，这种嵌套查询，可以出现在任何一个子句中，只要你这样做存在着抽象价值。</p>
<span id="more"></span>

<h2 id="where子句嵌套"><a href="#where子句嵌套" class="headerlink" title="where子句嵌套"></a>where子句嵌套</h2><p>简单来看一个小demo</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.2-modernSQL(nested)/image-20250224170141170.png" alt="image-20250224170141170"></p>
<p>​	这个并不是一个完整的嵌套查询语句。抽象来看现在这个查询语句其实存在了一个缺陷，就是你无法抽象出来你这里的父查询语句要怎么使用这个子查询语句的输出，这时就需要一些额外的关键字的使用来解决这个问题。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.2-modernSQL(nested)/image-20250224171132491.png" alt="image-20250224171132491"></p>
<p>​	你提到的这个问题非常经典，正是嵌套查询的核心挑战之一。在 SQL 中，嵌套查询的出现通常是为了处理一些复杂的需求，比如筛选符合条件的数据、关联不同的表等。但是，正如你说的，这种查询方式有时难以优化，且存在一些模糊的地方，比如如何将子查询的输出与父查询关联起来。</p>
<h3 id="如何将子查询与父查询结合"><a href="#如何将子查询与父查询结合" class="headerlink" title="如何将子查询与父查询结合"></a>如何将子查询与父查询结合</h3><p>为了将子查询的结果作为父查询的输入，确实需要一些关键字，主要有以下几种常见的方式：</p>
<h4 id="1-IN-关键字"><a href="#1-IN-关键字" class="headerlink" title="1. IN 关键字"></a>1. <strong><code>IN</code> 关键字</strong></h4><p><code>IN</code> 关键字可以将子查询的结果集作为父查询条件的一部分。</p>
<ul>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="keyword">IN</span> (<span class="keyword">SELECT</span> sid <span class="keyword">FROM</span> enrolled <span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这里，子查询 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT sid FROM enrolled WHERE cid = &#x27;15-445&#x27;</span><br></pre></td></tr></table></figure>

<p> 会返回一组 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sid</span><br></pre></td></tr></table></figure>

<p>，然后父查询 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name FROM student</span><br></pre></td></tr></table></figure>

<p> 会使用 <strong>IN</strong>关键字，筛选出 <strong>sid</strong>在这组返回结果中的学生名字。</p>
</li>
</ul>
<h4 id="2-EXISTS-关键字"><a href="#2-EXISTS-关键字" class="headerlink" title="2. EXISTS 关键字"></a>2. <strong><code>EXISTS</code> 关键字</strong></h4><p><code>EXISTS</code> 用来测试子查询是否返回任何记录。如果返回了记录，<code>EXISTS</code> 就会返回 <code>TRUE</code>，否则返回 <code>FALSE</code>。通常用在<strong>子查询存在与否的判断</strong>上。</p>
<ul>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> enrolled e <span class="keyword">WHERE</span> e.sid <span class="operator">=</span> s.sid <span class="keyword">AND</span> e.cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这里，<strong>EXISTS</strong>子查询会检查是否存在与 <strong>student</strong> 表中 <strong>sid</strong>匹配的记录，并且这些记录的 <strong>cid</strong>是 ‘15-445’。如果存在这样一行，父查询就会返回该学生的名字。</p>
</li>
</ul>
<h4 id="3-ANY-SOME-关键字"><a href="#3-ANY-SOME-关键字" class="headerlink" title="3. ANY &#x2F; SOME 关键字"></a>3. <strong><code>ANY</code> &#x2F; <code>SOME</code> 关键字</strong></h4><p><code>ANY</code> 和 <code>SOME</code> 都是用来比较父查询的某个值与子查询结果集中的任意一个值。如果与子查询的结果中的任意一个值符合条件，父查询会返回相应的记录。</p>
<ul>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="keyword">ANY</span> (<span class="keyword">SELECT</span> sid <span class="keyword">FROM</span> enrolled <span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这里，ANY检查 student表中的 sid是否与子查询 SELECT sid FROM enrolled WHERE cid &#x3D; ‘15-445’的结果集中的任意一个 sid匹配。</p>
</li>
</ul>
<h4 id="4-ALL-关键字"><a href="#4-ALL-关键字" class="headerlink" title="4. ALL 关键字"></a>4. <strong><code>ALL</code> 关键字</strong></h4><p><code>ALL</code> 用来比较父查询的某个值与子查询结果集中的所有值。如果父查询的值与子查询结果集中的所有值都符合条件，才会返回结果。</p>
<ul>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">&gt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> sid <span class="keyword">FROM</span> enrolled <span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这个查询会返回 sid 大于子查询中所有 sid的学生。</p>
</li>
</ul>
<h4 id="5-JOIN-子查询"><a href="#5-JOIN-子查询" class="headerlink" title="5. JOIN 子查询"></a>5. <strong><code>JOIN</code> 子查询</strong></h4><p>有时可以将子查询与 <code>JOIN</code> 结合，利用联接来简化查询结构，尤其是涉及到多表查询时。</p>
<ul>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.name</span><br><span class="line"><span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">JOIN</span> enrolled e <span class="keyword">ON</span> s.sid <span class="operator">=</span> e.sid</span><br><span class="line"><span class="keyword">WHERE</span> e.cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这种方式将子查询转化为一个连接操作，直接从 student和 enrolled表中联接出需要的数据。这里，e.cid &#x3D; ‘15-445’即是查询条件。</p>
</li>
</ul>
<p>​	以上几个就是GPT给出的几个关键字的小demo，由于我不想再去对这几个进行深入，所以暂时就先这样。</p>
<h2 id="from子句嵌套"><a href="#from子句嵌套" class="headerlink" title="from子句嵌套"></a>from子句嵌套</h2><p>​	简单来看几个子句的嵌套，其实可以发现一个现象，就是这种嵌套其实是基于一个接口规范来实现的。在我看来，部分子句的输入格式应该是关系，或者说元组的集合。那么，当我们查询语句的输出是一个关系时，那是否意味着我们能够使用这些个查询语句的输出作为另一个查询语句子句的输入。这里就是这样，from子句决定的是我们整个查询语句接下来所要操作的表。而一个查询语句的输出也正是一个规范格式的表。</p>
<p>​	最直观的一个，我们直接将一个查询子句放于from子句中，这在逻辑上是一个成立的，就比如：我从xx中找出了一些人，我再在这些人当中筛选出一些人之类的。</p>
<p>​	来看一个小demo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT d.department_name, e.employee_count</span><br><span class="line">FROM departments d</span><br><span class="line">JOIN (</span><br><span class="line">    SELECT department_id, COUNT(*) AS employee_count</span><br><span class="line">    FROM employees</span><br><span class="line">    GROUP BY department_id</span><br><span class="line">) e ON d.department_id = e.department_id;</span><br></pre></td></tr></table></figure>

<p>​	这里需要注意下join关键字，在这里先不考虑join关键字的深入用法。简单来说一下，join关键字就是将俩侧的表合并为一个表，至于更多的规则和限制，之后有遇到再说吧。</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select max(tot_salary)</span><br><span class="line">from (select dept_name, sum(salary)</span><br><span class="line">	  from instructor</span><br><span class="line">	  group by dept_name) as depe_total(dept_name,tot_salary);</span><br></pre></td></tr></table></figure>

<p>​	可以看到这里的demo相对于上面那个存在了一个最大的区别，就是在子查询语句之后加上了一个更名关键字as，通过这个更名关键字，我们能够对于这个子查询产生的关系进行命名。这是一种规定，也很好理解，毕竟单纯的查询语句出来的关系其实是匿名的，通过这种更名操作，能够给后续的一些操作提供便利，毕竟在一些复杂的架构中是可能使用到这种子查询产生的表的。</p>
<p>​	需要注意的是，在一些SQL实现(MySQL等)要求这种子查询都必须使用as关键字来进行子查询产生的关系的更名，即使这个关系没有被引用。还有一些实现(Oracle等)允许进行更名，但是不允许在这种更名语句中进行再更名，即对于select中的属性进行隐式的更名，就比如上面那个demo一般。因此，如果实在Oracle中，需要将select子句替换为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select dept_name, sum(salary) as tot_salary</span><br></pre></td></tr></table></figure>

<p>并将 <code>as depe_total(dept_name,tot_salary)</code>替换为<code>as depe_total</code></p>
<h2 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h2><p>​	标量子查询的原理我们前面其实已经出现过了，就是通过输入和输出接口的统一来实现对于一个字查询语句的任意插入。</p>
<p>​	官方点来说：SQL允许子查询出现在返回单个值的表达式能够出现的任何地方，只要该子查询只放返回一个包含单个属性的元组，这种子查询就是<strong>标量子查询</strong>。</p>
<p>​	这个不难，简单看一个demo过了就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select dept_name,</span><br><span class="line">	(select count(*)</span><br><span class="line">	 from instructor</span><br><span class="line">	  where department.dept_name=instructor.dept_name)</span><br><span class="line">	 as num_instructors</span><br><span class="line">	from department;</span><br></pre></td></tr></table></figure>



<h2 id="不带from子句的标量"><a href="#不带from子句的标量" class="headerlink" title="不带from子句的标量"></a>不带from子句的标量</h2><p>​	在一些时候，我们需要对于数据库的一些数据计算后将这些数据用于一定的算数运算，有些时候，这种算数运算不需要再额外去指定from子句作为输入，就比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(select count(*)from teachers)/(select count(*)from instructor);</span><br></pre></td></tr></table></figure>

<p>​	这是使用俩个子句来组成的另一个运算语句，在部分DBMS中，这是合法的，但是更多时候这会使得DBMS系统报错无法计算，因为这个语句缺少from语句。此时数据库系统就给我们提供了一种预定义的关系来使用，这种关系时虚拟的，但是可以在from中去使用去屏蔽掉报错，但是你很少能从中去获取一些具体有效的信息，这个关系就是 dual。</p>
<p>​	此时上面那个语句可以改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(select count(*)from teachers)/(select count(*)from instructor)</span><br><span class="line">	from dual;</span><br></pre></td></tr></table></figure>

<p>​	当然，这种显式指定from语句的规则可能不是每个DBMS都要求的，具体参考对于的使用手册即可。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern SQL-Function</title>
    <url>/2025/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/1.3-Modern%20SQL(function)/</url>
    <content><![CDATA[<h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><p>​	接下来看一些DBMS中存在的一些窗口函数。</p>
<p>![image-20250225092345760](.&#x2F;1.3-Modern SQL(function)&#x2F;image-20250225092345760.png)</p>
<p>​	上面那句话其实就是说一个窗口函数是对于输出序列中的一个特定窗口范围内的数据进行操作的函数。这个函数于聚合函数相似，都是对于一系列的元组执行操作的函数，但是这个函数于聚合函数最大的不同就是窗口函数并不会对输出结果进行合并，而是每个输入元组都能获得一个窗口函数的一个输出属性。</p>
<p>​	没意思，润</p>
<span id="more"></span>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern SQL-Modify</title>
    <url>/2025/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/1.4-Modern%20SQL(modify)/</url>
    <content><![CDATA[<h1 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h1><p>​	在此前的几个文档中，我们都专注于对于数据库数据的抽取，接下来可以进入对于数据库数据的增删改了。这也基本是modernSQL的尾声了。</p>
<span id="more"></span>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>​	删除的关键字是delete关键字。这个关键字的使用与select使用的方式十分相似。需要注意的是，我们对于数据库数据的删除的基本单位是元组，我们不能对于一个元组中的一个或多个特定属性进行删除。</p>
<p>​	这样规定的原因想必也十分明显，毕竟如果只对于部分属性进行删除那么首先其在数据的管理上就增加了难度，并且这还带来一系列的麻烦。</p>
<p>​	删除语句的格式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> r</span><br><span class="line"><span class="keyword">where</span> P;</span><br></pre></td></tr></table></figure>

<p>​	这个格式的含义是对于r关系中的满足P谓词的所有元组进行删除。至于from与where子句之间的进阶使用，跟前面提到过的并无不同，这里就不再进行赘诉，接下来看一个小demo就过了。</p>
<p>删除在Waston大楼里工作的所有教师元组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="keyword">in</span>( <span class="keyword">select</span> dept_name</span><br><span class="line">					<span class="keyword">from</span> department</span><br><span class="line">					<span class="keyword">where</span> building <span class="operator">=</span> <span class="string">&#x27;Waston&#x27;</span></span><br><span class="line">					);</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入的关键字是 <code>INSERT</code> 关键字。这个关键字的使用与 <code>SELECT</code> 使用的方式十分相似。需要注意的是，插入操作的基本单位是元组，我们不能仅插入一个元组中的一个或多个特定属性（列），而必须为所有列提供对应的值。</p>
<p>这样规定的原因也十分明显，毕竟如果只插入部分属性，那么我们就无法保证数据的完整性和一致性，且这样会导致一些不必要的管理麻烦。</p>
<p><strong>插入语句的格式</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 (列<span class="number">1</span>, 列<span class="number">2</span>, ..., 列N)</span><br><span class="line"><span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ..., 值N);</span><br></pre></td></tr></table></figure>

<p>这个格式的含义是向 <code>表名</code> 表中插入一条新的记录，其中每个列的值由 <code>VALUES</code> 子句提供。列名和对应的值按顺序匹配，确保每一列都有相应的值。至于列和值的详细使用，与前面提到的 <code>SELECT</code> 子句并无不同，这里就不再赘述。接下来看一个简单的插入示例。</p>
<p><strong>插入一条新的教师记录</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> instructor (instructor_id, name, dept_name, salary)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1001</span>, <span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;Computer Science&#x27;</span>, <span class="number">85000</span>);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们向 <code>instructor</code> 表中插入一条新记录，包含了 <code>instructor_id</code>、<code>name</code>、<code>dept_name</code> 和 <code>salary</code> 四个属性的值。</p>
<hr>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>更新的关键字是 <code>UPDATE</code> 关键字。这个关键字的使用与 <code>SELECT</code> 和 <code>DELETE</code> 使用的方式十分相似。需要注意的是，更新操作的基本单位是元组，也就是说，我们对一个元组中的某些属性进行更新，而不是对单个属性进行删除或插入。</p>
<p>这样规定的原因同样十分明显，毕竟如果仅更新一个属性而不明确其它属性的状态，可能会导致数据的不一致或丢失。因此，更新操作通常涉及某些特定条件的筛选。</p>
<p><strong>更新语句的格式</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名</span><br><span class="line"><span class="keyword">SET</span> 列<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>, 列<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span>, ..., 列N <span class="operator">=</span> 值N</span><br><span class="line"><span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure>

<p>这个格式的含义是更新 <code>表名</code> 表中满足 <code>WHERE</code> 条件的所有记录，将它们的某些列的值更新为新值。<code>SET</code> 子句用于指定更新的列及其新值，<code>WHERE</code> 子句用于筛选需要更新的记录。需要注意的是，<code>WHERE</code> 子句的使用至关重要，因为如果没有指定条件，表中所有记录都会被更新。</p>
<p><strong>更新在 Waston 大楼的所有教师的薪水</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> instructor</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHERE</span> dept_name <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> dept_name</span><br><span class="line">    <span class="keyword">FROM</span> department</span><br><span class="line">    <span class="keyword">WHERE</span> building <span class="operator">=</span> <span class="string">&#x27;Waston&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们将所有在 ‘Waston’ 大楼工作的教师的薪水增加 10%。子查询 <code>(SELECT dept_name FROM department WHERE building = &#39;Waston&#39;)</code> 返回所有在 ‘Waston’ 大楼工作的系的名称，然后主查询更新这些系的所有教师薪水。</p>
<p>​	简单过一遍语法，得开始去实践一下了。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern SQL-STRING</title>
    <url>/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>​	在SQL中，自然也存在字符串这种元素。一般来说，SQL使用单引号**’ ‘**来标识这是一个字符串，同时在SQL标准中，数据库对于字符串大小写应该是一个敏感的状态。但是，很多数据库系统中，包括但不限于MySQL和SQL Server中，对于这些个标准都是存在一些选择的。例如在MySQL中，其对于字符串的大小写就是不敏感的，当然，你可以在MySQL中去使用对于的标准设置语句去进行调整。不过种种这些，都是一些小玩意，在使用具体的数据库时去进行适当的调整即可，没必要去进行一个个的深入了解。</p>
<span id="more"></span>

<h2 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h2><p>​	SQL允许在字符串上使用多种函数。包括但不限于连接字符串(“||”),提取子串，计算字符串长度，大小写转换等函数。但是这些都只是一些实例的使用，具体的参考自己的数据库系统使用就行，不行就去问ai。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224074520213.png" alt="image-20250224074520213"></p>
<p>​	对于字符串函数，使用起来其实跟普通语言的函数之间很相似，都存在着一定的输入参数，并默认这些字符串函数都返回一个字符串提供后续的操作。例如上图中的SUBSTRING和UPPER函数。</p>
<p>​	可以注意到的是，这些函数在上图那个示例中都出现了不同的使用语句位置。不难想象，还可以存在多种使用位置。换句话说，字符串函数的使用位置与语句之间是弱耦合的，但是与它使用的数据类型是强耦合的，基本上必须存在着为字符的参数。所以理论上，所有可以出现字符串的地方，系列字符函数都能被使用。</p>
<p>​	</p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>​	在之前的几个文档中，我们其实不难看到有着like关键字的出现，这里对于这个关键字进行进一步的分析。</p>
<p>​	like关键字是用来实现模式匹配的，通过like关键字，我们能够实现对于所需要的字符串的一定程度上的一些限制。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224073610584.png" alt="image-20250224073610584"></p>
<p>​	正如上图中所说，’%’能够匹配任何子串(不限长度和内容，包括空串)，’_’只能够匹配任意一个字符，通过对于这俩个字符的排列组合，我们能够实现很大程度上的对于匹配字符串的限制。</p>
<p>​	这里需要特别注意一下like关键字的使用环境。理论上说like可以出现在任意一个子句中，毕竟它并只是与字符串绑定，可以粗略理解为like就像其他字符串函数一样，输入一个字符串并返回一个字符串以供后续的系列操作。但是在实际中，like的使用位置一般是位于where子句中的，毕竟相对来说，这个位置上的like具有更强的逻辑抽象。</p>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>​	在DBMS中，还存在着一系列的方法能够进行一些输出的重定向，就比如将输出重定向到一个新表中去生成一个新表。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224082830887.png" alt="image-20250224082830887"></p>
<p>​	上图中的demo其实就已经简单的列出了这个重定向的一些特性。</p>
<p>​	一个重定向需要使用一些输出作为输入，比如，这里的使用了select语句中的输出作为一个输入，并将这个作为输入去作为后续的INTO的输入。</p>
<p>​	一个重定向的输入存在几个特点。重定向的表必须没有被彻底的限定，必须允许能够被插入新的属性并能够被插入新的元组。在重定向后，这个输入将被插入重定向的表中。上图中其实就是将一个属性重定向到新表中的demo。接下来看一个插入新元组的方法。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224084043297.png" alt="image-20250224084043297"></p>
<p>​	额外需要注意的是，当我们重定向的输入是一系列元组时，我们这些输入元组必须与目标表的元组组成的一致，这个也能够理解。毕竟如果你的插入元组与目标元组组成不一致，那么这就违背了数据库对于数据组织的底层逻辑，这是我们所不想看到的。</p>
<h3 id="输出排序"><a href="#输出排序" class="headerlink" title="输出排序"></a>输出排序</h3><p>​	在实际应用中，很多时候我们需要将输出的数据按照一定的次序进行排列，这个排列的时机有很多，这里考虑的是DBMS输出表数据的时候。这时候我们可以通过一个新的order by子句来进行一定程度上的排序。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224085039262.png" alt="image-20250224085039262"></p>
<p>​	</p>
<p>​	很多元素都可以使用order by进行升序和降序的排序。包括但不限于整形，浮点型和部分的字符型等(字典序排序)。</p>
<p>​	在缺省情况下，order by子句是使用升序排序的。要说明order by子句中的排列顺序，可以使用des表示降序，或者使用asc使用升序。同时，在上面那个demo中没有体现的是，一个order by子句中可以存在多个用于排序的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from instructor</span><br><span class="line">order by salary desc, name asc</span><br></pre></td></tr></table></figure>

<p>​	该demo中的查询语句的含义是:从instruct表中去输出所有的元组并对于这些元组按照salary降序排列，按照name升序排列。</p>
<p><img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224092105897.png" alt="image-20250224092105897"></p>
<p>​	在一些个order by子句中，我们可以看到一些数字，这些数字其实是一种别名，对应的则是在select子句中出现的第i个元素。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>对于order by的排序，如果此间存在着多个用来排序的元素，那么在这之中存在着一定的排列顺序，就比如上面那个demo，先按照salary属性进行降序排序，再按照name进行升序排列，也就是说，order by子句是按照该子句中属性出现的次序来进行排序的。</li>
<li>对于排序的结果，还是存在那个特殊值(NULL)可能导致的问题。在一般的DBMS中，NULL值一般都被视为一个最小值，但是这个不好说，具体参考各个DBMS的使用手册。</li>
</ul>
<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>​	数据库系统还支持对于输出的一些数量和位置上的一些控制，具体是通过order by子句来实现的。相对来说跟之前的子句使用很相似，简单过一遍即可。</p>
<p>​	<img src="/2025/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/1.1-modernSQL(string)/image-20250224164339216.png" alt="image-20250224164339216"></p>
<p>​	对于这个输出控制关键字，主要存在着俩个功能，第一个是对于输出的数量上面的限制，这个通过在limit之后再加上对应的数字就能够实现对于输出元组数的控制了。</p>
<p>​	额外的，我们还可以在limit子句中去添加另外一个关键字offset来进行输出元组的偏移。通过在这个关键字之后添加上对应的数字，我们能够限定接下来的输出的其实元组位置。</p>
<h5 id="demo"><a href="#demo" class="headerlink" title="demo"></a><strong>demo</strong></h5><ol>
<li><p><strong>限制返回的记录数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">LIMIT 5;</span><br></pre></td></tr></table></figure>

<p>这个查询会返回 <code>employees</code> 表中的前 5 行数据。</p>
</li>
<li><p><strong>与 <code>OFFSET</code> 配合使用，进行分页：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">LIMIT 5 OFFSET 10;</span><br></pre></td></tr></table></figure>

<p>这个查询会跳过前 10 行，返回从第 11 行开始的 5 行记录。<code>OFFSET</code> 表示跳过多少行数据。</p>
</li>
<li><p><strong>限制查询结果，并按特定顺序返回：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">ORDER BY hire_date DESC</span><br><span class="line">LIMIT 3;</span><br></pre></td></tr></table></figure>

<p>这个查询会返回 <code>employees</code> 表中按 <code>hire_date</code> 降序排列的前 3 行记录。</p>
</li>
</ol>
<p>​	需要注意的是，在一些数据库系统中，这个limit关键字被替换为了一些新的关键字，具体参照对应的使用手册即可。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Storage_Files &amp; Pages</title>
    <url>/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/</url>
    <content><![CDATA[<h1 id="储存管理"><a href="#储存管理" class="headerlink" title="储存管理"></a>储存管理</h1><h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a><strong>前情回顾</strong></h2><p>​	接下来，我将跟着15445的进度跳过中间的中级SQL和高级SQL和其他一些对于数据库的优化操作，直接跳到书籍的第三章节中来。正如15445在课程中所说的，这门课程主要是为了让我们了解一个数据库系统到底是什么，而不是了解数据库系统怎么来进行使用。</p>
<span id="more"></span>

<p>​	如下图</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227191240783.png" alt="image-20250227191240783"></p>
<p>​	我其实在学习这个的时候遇到了一个问题，就是我学校的课程内容其实相对于15445来说存在比较大的出入，就比如，学校的课程目标在database system concepts中主要就是第一二部分的内容。但是15445的课程目标则是后面的第三部分的内容，从底层来进行分析一个DBMS。在我看来，你作为一个CSER，在这方面的选择其实不应该犹豫，毕竟相对来说，CMU已经是很多CSER所能接触到的最好的课程了，如果想要拥有一个更好的底子，跟着CMU的课程目标走无疑是更加能够提高个人的能力的，所以，拼命吧，不必要去学校偷懒。</p>
<blockquote>
<p>CSER，Database Start！</p>
</blockquote>
<p>先来看一个图，这个其实15445的课程大纲</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227195226036.png" alt="image-20250227195226036"></p>
<p>​	该图中的左侧是15445整门课程大致的学习章目，此时我们已经进入Storage储存管理部分，右侧的层次架构是整个储存部分的基础管理结构，由下至上逐渐抽象，逐渐的远离硬件结构，在15445中则是从底层逐渐学起，逐渐架构起对于硬件与软件层次的认知。</p>
<h2 id="数据储存"><a href="#数据储存" class="headerlink" title="数据储存"></a>数据储存</h2><p>​	接下来我们来进行对于一个DBMS中数据的底层管理体系进行分析。</p>
<p>​	学过了CSAPP，其实不难知道数据在底层上都应该是储存在磁盘等非易失性储存器的，数据库中最主要的就是那些数据，因此这一点又需要额外重点注意。在这种架构下，DBMS确保了一个数据库的主要储存位置都位于非易失型储存器上。在现代的数据库使用中，由于在性能与损耗之间的平衡，对于需要使用的数据库数据，还是需要从非易失型储存器转移到主存中的，正如操作系统负责部分文件从外存往内存中的加载一样，DBMS负责数据库的数据在易失型和非易失型储存器之间的移动。</p>
<p>​	因此，接下来的学习中，我们的重点将会侧重于如果将一个DB中的数据安全的转移到主存中去，话不多说，启动。</p>
<h3 id="储存架构"><a href="#储存架构" class="headerlink" title="储存架构"></a>储存架构</h3><p>​	接下来看一个老朋友</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227201731393.png" alt="image-20250227201731393"></p>
<p>​	对于这个图中的内存架构，如果学过CSAPP中的储存模型，相似能够很快的理解。</p>
<p>​	这里主要对一些东西重复一下</p>
<ul>
<li>Volatile(易失型储存器):在易失型储存器中，储存器硬件上的内容可以按照字节来进行寻址，但是这种储存器一但断电其上面储存的信息将会在很短的一段时间内小时，不难长时间储存。</li>
<li>Non-Volatile(非易失型储存器):一般来说，非易失型储存器并不能按照上面的通过字节来进行内容的读取，因为它实在是太慢了，使用按字节读取的损耗不能够弥补付出。但是这种储存器在断电后其上的信息仍然能够长时间储存。</li>
</ul>
<p>​	在数据库的内存系统中，我们主要考虑的是在各个硬件架构之后，我们需要怎么去确保在数据的传输过程更安全，更有效率，话不多说，开始。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227202547718.png" alt="image-20250227202547718"></p>
<p>​	在non-volatile中，基本所有情况下对于数据的随机访问都是慢与顺序访问的，这样其实也很好理解，毕竟相对于顺序访问，随机访问通常意味着更多的磁头的移动和读取，这种硬件的移动和读取是我们所不喜欢的，这大大影响了数据读取的效率，那么一个DBMS就必须在这一块之上去下功夫。</p>
<p>​	最简单的一点，为了优化效率，我们在设计DBMS时，我们需要去选择哪些能够使得我们最后在读取&#x2F;写入数据时能够顺序读取&#x2F;写入数据的数据结构或者算法。就比如，我们在需要将主存中的数据写回到外存中时，去选择哪些能够顺序写入外存的储存页的方法，写出同理。</p>
<p>​	例如，在MySQL中，在往磁盘写入数据时，其通常是先将需要写入的数据先给以顺序写入的方式写入到一个缓存池中去，然后通知外界你这块数据已经成功被保存。但是实际上这块数据可能还没有被写入到外存中，只有当触发了缓存池中的写入限制时才会一次性写入到外存中，这次写入可能是随机写入的，但是我们不用对这个进行管理，因为这个是在后台进行的。</p>
<p>​	接下来来看一个美图</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227205144263.png" alt="image-20250227205144263"></p>
<p>​	这个的图学过CSAPP的话，一眼过去基本就能猜测出对应的操作了，这里就不进行再分析了。</p>
<p>​	</p>
<p>​	在DBMS中，上面那个过程对于disk上的内存页的调配很多程度上都是相对于OS独立实现的，那么，为什么呢，为什么要自己造轮子呢？（其实使用C++来写东西的人应该对于这个问题会有一个初步的自己的回答）</p>
<p>​	这一块不会进行分析，时间紧任务重，先赶进度先。在课间中对于这一点进行了这一块的较大篇幅的讲解，感兴趣可以去看一看。</p>
<h3 id="文件储存"><a href="#文件储存" class="headerlink" title="文件储存"></a>文件储存</h3><p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227210340760.png" alt="image-20250227210340760"></p>
<p>​	在DBMS中，对于数据库一般都是以文件的形式储存在disk上的，OS无法解析这些文件，只是知道这些文件的存在。并且，基本上每个DBMS都有自己一套的数据库的储存方法，很多DBMS的数据库文件都是无法互相解析的。部分DBMS例外。</p>
<p>​	需要注意的是，在15445中，其进行学习的储存基础的文件系统是OS的文件系统，对于哪些少数自己实现文件系统的，并不在课程讨论之内。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227211251521.png" alt="image-20250227211251521"></p>
<p>​	一个DBMS中一般会存在一个自己的storage manager用来管理自己的数据库文件，通过对manager进行特定的优化可以看到各个数据库之间的性能差距，但我们这里要学习的是他们的基本共性。</p>
<p>​	对于一个manager，其一般会将文件视为一系列的pages的集合，在文件中，其负责跟踪每个页在该文件中的位置已经跟踪每个页中存在的空闲位置。</p>
<h2 id="PAGES"><a href="#PAGES" class="headerlink" title="PAGES"></a>PAGES</h2><p>​	接下来我们来看到数据库文件的基本储存单位:<strong>pages</strong>。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227212103999.png" alt="image-20250227212103999"></p>
<p>​	对于一个<strong>pages</strong>来说，其内部一般是一系列的block的集合，在每个页中，其中包含了关于这个页中的一些信息，这个就像我们二进制文件中的那些前置信息一样，这些信息一般都是位于页的起始部分的，规定了页的一些基础属性，已经系列页的跳转位置，页内的块索引等等，碰到再说。</p>
<p>​	额外的，每个页拥有，也需要一个唯一且特殊的标识符来进行标识，这个由DBMS来设定和提供。</p>
<p>​	一般来说，在一个页中，该页只会储存一种类型的数据，就比如当储存一个表时，一般只会储存这个表的数据而不会混杂多个表的数据，当是索引页的时候，就不会去储存数据页。这种设计其实在CSAPP中也有一定的出现，优势页很明显，就是这样的设计能够减少页的切换，使得你要读取数据时，一般只需要再一个页内去读取就行，对应与磁头等的物理操作就会减少一些，提高了效率，对应的只是一些越来越廉价的外存的损耗，这是完全可以接受的。</p>
<p>​	同时，这种设计也使得在硬盘在遭受一些极端的外界因素而损毁时，我们能够尽可能的去读取剩余的数据(如果表头数据还在的话)。</p>
<p>有时我们会在页中去储存多余的元数据，这在一定程度上也是为了数据的恢复。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227215004495.png" alt="image-20250227215004495"></p>
<p>​	在计算机层面上，存在着多种pages，最底层的是Hardware Page,这种是最基本的硬件层面上的页，接着是OS Page，这种是OS定义的基本页，通常都是与Hardware Page相挂钩的，以前一般是与其一样的大小，在现在内存廉价后变大了许多，但在本门课中假设OS Pages跟Hardware Page的大小一致为4KB。再之后就是我们的Database Page，这个是建立在OS Pages上的，虽然DBMS不使用OS的文件系统，但是DBMS的文件读取读入，还是通过OS实现的，至于Database Pages的大小，这个每个DBMS一般都有自己的规定，如上右图。  </p>
<p>​	我们这里需要对页的大小的选择进行一下分析，为什么不直接选择最大的页面而是有些选择较小的页面。这里需要考虑一个页的写回，当我们一个页的大小是16KB时，我们对其修改了一些数据后需要对其进行写回，那么此时OS需要做什么，OS需要把整个16KB大小的页面都给写回到disk中，假设我们只对于这个页面修改了1条数据，其在写回时仍需要把这个16KB大小的页面写回，这是十分浪费的，当然，较大的页面大小使得我们在这个页中去查询大量相同的数据时拥有更高的效率，所以我们需要平衡页面大小与查询性能之间的关系。</p>
<p>​	举例，当我们对于数据库操作是读密集型的时候，大页面会具有更大的优势，毕竟你可以在一个页面内去读取更多的数据，再需要时再丢弃这个页读取新页。而对于写密集型的时候，小页面具有更大的优势，因为写回时会浪费的页面大小空间会相对大页来说更少。</p>
<h3 id="储存形式"><a href="#储存形式" class="headerlink" title="储存形式"></a>储存形式</h3><p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227221435425.png" alt="image-20250227221435425"></p>
<p>​	在不同的DBMS中，其对于其自己的数据库文件中的页管理可能是不同的形式的。这里先来对于Heap File Organization来进行讨论，这是最常见的一种DBMS对于数据库文件中的页面管理方法。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227222236459.png" alt="image-20250227222236459"></p>
<p>​	对于堆文件架构的数据库文件来说，其中储存的页是无序的，或者说，其中的数据时按照插入顺序排序的，每个页面都有着自己独立的一个编号，通过这个编号，在需要查找某块数据时，通过数据对于的页编号能够索引到对应的块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Offset = Page# x PageSize;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250227225125034.png" alt="image-20250227225125034"></p>
<p>​	在一个DBMS当中，通常会存在一个特殊的索引页来进行对应数据库文件中的特定页的索引，通过这个索引页，可以索引到对应的页，但是需要注意的是，也只能索引到特定的页，至于对于也里面的数据内容，这不是索引页中需要了解的，是在索引到特定的页之后需要对其进行的解析等的操作。</p>
<p>​	在课程中，还对堆文件中的空闲页空间管理进行了一次demo的演示，在DBMS中，存在着一种能够跟踪储存一个表的系列页的空闲空间的方法。在演示的demo中，我们看到有时候我们往数据库中去插入对于的数据然后去查看插入后的对应的表的空闲空间，可能是与插入前一致的(猜测其实是被缓存了还没有插入，因此，没有触发对应的空闲空间的检测)，但是如果此时使用DBMS自带的更新语句更新再查询，就会发现对应的页空闲空间产生了变化。接着还有当我们从表中去删除数据再去查看对应的空闲空间时，可以看到删除后的空闲空间发生了实时的变化。通过这个可以看到对于的DBMS的空闲页的更新机制。</p>
<p>​	需要注意的是，这里的空闲空间查询机制在一些程度上是相对独立的机制，或者这么说，只要你去查看了对应的表所使用的页的空闲空间，那么它所输出的结果就确实是现在在disk上的空闲空间大小，只是我们空闲空间管理器锁需要具备的基本功能。至于为什么我们插入数据后还是没有变化，想必你也有点头绪，就是因为此时这些插入的数据还是被缓存了，并没有被实时的写入到对应的disk中的文件中，因此此时查看磁盘中的文件空闲空间才会是插入之前的情况。至于删除这种操作后会有区别，想必就是进行了实时的更新了吧，这个应该取决于你DBMS的设计，如果设计的删除和插入一样会被缓存，那么这里的查询也应该会延后更新。不过这都不重要，因为我们已经理解了缓存会带来的空闲查询延后更新的这种影响。</p>
<p>​	</p>
<h3 id="PAGE格式"><a href="#PAGE格式" class="headerlink" title="PAGE格式"></a>PAGE格式</h3><p>​	接下来看到PAGE的格式。众所周知啊，对于底层数据的文件，页，块等的组织，一般都会在对应区域的其实位置附上一些信息用于识别该块内存所有的一些信息。也就是所谓的头部。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250228103902474.png" alt="image-20250228103902474"></p>
<p>​	在页的头部中，包含了这个页的大小和一些杂七杂八的信息，这里就不进行一个个深入了。</p>
<p>​	我们主要的是接下来的内容，一个页中是如何对其中的数据进行组织的，换句话说，一个页中是如何储存其的信息，对应的元组是怎么进行排列的。在接下来的讨论中，可以考虑十分友好的遵守了单一职责原则，在这里面我们暂时只需要考虑文件内部如何组织数据而不必去考虑外部给其带来的影响。</p>
<p>​	</p>
<p>​	接下来看到一个问题:当我们要储存一个元组时，我们应该如何将这些元组放入到这些页面中，当我们想要从一个页中去查找一个元组，我们需要怎么去查找。</p>
<p>​	接下来看一种元组的储存形式</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250228110856551.png" alt="image-20250228110856551"></p>
<p>​	这是一个顺序储存，当我们需要插入元组的时候，分配器会为其分配一个特定的ID并查找空闲区域并进行插入，在只存在插入时这种架构不会存在什么问题，但是想想也是不可能的，最明显的，当你需要进行删除时，会发生什么呢。首先，你需要去将页内的元组的存在有效性被抹除，对应的内存块对于外界来说会是一个空闲的状态。那么，当此时我们需要插入时，由于顺序插入，查询到空闲且合理的位置就进行插入，那么这里就可能导致类似于 <strong>Tuple #1 Tuple #4 Tuple #3</strong>之类的元组顺序，这样的话对于外界来说，索引起来是非常麻烦的。</p>
<p>​	还存在一个问题，在这种内存架构下，如果你的元组大小的长度是一个可变的呢，就比如不同的邮箱通常存在着不同的长度，如果你想要去规定元组的大小为最大的长度，那么这里就会存在一个十分常见且不讨喜的问题。在一定时间的使用后，内存空间将会被严重碎片化，这是我们所不想看到的。</p>
<p>​	在种种这种顺序储存结构存在的缺陷的基础上，出现了另外的一种储存格式：槽页面</p>
<p><strong><code>slotted pages</code></strong></p>
<p>​	接下来看一下一种顺序存储的优化页面，槽页面。</p>
<p><img src="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/2-databaseStorage_Files/image-20250228115641837.png" alt="image-20250228115641837"></p>
<p>​	在槽页面中，出现了额外的一种结构（槽数组）来对页内的元组进行管理。在这种架构下，元组的储存位置与数据进一步的分离了。可以说，这种架构下的槽数组的每个元素与每个元组之间，类似于一种映射的关系。通过槽数组中的数据，可以直接去定位到对应的元组位置，这种分离使得在元组的管理上更加的灵活。</p>
<p>​	对于元组来说，其的添加删除其实还是跟之前很相似，都是查询到一块空闲区域时进行插入，但是这种架构下的元组相较于顺序存储具有更强的变长能力。当插入不同长度的元组时的操作并无不同，猜测在槽数组中，每个元素都包含了一系列元组的信息，其中就包括了对应元组的长度。同时，删除时的操作其实也跟之前很相似，这里是将元组对于的槽数组元素的可用标志位给置否(类似于语言中内存分配器的实现)。其实这种结构下的内存分配，与各个语言中的内存分配器很相似，所以其实没有什么新奇的地方。</p>
<p>​	与内存分配器相同的是，在这种架构下的页结构对于碎片化的空闲空间在一定的时机中也可能触发合并操作，比如可能挪动部分的元组位置来进行合并碎片小块来提供一个大块的操作。总总这些，其实跟内存分配器的思路很相似，这里不再进行赘诉。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>槽页面架构通过引入槽数组，成功地将元组的管理与数据的实际存储位置分离，使得插入、删除操作更加高效，并且具备了更强的可变长度支持。同时，槽数组的设计与内存分配器非常相似，通过标记、合并等方式有效管理内存碎片化问题，提升了存储空间的利用率和系统的整体性能。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>看前须知</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0.0-%E7%9C%8B%E5%89%8D%E9%A1%BB%E7%9F%A5/</url>
    <content><![CDATA[<p>由于一些原因，这里0-12的所有文档的排版都很垃圾<br>实际上就是我懒得再重新排版了，这是我直接从我之前写的文档转换来的<br>重新排版太麻烦了，所以我就摆了，凑活着看吧</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>模式分类</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0-%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0-%E5%88%86%E7%B1%BB/1-1734924258079-2.jpg" alt="1"></p>
<span id="more"></span>
<p>对于设计模式可以根据其用途、特性和目标进行分类，主要分为三大类：<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。此外，还有一些并发模式和架构模式也在特定场景中使用较多。</p>
<h2 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1~创建型模式"></a><strong>1~创建型模式</strong></h2><p>创建型模式主要关注对象的创建方式，目的是隐藏对象创建的复杂性，并提高系统的灵活性和可扩展性。</p>
<h2 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2~结构型模式"></a><strong>2~结构型模式</strong></h2><p>结构型模式主要关注类与对象的组合方式，旨在提高代码的可复用性、灵活性和扩展性。</p>
<h2 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3~行为型模式"></a><strong>3~行为型模式</strong></h2><p>行为型模式关注对象之间的通信与协作，旨在简化复杂的控制流程和对象交互。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>用一个简单的示例来进行面向过程和面向对象的俩种特性之间的区分</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Aspose.Words.0ed437a4-543a-4af4-8349-d84cfd143b73.001.jpeg" alt="Aspose.Words.0ed437a4-543a-4af4-8349-d84cfd143b73.001"></p>
<span id="more"></span>
<p>这是一个经典的问题。将大象装进冰箱里分几步。不难看到，我们可以先把冰箱打开，然后我们把大象放到冰箱里面去，再之后将冰箱关上。这是一个简单的三步流程。在这三步中，我们可以观察到，执行操作的对象是谁，是<strong>我们</strong>。也就是说，这一系列的操作都是由我们去触发的。而这就跟面向过程的核心很接近了。	在面向过程的设计中，我们充当的是一个动作的执行者与一个动作的对象提供者。或者说，我们要做的就是调用一个函数并且为它提供对应的参数。这里的打开冰箱就是我们一个函数调用所需要实现的功能，而<strong>打开</strong>的这个实现是由函数封装的。冰箱这个对象是由我们提供给函数的。从此中我们可以看到，面向对象，是要求调用者明确其调用的功能，和被传递给调用的方法的对象的。</p>
<p>与此同时，我们来从另外一个视角来看这个问题。在这其中，我们如果认为没有人这个个体呢？我们可以把这个过程看做。冰箱打开了自己，大象走进了一个地方，这个地方是一个冰箱，冰箱本身容纳了一个物体，这个物体是一个大象，冰箱本身关闭了。整个过程看下来，我们发现，我们并没有用到一个额外的人物来帮我我们实现这三个步骤。而是仅仅局限于大象和冰箱这俩个对象来实现我们的功能。而这个就是面向对象的一种思想。</p>
<p>在这里我们将大象和冰箱都抽象为一个对象。冰箱拥有打开，关闭，容纳功能，大象拥有被容纳的功能。通过这样，我们实现了对一个对象的设计。在这种设计下，我们只需要知道一个对象所拥有的功能我们就可以实现对应的操作。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-/</url>
    <content><![CDATA[<p>接下来我们进入<strong>组合模式</strong>。</p>
<p>给出<strong>定义</strong>：组合多个对象形成树形结构以表示”部分-整体”的结构层次。组合模式对单个对象(即叶子对象)和组合对象(即树这只鸟容器对象)的使用具有一致性。组合模式又可以称为”部分-整体”模式，属于对象的结构模式，将对象组织到树形结构中去，可以用来描述整体与部分间的关系。</p>
<span id="more"></span>


<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-/1.png" alt="1"></p>
<p>我们先来分析一个组合模式下的UML类图，其实都很简单。在接下来中，我们将会使用树的术语进行分析。</p>
<p>其实组合模式抽象理解起来很简单，就是将一系列具有相似属性的类使用树的数据结构给它管理起来。在这种设计下，我们的UML类图中存在一个抽象基类，这个基类其实就是我们建树中常用的节点类。在这个抽象基类中，包含了一系列类似于树的方法以及在实际中我们这个类所扩展出来的属性。</p>
<p>在这些方法中，为了实现组合模式，其中的关键就是那个自身抽象类的指针。这个指针的作用我们也很熟悉，就是我们建树中常用的那个边。这里我们一般不考虑使用左右孩子的俩个指针设计，毕竟这样更耗费空间，也可能导致我们后续在设计时出现混乱。所以我们使用父亲节点这个在多叉树中每个节点唯一的属性进行连接。</p>
<p>在这个抽象基类的简单派生中，我们可以看到它派生出了俩个子类，其中一个是一个叶子节点类，并没有什么特殊的。另一个是管理节点类。好，这里我们对整颗组合模式将要组成的树进行下分析和分类。在这一整颗树中，我们将最底层的节点(即没有子节点的节点)分类为叶子节点。在叶子节点之上的，统一分类为中间节点，或者说管理节点(因为这些个节点在逻辑上都有着自己的孩子)。在这些个管理节点中，除没有父亲的根节点外，其他的都大致一样。</p>
<p>总的来说，组合模式就是一颗专门用于管理类的树。在这个模式中，每个在这颗树中的节点都有着指针指向它的父亲(当然可能存在设计使得使用孩子指针，不给不太可能就是了)。在这种层次设计下，使得同一层次下的节点往往具有相同或相似的属性，而位于不同分支下的节点，由于深度的加深，各自的属性可能会逐渐的发生差异化，但是总的来说还是会符合整颗树的设计规范的。而且，只要在这颗树中，无论你是位于哪里，只要你遵守了抽象层，也就是抽象节点的接口设计规范，那么所有的节点都可以为外部使用统一的接口进行调用。</p>
<p>对了，既然是一颗树，那么对于这颗树的有效遍历，将会是这颗树无法逃脱的命题，而一个节点值保留其的父节点地址显然是无法实现遍历的。所以这个就需要我们去进行一些额外的设计，在我们的管理节点类中，我们需要去添加一个额外的成员变量来储存我们当前节点所连接的所有的子节点的地址。通过这个成员变量，我们才能够从整颗树的根节点去不断的向下遍历，知道遍历完整颗树。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>接下来进入<strong>桥接模式</strong></p>
<p>首先来看到给出的定义：将抽象部分与它的实现部分分离，使得它们都可以独立的进行扩展变化。</p>
<span id="more"></span>
<p>我们来看到一个简单的例子。我们电脑上常用的绘图软件，我们可以使用其绘制各种各样的图像，矩形，圆型等。如果要我们来设计的话，我们将会把这些图形抽象为一个个类，这些类的具体示例就是我们画布上的具体图形。</p>
<p>在这基础之上，我们还可以为这些个图形指定不同的颜色，就比如黄色，紫色，白色等等。那么我们如果想为我们绘制的图形也加上指定的颜色呢？在底层设计中，我们有多种做法，最简单的就是为每一个图形类都去派生出对应颜色的子类吧，这样当我们要创建一个特定颜色的矩形时，我们只需要去创建对应的对象即可了。但是吧，你应该也能感觉到这个设计上的巨大缺陷，当我们存在11个图形，11个颜色的时候，我们如果要列出所有可能的图像，我们总共需要创建121个类，这个是不可接受的。那么我们就需要一个优化的方法。</p>
<p>这个方法其实在现实生活中也有体现，就比如你在画画的时候，你一般是什么，你一般都是先考虑画什么图形，然后再考虑里面需要填充什么颜色。这个想法中，我们考虑画什么图形的这一步可以抽象为抽象部分，后面的填充颜色可以视为实现部分，毕竟这部分意味着你将会画出一个实际的图形出来。</p>
<p>接下来，我们再将这个想法建模到我们的设计中去。我们前面的做法是通过一个类去完整的标识我们需要的图像的形状，颜色等属性。但是我们这里把它们分离开来，把这些固定了组合的类给他拆分成形状类和颜色类。这就是桥接模式的核心，将一个类中可拆分的部分且不拆分会导致设计复杂的部分给他拆分出来，用前面的术语其实就是将抽象部分与实现部分给他拆分成俩个单独的类。</p>
<p>让我们来看看这样做的好处，在这种设计下，我们的形状类和颜色类都由一个独立的抽象类进行管理。那么我们需要怎么去实现一个具体颜色的矩形的创建呢。这时候就需要我们<strong>桥接模式</strong>的<strong>桥接</strong>俩字提供作用了。我们创建一个具体的实例类，就比如紫色矩形。这个类中应该至少保留着一个形状指针和一个颜色指针。我们前面已经提到，那个抽象部分和实现部分都应该被管理。在实际设计中，其实就是各自隶属于一个抽象类下。在我们的这一个实例类中，这写个部分一般都以一种聚合关系连接，毕竟你想，即使你这些个实例对象不见了，你的矩形属性，颜色属性，这些都应该是还存在的吧。</p>
<p>也就是说，桥接模式的核心，就是把一个复杂的类，甚至于不用说复杂，只要这个类中存在相对联系比较松散的属性，我们可以将这些属性给它分离开来，类中只保存这些类的一个单独实例。且这些类之间通过聚合关系联系。通过这样的设计。类间关系进行了进一步的解耦，当我们需要进行扩展时，我们不再需要对这个类进行一系列的派生。而这样在需要特定的属性类时去创建一个唯一的示例类即可，大大减少了设计的复杂度。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/1.png" alt="1"></p>
<p>上面是一个桥接模式UML类图的举例。</p>
<p>让我们来分析下桥接模式的UML类图，其实在这其中，最关键的其实是其关联关系的几个类。这些个关联关系的类定义了整个桥接模式下的类的基本性质。</p>
<p>在整个桥接模式设计中，各个职责不强关联的类都被分离开来并一般都由一个抽象类进行管理。然后这一系列的抽象类间将会通过组合关系或者聚合关系进行互相通信。这种通信定义了我们最后看到的类的属性，就比如红色的矩形之类。</p>
<p>在桥接模式要表示的一个最后的对象中，一般就是我们这些个关联关系的属性的集合即各个抽象类的单个实例。在这些个抽象类中，能够派生出一系列的子类，但是最后的对象有且只有使用了这些个类的一个。在这里其实可以联想到我们的抽象工厂模式中的一个产品的构建，很相似。不过我们的抽象工厂模式服务的对象是一个产品的构建，其实吧，这里也是一个产品的构建，但是这个产品的构建是由其他相对来说比较大的产品来构建的，也可以看做是抽象工厂模式的产品层者一层的。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>前面我们看完了最后一种创建型模式:原型模式。接下来我们要进入到设计模式的第二大类:<strong>结构性模式</strong>。</p>
<span id="more"></span>
<p>需要注意的是，在创建型模性模式中就不同了，其注重的是侧重于如何将类或对象组合在一起形成更大的结构，以实现系统的高效协作和更好的扩展性。它们主要关注如何组织和组合类或对象，处理不同类之间的关系和交互，使得系统更灵活、可维护。也就是说在这个模式中一个相对重要的原则是<strong>开放封闭原则</strong>。</p>
<p>还有一个也很重要的原则:合成复用原则</p>
<p>来看一下第一个要学的结构性模式：<strong>适配器模式</strong>。</p>
<p>首先来说一下适配器模式起的作用。人如其名，适配器存在的目的就是起到一个适配的作用。在显示生活中，如果我们离开中国大陆，我们需要使用当地的电的话，我们通常需要一个适配器，就比如香港等地，你是无法使用你现有的接口去使用当地的插口的。你需要去购买一个能够接通俩头的适配器去转换电压或者提供插口之类的。</p>
<p>适配器的作用也是如此。就比如我们的程序中有着多个独立的类，当我们想要在一个类中去使用另一个类时，我们会先去考虑我们要使用的这个类有没有接口可以提供别的类使用，有自然就简单，但如果没有呢。没有的话我们有多种做法，最直接的就是去给这个被使用的类添加一个可供目标类使用的接口。但是这违背了开放封闭原则，所以我们需要考虑一些别的方法，这时候适配器模式就出现了。</p>
<p>还是那个问题，只说还是很抽象，上代码。</p>
<p>我们重新来分析下适配器模式下需要的几个层次。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/1.jpeg" alt="1"></p>
<p>在适配器模式中，存在的一个非常核心的概念就是包装，我们期望中的一个适配器是一个能够将想要整合进现有代码的外部类包装成我们能够直接使用现有的统一接口的类。</p>
<p>就比如把，我们在设计中规定了我们所有的渲染函数都必须是draw名，无论你是渲染矩形，圆形还是什么。现在我们想要在现有代码中去引入一个外部已经实现好的类，但是这个类的接口名不是draw，如果我们不包装直接使用，那么我们就需要时刻去注意我们编写的代码，这是很麻烦的。所以，我们考虑使用一层包装将这个外部类包装成跟我们现有的类在外部看起来一样的，我们只举最简单的例子，就比如我们只是包装它的函数名。那么我们就需要在这个适配器类中去构建我们现在的外部库向我们现有代码中兼容的装换原则。在这里可以见到视作是在外部用一个统一的函数名来包装调用我们实际的函数名。</p>
<p>好了，接下来我们来看一下适配器类中我们需要了解的层次。最底层就是我们的源接口，就是我们现在想要引入程序的代码，这个接口是不符合我们用户端当前使用的接口规范的。</p>
<p>在往上就是一个适配器的层次，在这个层次中，其规定了我们的源接口项目标接口转换的方法。这里我们对前面的简单情况进行扩展，我们前面只是说了只用变换名字调用函数的情况。让我们复杂一点，在类的设计中，由于我们期望的设计都应该是遵守设计模式三原则的，所以我们引入的这个类也是一个应该遵守开放封闭原则的类，所以我们的适配方法不应该是去修改我们的源接口中的实现的。</p>
<p>而在一般情况下，我们的这个适配器接收的参数是由用户层提供的，也就是我们装换后的接口提供的，那么，我们想要实现这俩者之间的适配，我们就得考虑我们当前目标层的接口之间与源接口之间需要来进行怎么样的对接。这个其实就是我们的电压适配器中那个物理原理(那个电压转换原理)。而这个就是我们的适配器类中所要注意的核心了，通过一个适配器提供的转换方法，我们将一个用户层接口所能提供的信息给进行一系列的加工，转换成了能够调用出来源接口的一系列信息。然后我们的适配器会去调用我们的源接口，这个就是我们适配器模式的核心。</p>
<p>重新回到我们那个最简单的模式来看一下，假设我们俩段的接口调用都不用传递或处理任何参数，那么我们这里的这个适配器接口将不用处理任何的细节，只需要在现有的封装接口中去调用我们的源接口即可，无需考虑参数间的处理。</p>
<p>然后我们再往上去进行探索，再往上其实就是我们用户接触的接口了。其实这个接口一般在设计中都是有一套接口规范来定义的。就比如你的渲染模块的渲染接口应该是什么名字，应该传递什么参数等等。这个接口是用户是直接调用的接口，直接屏蔽了用户与底层的交互。</p>
<p>最上层就是我们的用户层了，这一层没什么好说的，其实就是根据接口规范去找到对应的接口并进行调用的层次。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/3.jpeg" alt="3"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/4.jpeg" alt="4"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/5.jpeg" alt="5"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/6.jpeg" alt="6"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/7.jpeg" alt="7"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/8.jpeg" alt="8"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/2.jpeg" alt="2"></p>
<p>由于截屏问题，有些代码无法看到，自行脑补</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2024/12/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>​	<em>本文将进行结构性模式的外观模式的分析</em></p>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>​	为子系统中的一组接口提供一个统一的入口。外观模式定义类一个高层系统，使得下层的子系统更加容易使用。在外观模式中，外部与一个子系统的通信可以通过一个统一的外观对象进行。外观模式又叫做门面模式，它是一种对象结构型模式。</p>
</blockquote>
<span id="more"></span>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>​	外观模式跟装饰模式在一些属性上有点类似。从名字上也可以窥见一些东西，所谓装饰和外观，在显示生活中就是一种对于事物进行进一步的修饰。装饰模式是通过关联关系去给现有的事物进行一层修饰去给其添加一些属性。就比如我们穿衣服这个动作给我们添加了衣服这个属性。以此类推，外观模式在生活中的体现就是对现有一层修饰。在外观模式中，我们会对现有的方法进行外包装，让其变得易于使用。</p>
<p>​	先举一个现实生活中的外观模式的例子吧。就比如显示中你如果要去冲一杯茶，你如果是自己沏的话，你就需要经历选茶叶，过一遍茶水，倒茶水等众多步骤，这是由你自己进行的沏茶的这个行为所需要的步骤。而你如果去外面茶馆喝茶，你只需要提出需求，交出对应的费用，让小二给你上茶即可，你就不必去费心费力去沏一杯茶。在设计模式中，外观模式的目的与现实中这个茶馆存在的意义有些类似，就是去方便那些不愿意自己沏茶的人，去给这些想要方便的人提供一个更加简便的获取方式。</p>
<p>​	抽象茶馆的行为，我们可以看到这沏茶的中间步骤每一步都是一个行为，抽象到程序中每个行为就是一个行为类。而茶馆这个东家则是最大的行为类，它负责的就是给我们的用户提供一些接口，在这里就是提供一个茶给我们用户，而且我们顾客不再需要去关注这个背后的步骤到底是什么，到底需要先做哪个后做哪个，我们只需要付出相应的代价，就能够获取我们需要的商品。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>​	我们再对外观模式进行一下总结，外观模式的存在意义就是给现有的一系列复杂的步骤进行一次外部的封装并提供一个简单的接口，用户通过提供一些简单的参数供给可以调用这个接口，通过对这个接口的调用用户可以实现一些复杂的功能但是却不用去关注这些复杂功能的实现</p>
</blockquote>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2024/12/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/6983a8f93a172d723e31bd05cc3ae005.png" alt="img"></p>
<p><strong>简单找了一个UML类图来进行分析，简单但是很好的体现了外观模式下的UML架构</strong></p>
<p>​	可以看到，这里运用了一个抽象基类作为第二层具体构件类的父类，这个的抽象类的作用我们在前面装饰模式中一起分析过了，主要就是起到一个<strong>接口规范</strong>的作用，没什么好说的。</p>
<p>​	接下来看到由接口规范派生出的一系列的子类，可以看到，每一个都具有相对简单，单一的功能，符合了三原则的单一职责原则。主要来看我们下面的这个Computer类。在这个类中，我们可以看到这里使用了一个组合关系来进行该类的创建。从Computer类的成员的属性也可以看出，这个是与当前类的生命周期所挂钩的。</p>
<p>​	其实这里是否要使用组合来创建还是得看具体的设计，不过一般来说使用外观模式的话都是需要使用组合的。毕竟你想，我们使用外观来设计，就代表着这个外观之下的逻辑是相对复杂且精密的。既然这样，我们不应该允许用户能够随意的去访问这些子系统，毕竟这样的随机访问对于整个系统架构来说是存在较大的风险的。总之，注意使用环境，必要时再去使用聚合来构建关系对象。</p>
<p>​	主要来看这个Computer类的start函数，此时我们也可以感觉到一个接口规范的好处了，通过一个接口规范，我们可以保证在这个类图上的所有的具有相似功能的接口都能够保证接口的一致性以简化设计以及理解，不然你这里写个函数名是start那里写个函数名是open，那我还得费劲去了解你的源码，麻烦滴很啊。</p>
<p>​	我们这里就不给出代码示例了，因为这个外观模式确实很简单。我们简单来说一个这里的Computer类的start函数将会是一个怎么样的构造。在这个层次架构中，Computer类是直接与外界用户层所交互的，当外界调用start函数时，我们的期望是一个计算机能够被正确的启动，所以我们的这里的start函数就应该包含所有的应该被启动的硬件的start方法。通过这种包装，我们能够实现对于一个复杂操作的简单化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Computer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;CPU.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;Disk.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;Memory.<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这就是一种可能存在的代码顺序，当然，实际顺序并不重要，重要的是你需要去理解这里为什么需要这个外部类来进行这些操作的封装，以及这些封装的内生逻辑，这些才是外观模式的核心。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>​	外观模式是一个相对简单的结构型设计模式，但是它的使用频率也是相当高的，你可以把它类比为创建型模式中的原型模式，这你就应该知道为什么这么高了吧。</p>
<blockquote>
<p>差不多了，风紧扯呼~~~</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2024/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>运用共享技术有效地支持大量细粒度的对象。其目的是通过共享对象来减少内存的使用，尤其是当系统中有大量相似对象时，享元模式可以帮助减少对象的创建，从而降低系统的内存消耗。</p>
</blockquote>
<p>​	具体来说，享元模式将对象的<strong>共享部分</strong>和<strong>不共享部分</strong>分开，尽可能地将重复的对象共享，而将每个对象的<strong>独立部分</strong>(外部部分)保留在每个实例中。</p>
<span id="more"></span>

<h3 id="关键要素分析"><a href="#关键要素分析" class="headerlink" title="关键要素分析"></a>关键要素分析</h3><h4 id="内部状态与外部状态："><a href="#内部状态与外部状态：" class="headerlink" title="内部状态与外部状态："></a><strong>内部状态与外部状态</strong>：</h4><ul>
<li><h5 id="内部状态（Intrinsic-State）："><a href="#内部状态（Intrinsic-State）：" class="headerlink" title="内部状态（Intrinsic State）："></a><strong>内部状态（Intrinsic State）</strong>：</h5><p>​	可以共享的、不变的部分。例如，字体、颜色、形状等不随对象变化而变化的属性。</p>
</li>
<li><h5 id="外部状态（Extrinsic-State）："><a href="#外部状态（Extrinsic-State）：" class="headerlink" title="外部状态（Extrinsic State）："></a><strong>外部状态（Extrinsic State）</strong>：</h5><p>每个对象独有的、可能会变化的部分，例如位置、大小等。</p>
</li>
</ul>
<h5 id="共享对象："><a href="#共享对象：" class="headerlink" title="共享对象："></a><strong>共享对象</strong>：</h5><p>​	享元模式通过共享内部状态的对象来减少内存消耗。客户端只需要维护外部状态，内部状态由共享的享元对象提供。</p>
<h5 id="享元工厂（FlyweightFactory）："><a href="#享元工厂（FlyweightFactory）：" class="headerlink" title="享元工厂（FlyweightFactory）："></a><strong>享元工厂（FlyweightFactory）</strong>：</h5><p>​	负责管理享元对象的创建和共享。它维护一个缓存池，避免重复创建相同的享元对象，只有在享元对象不存在时才会创建一个新的对象。</p>
<hr>
<h2 id="目的分析"><a href="#目的分析" class="headerlink" title="目的分析"></a>目的分析</h2><p>​	还是得结合现实来进行一些分析，在生活中，存在一些场景需要我们去使用一些<strong>重复</strong>的对象或者具有<strong>高相似度</strong>的对象，在这种需求下，我们如果去给这些对象都进行一个完整的构造，(换句话说，我们如果想要对这些个对象进行各自数据的一套构建) 将会是很费时费力的。</p>
<p>​	这里我们引用C++中类的一个特性来说明:<strong>类的静态(static)成员</strong></p>
<p>​	我们知道，在类的设计中，我们如果将一个成员的属性声明为了<strong>static属性</strong>，那么这个成员将会是在这个类实现出的所有类中共享的。通过这个属性的声明，我们能够实现类对于这个成员属性的共享。同时，这个属性也不会在派生出的类中进行创建。</p>
<blockquote>
<p>​	题外话，你如果读过CSAPP你就应该知道这个静态成员会被储存在哪里。其实就是我们可执行文件中的.bss段。所有的实例类中应该都保留着这块内存区域的一个引用以提供对于这个静态成员变量的访问。</p>
</blockquote>
<p>​	从上面我们初步了解了享元模式下的一个基本性质，就是实现对于一些类属性的共享。当然，在我们的享元模式中，一般不指这些通过静态成员的实现。在具体实现中，我们是将这种属性应用到了更复杂的场景之中。这时如果使用一个静态成员来设计的话会导致设计上面的麻烦，所以我们考虑将这些应该被共享的属性放于一个类中并进行管理。</p>
<h3 id="无端猜测"><a href="#无端猜测" class="headerlink" title="无端猜测"></a>无端猜测</h3><blockquote>
<p>​	虽然我还没有深入去了解这个的应用场景。不过我想进行一些合理的猜测，在实际应用这种，我们这些共享类的创建如果比较严格，要求不能够被随便复制出去的话，可能考虑使用一个<strong>单例模式</strong>来创建这些个共享类。如果这些属性需要被频繁的修改以及被一些类给单独拿出进行使用，那么可能使用<strong>原型模式</strong>来设计共享类。</p>
</blockquote>
<p>​	</p>
<blockquote>
<p>​	话说回来，我们还是来系统的说明下襄垣模式的目的吧。我的问题就是在学一个东西时总是会发散出去，想当初学一节CSAPP的课就为了了解这了解那一个半小时的课硬是给我用了一个晚上和一个早上。</p>
</blockquote>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ol>
<li><strong>减少内存消耗</strong>：通过共享相同的对象，避免了每次创建相同对象的内存开销。</li>
<li><strong>提高性能</strong>：减少了重复对象的创建，降低了对象的实例化时间。</li>
<li><strong>控制细粒度对象的数量</strong>：享元模式适用于需要大量细粒度对象并且这些对象大部分具有相同状态的场景。</li>
</ol>
<h2 id="美图"><a href="#美图" class="headerlink" title="美图"></a>美图</h2><p><img src="/2024/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/flyweight-zh.png" alt="享元设计模式"></p>
<hr>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><h3 id="第一类图分析"><a href="#第一类图分析" class="headerlink" title="第一类图分析"></a>第一类图分析</h3><p><img src="/2024/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/edd2f30924f44ff6bae0bd259202b9c9.png" alt="img"></p>
<blockquote>
<p>​	让我们来分析下这个类图中的层次</p>
</blockquote>
<p>​	这个类图其实只是实际享元模式中的一个层次，即享元类的创建，不过这个图能够帮助我们很好的一步步理解具体的享元模式下的架构，我们先来分析下这里的功能。这个类图中的功能其实就只是在具体的享元模式中去负责享元类的创建，至于享元类在其他类的运用，并没有在这个图中显示出来。</p>
<p>​	在这个类中，<strong>BlackPiece类</strong>和<strong>WhitePiece类</strong>就是我们的俩种享元类。其实这个类图还可以进行优化，我们看到这俩个类其实具有相同的成员，也就是说，这俩个其实都可以归档到一个父类进行管理以及接口规范的，不过这里还行了，你可以自己去画一个类图。</p>
<p>​	我们来看，在这种类图中，我们其实不是直接通过享元类去进行创建的。相反，我们是通过一个工厂类来进行这些享元类的生产的。其实给出这个类图后你就应该了解这个工厂存在的意义了。毕竟，如果你都需要使用享元类了，就意味你不免需要创建大量的相似对象，你只是使用了结构性模式去进行这些对象的建构，但是这些对象的生产呢?这里是设计模式的<strong>建造者模式</strong>中需要去管理的。我们需要注意的是，对于系列的设计模式之间，其并不是相互割裂的，相反，它们的关系极其紧密。</p>
<blockquote>
<p>​	这里我对工厂的猜想是一般不会用到抽象工厂，一般的话应该使用工厂模式即可，不过还是那句话，依照现实需求去进行设计。这里直接使用简单工厂来画也无所谓，只是为了说明这种建造模式是可行且可取的。</p>
</blockquote>
<h4 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h4><p>​	在这里，我们存在着多种享元类，这些享元类具有着相同的外部属性，但是这些属性内部的实现可能有所不同，就比如在游戏中的子弹，可能伤害高点，可能伤害低点，依照这种差异化进行从抽象父类的派生。</p>
<p>​	接着，我们需要对这些个享元基类进行一些实例化。虽然说享元基类是为了减少实例化而产生的。但是，这里的工厂创建其实是为了适配现实生活中的场景的。毕竟，即使你再很多地方不用去进行享元基类的再创建，但是你在一些应用场景下你还是需要去对其进行批量再创建的，这里就需要我们的建造型设计模式了，上面说了一些，不再扩展。当然，你也可以不使用<strong>工厂</strong>，依照现实需求，你甚至可以对这些个享元基类进行<strong>单例模式</strong>的使用。</p>
<blockquote>
<p>​	总之，这上面这个类图，其实是为了进行享元模式中的享元类的构建，接下来，我们再看一个类图。</p>
</blockquote>
<hr>
<h3 id="第二类图分析"><a href="#第二类图分析" class="headerlink" title="第二类图分析"></a>第二类图分析</h3><img src="/2024/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/image-20241222204418259.png" alt="image-20241222204418259" style="zoom:80%;">

<blockquote>
<p>​	这里我们就不对那些之前分析过的进行分析，我们只来看这里的享元基类与实际对象之间的关系。</p>
</blockquote>
<h4 id="享元类与构件类"><a href="#享元类与构件类" class="headerlink" title="享元类与构件类"></a>享元类与构件类</h4><p>​	可以看到，它们之间是通过一个聚合关系来进行连接的，这其实也符合享元模式的设计思路。享元模式希望这些享元类是一些相对静态的数据。那么，我们不应该希望这些个享元被挂载到特定的构件类中导致这俩的声明周期被绑定。简单说吧，通过聚合关系而不是组合关系能够更符合我们生产环境中对于享元模式中的管理。</p>
<p>​	额外注意到一点，在这个类图中，其实享元类的生命周期是被工厂类所管理的。由工厂类去管理是否要生产享元类，同时，由工厂类来进行这些享元类的实际分配。通过这种职责的分离，各个类功能进行进一步的解耦，更加符合单一职责原则。</p>
<p>​	</p>
<blockquote>
<p>​	好了，其他的其实就没有什么好说的，你应该也能够看懂，该上代码了。</p>
</blockquote>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><blockquote>
<p>​	<strong>在设计模式的搓代码过程中，慢一点，跟着搓，去逐层建构其整个设计模式下的层次逻辑，能给让你对整个的理解更加深入。</strong></p>
</blockquote>
<hr>
<h3 id="享元基类"><a href="#享元基类" class="headerlink" title="享元基类"></a>享元基类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//享元模式的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightBody</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FlyweightBody</span>(string sprite):<span class="built_in">m_sprite</span>(sprite) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FlyweightBody</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y ,<span class="type">int</span> speed)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>= <span class="number">0</span>;<span class="comment">//重绘精灵图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string m_sprite;    <span class="comment">//精灵图</span></span><br><span class="line">    <span class="comment">//string color;    //颜色</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这个类定义了我们整个享元类的基本属性，定义了接口规范等，老生常谈的东西，这里就不再赘述，自己看吧。</p>
<hr>
<h3 id="享元子类"><a href="#享元子类" class="headerlink" title="享元子类"></a>享元子类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//享元类的子类-共享的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedBombBody</span> : <span class="keyword">public</span> FlyweightBody &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> FlyweightBody::FlyweightBody;</span><br><span class="line">    ~<span class="built_in">SharedBombBody</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y ,<span class="type">int</span> speed)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt;m_sprite&lt;&lt;<span class="string">&quot;以每小时&quot;</span> &lt;&lt;speed&lt;&lt;<span class="string">&quot;的速度飞到了(&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;)处&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前在(&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;)的位置处重绘了&quot;</span>&lt;&lt;m_sprite&lt;&lt;<span class="string">&quot;弹体...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//享元类的子类-不共享的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniqueBombBody</span> : <span class="keyword">public</span> FlyweightBody &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> FlyweightBody::FlyweightBody;</span><br><span class="line">    ~<span class="built_in">UniqueBombBody</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y ,<span class="type">int</span> speed)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_sprite&lt;&lt;<span class="string">&quot;以每小时&quot;</span> &lt;&lt;speed&lt;&lt;<span class="string">&quot;的速度飞到了(&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;)处&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前在(&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;)的位置处重绘了&quot;</span>&lt;&lt;m_sprite&lt;&lt;<span class="string">&quot;弹体...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这个其实页没有什么好说的，就是一个具体的享元类，定义了这类享元所应该有的属性。</p>
<p>​	需要注意的是，我们派生出来的这些享元类之间的属性应该是存在差异的，就比如，一个可能是共享的，一个可能是不共享的。可能还是抽象了点。换句话说吧，在**&lt;&lt;葬送的芙莉莲&gt;&gt;**（我缺的第二季这块快点给我端上来啊！！！！！）中的宝箱。这其中一些可能包含了一些魔导书，可能包含了一些装备，当然，也有可能是宝箱怪。但是，这些都是宝箱，而且，这些都是会在异世界世界观下普遍出现的事物。这里的就跟享元模式的应用环境很像了。</p>
<hr>
<h3 id="享元挂载类"><a href="#享元挂载类" class="headerlink" title="享元挂载类"></a>享元挂载类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发射炮弹，享元类挂载的大类，复杂的实际对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LaunchBomb</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LaunchBomb</span>(FlyweightBody* body):<span class="built_in">m_body</span>(body) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">LaunchBomb</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSpeed</span><span class="params">(<span class="type">int</span> speed)</span> </span>&#123;</span><br><span class="line">        m_speed = speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        m_x = x;</span><br><span class="line">        m_y = y;</span><br><span class="line">        m_body-&gt;<span class="built_in">move</span>(m_x,m_y,m_speed);  <span class="comment">//调用享元类的方法,统一接口的思想</span></span><br><span class="line">        <span class="built_in">draw</span>();  <span class="comment">//调用享元类的方法,统一接口的思想</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_body-&gt;<span class="built_in">draw</span>(m_x,m_y);  <span class="comment">//调用享元类的方法,统一接口的思想</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FlyweightBody *m_body;</span><br><span class="line">    <span class="type">int</span> m_speed=<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> m_x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m_y=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	这里就是对应的享元类挂载的地方，在这其中其实包含的是一些相对统一的方法。而且事先声明一点，在稍微复杂一点的设计中，这种类可能是不止一个的。这样类比吧，我这里其实是吧那些个宝箱怪，具有各种奖励的宝箱都归纳到了这个类中，并没有赋予具体的属性，在实际的设计中，对于这些宝箱怪，武器宝箱等，一般是存在各自独立的类来进行挂载的，这里只是为了简单而编写的，别被我限定了思路。</p>
<p>​	回来看到这个类中，我们可以看到在这个类中存在着一些自己的方法，其实这些方法你看起来有没有点眼熟。是不是有点像之前的外观模式中的封装。事实上也确实，你想啊，当你打开一个宝箱时，你知道里面发生了什么吗，不知道吧，你只是看到了最后的一个结果。当然，打住，这方面不再深入。</p>
<blockquote>
<p>​	<strong>总之，对于这个类，我们需要注意的是，这一系列类其实就是对应的享元类的具体使用实现，这些类是使用享元类的外层，是我们用户层所直接接触到的东西</strong></p>
</blockquote>
<hr>
<h3 id="享元工厂类"><a href="#享元工厂类" class="headerlink" title="享元工厂类"></a>享元工厂类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//享元简单工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BombBodyFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BombBodyFactory</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">//工厂类的析构函数  由工厂类来对享元类的对象进行管理释放</span></span><br><span class="line">    ~<span class="built_in">BombBodyFactory</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_map.<span class="built_in">begin</span>();it != m_map.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">            <span class="keyword">delete</span> it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        m_map.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FlyweightBody* <span class="title">getFlyweightBody</span><span class="params">(string key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_map.<span class="built_in">find</span>(key) == m_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            FlyweightBody* body = <span class="literal">nullptr</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;创建新的&quot;</span>&lt;&lt;key&lt;&lt;<span class="string">&quot;对象&quot;</span>&lt;&lt;endl;</span><br><span class="line">            body = <span class="keyword">new</span> <span class="built_in">SharedBombBody</span>(key);</span><br><span class="line">            m_map[key] = body;</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;正在复用&quot;</span>&lt;&lt;key&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> m_map[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    map&lt;string,FlyweightBody*&gt; m_map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	<strong>这个类其实是我认为这些类之中最有理解难度的一个类了。</strong></p>
<h4 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h4><p>​	看到这了，我们先停下来，你还记得住前面我们讲的层次吗，我们再来梳理一遍。</p>
<blockquote>
<p>​	首先，这些类最底层的，应该是我们的享元抽象类，这个抽象类管理者享元类的基本属性以及接口规范</p>
<p>​	然后，是我们的具体享元类，这些类定义了我们具体的享元属性。例如，宝箱怪属性，武器箱属性</p>
<p>​        再然后，是我们的享元挂载类，这是一系列享元实例化的地方。为什么要说实例化，因为一般来说，单独的享元类是没有使用的    价	值的，只有将这些属性添加到实际的事物上它才有使用的价值。</p>
<p>​	最后就是我们现在要讲的享元工厂类了。</p>
</blockquote>
<hr>
<blockquote>
<p>​	<strong>当然，我们这里讲的不是整个的层次，你看层次还是得看UML类图，这里只是说的我的顺序。叠个小甲</strong></p>
</blockquote>
<p>​	来进入这个工厂，这个工厂的外部功能其实很清晰，而且由于我们已经学完了工厂模式，所以我们看过去就知道这个工厂打的怎么工作的，所以我们看到这个工厂中最有意思的一个地方。就是这里的成员变量 <strong>map&lt;string,FlyweightBody*&gt; m_map;</strong> </p>
<p>​	这里最有意思的地方就是这里的<strong>键值对</strong>，这里的第二个成员是我们的抽象享元基类指针，这意味着什么，意味着我们可以对其进行内存的管理。而我们回想一下工厂的功能是什么，就是<strong>生产</strong>我们的实例对象吧。你到这里应该有自己的想法了吧。是的，这里工厂最特殊的地方就是在于<strong>其可以管理所有在这个工厂中生产的享元对象的整个生命周期</strong>，包括从创建一直到死亡。</p>
<p>​	你到现在可能还有点疑惑，没事，等我给出下面的测试代码你就明白了。</p>
<hr>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建三种型号炮弹，每种有若干个对象对该类对象进行复用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BombBodyFactory factory;</span><br><span class="line">    string key1 =<span class="string">&quot;毒气弹&quot;</span>;</span><br><span class="line">    string key2 =<span class="string">&quot;炸弹&quot;</span>;</span><br><span class="line">    string key3 =<span class="string">&quot;彩蛋&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要动态数据，即那些具体发射炮弹的类，就是上面的LaunchBomb类</span></span><br><span class="line">    vector&lt;LaunchBomb*&gt; bombs;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建三种型号炮弹，每种有3对象,2个会对该类对象进行复用</span></span><br><span class="line">    vector&lt;string&gt; keys = &#123;key1+<span class="string">&quot;1&quot;</span>,key2+<span class="string">&quot;2&quot;</span>,key3+<span class="string">&quot;3&quot;</span>,key1+<span class="string">&quot;1&quot;</span>,key2+<span class="string">&quot;2&quot;</span>,key3+<span class="string">&quot;3&quot;</span>,key1+<span class="string">&quot;1&quot;</span>,key2+<span class="string">&quot;2&quot;</span>,key3+<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过工厂类创建炮弹对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> key:keys) &#123;</span><br><span class="line">        FlyweightBody* body = factory.<span class="built_in">getFlyweightBody</span>(key);</span><br><span class="line">        LaunchBomb* bomb = <span class="keyword">new</span> <span class="built_in">LaunchBomb</span>(body);</span><br><span class="line">        <span class="comment">//使用随机轨迹</span></span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            x = <span class="built_in">rand</span>()%<span class="number">1000</span>;</span><br><span class="line">            y = <span class="built_in">rand</span>()%<span class="number">1000</span>;</span><br><span class="line">            bomb-&gt;<span class="built_in">move</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        bombs.<span class="built_in">push_back</span>(bomb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动炮弹</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> bomb:bombs) &#123;</span><br><span class="line">        bomb-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> bomb:bombs) &#123;</span><br><span class="line">        <span class="keyword">delete</span> bomb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建彩蛋</span></span><br><span class="line">    <span class="comment">//可以采取一个工厂类来创建，也可以直接new</span></span><br><span class="line">    FlyweightBody* body = <span class="keyword">new</span> <span class="built_in">UniqueBombBody</span>(<span class="string">&quot;大彩蛋&quot;</span>);</span><br><span class="line">    LaunchBomb* bomb = <span class="keyword">new</span> <span class="built_in">LaunchBomb</span>(body);</span><br><span class="line">    bomb-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">delete</span> bomb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//享元类是与业务类聚合的，业务类的生命周期结束，享元类不一定也就结束了，所以需要手动释放</span></span><br><span class="line">    <span class="keyword">delete</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这个测试程序我就不进行分析了，自己分析去吧。我们主要来看到这个测试程序中的<strong>内存管理</strong>这一块。</p>
<p>​	在这个程序中，我们大部分的享元类都是由工厂创建的，那么也就意味着，这些个享元类在工厂类中都保有一份指针。或者，我们其实可以这么理解，这些享元类是一系列的单一产品，由工厂生产，且只会在工厂内部保留一份。当你想要使用产品时，你去申请对应的使用权，你可以利用这个产品进行一些操作，，但是你无权对于这个产品进行销毁。</p>
<p>​	现实生活中其实存在这种例子，但是我不是很清楚，我能够想到的就是一些公司提供的一些服务。有懂的可以在下面评论区分享。</p>
<p>​	总之，在这种工厂架构下，你无权去对这个产品的声明周期进行管理，这里是可以的，所以这里其实存在一些设计上的巧妙之处，当然巧在哪我也不知道()。也就是说，这个工厂其实还起到了一个屏蔽上下层使用的作用，用户只需要去使用，至于内存管理这方面的细节，其并不需要去关心，自然有人去进行管理。在这里，就是由工厂区进行管理的。</p>
<p>​	当我理解这一点之后，我其实是感觉到很兴奋的，因为<strong>这种设计实在是太妙了</strong>。用户不需要去进行繁琐的可能错漏的一个个享元对象的内存管理(如果存在多个享元类实例的话)。享元类本身其实也不需要去注意它什么时候去死。享元类的内存生命周期被巧妙的绑定到了工厂之上，由工厂直接管理。我们可以在工厂中去定义内存管理上面的细节，就比如工厂(死亡)倒闭时，其中的产品也大多不存在一般，可能是在工厂死亡是被一起析构掉的，也可能是其他。</p>
<blockquote>
<p>​	总的来说，这个架构对于单一职责的遵守，使得整个程序的架构变得很美。这种美是你不去自己搓一遍码，去理解对应的UML图所接触不到的，所以说，看UML类图是设计模式的不可或缺的一环。</p>
</blockquote>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	在享元模式中，存在一些令人兴奋的设计方法，这些方法需要你去进行一定程度的理解。</p>
<p>​	享元模式的重点，如其他模式一般，落在了它的名字之上。</p>
<p>​	<strong>享元二字，重点在享</strong>。通过对于一系列的共有属性的剥离，实现了属性的复用，通过将这种属性的创建和管理对于工厂的委托，实现了资源管理上的优化。不仅使得属性得以很大程度上的复用，还是得用户不用去担心内存管理上的细节。</p>
<hr>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2024/12/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>最后一种结构型模式了，会赢的</p>
</blockquote>
<p>​	通过代理模式的名字我们也可以了解到这个模式的重要之处就在与这个”代理”二字。我们举几个生活中的例子吧。就比如之前闹的沸沸扬扬的俄乌冲突，其实就是一场代理人战争，乌克兰实际上就是美国的代理人，为什么需要这个代理人呢，因为本人不好下场。换句话说，使用代理人的一般场景就是自己动手的代价是无法接受的，需要通过一种手段来<strong>减少损失</strong>，这就是代理的关键之处。</p>
<span id="more"></span>

<p>​	再举一个较近的例子。就比如我们去打开一个md文档，这个文档可能会很大，其中包含了一系列的数字和图片，如果我们需要一次性的全部打开的话代价是很大的，可能会感觉到明显的卡顿，这是很影响体验的。为了优化这种，我们可以考虑将这里的系列图片给添加代理。在我们打开时我们不需要去创建图片，而是去通知这些个代理我可能用到这些图片，去让这些代理准备好。直到我们真正需要使用图片(观看，下载等)时才去加载对应的数据。</p>
<p>​	其实吧，我感觉我们的内存系统中应该就应用到了<strong>代理</strong>这一概念。让我们想想我们的内存系统是怎么去加载一个程序的。不知道就去学<strong>CSAPP</strong>吧，小子。当我们点击一个可执行文件或者命令行输入一个指令时。程序调取对应的数据段进入主存。那么，也就是说，我们前面在主存之中最多就保留着对于可执行文件的引用而不是完整的文件。这种引用其实就是一种代理。</p>
<p>​	接着来看一下我们的页缺失异常的情况。当发生页缺失时，触发对应的信号，程序中断，控制权交还内核，内核进行复制，复制完成后重新把控制权交给程序这个用户。可以看到，这里的内核其实就相当于一个代理人的角色，其代理了所有的程序，当我们的CPU等需要一个程序的信息时，都是通过内核这个代理去进行间接的提取的。通过这样，程序不过去关心这个数据的提取是否麻烦。隔离了用户层与数据层。</p>
<hr>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>​	<strong>为其他对象提供一种代理以控制对这个对象的访问。</strong></p>
</blockquote>
<p>​	这是《设计模式：可复用面向对象软件的基础》（<strong>Gang of Four，GoF</strong>）中给出的定义。这个定义我们前面其实已经说的很清楚了。这里就不再对其进行赘述了。</p>
<p>​	</p>
<p>我们来看一下在《设计模式：可复用面向对象软件的基础》（<strong>Gang of Four，GoF</strong>）提高的适用性，其实也是几个具体的例子。</p>
<p>《设计模式：可复用面向对象软件的基础》（<strong>Gang of Four，GoF</strong>）中指出，代理模式适用于以下场景：</p>
<hr>
<h3 id="1-远程代理（Remote-Proxy）"><a href="#1-远程代理（Remote-Proxy）" class="headerlink" title="1. 远程代理（Remote Proxy）"></a>1. <strong>远程代理（Remote Proxy）</strong></h3><p>当需要访问一个远程对象时，代理可以在本地充当远程对象的代表，客户端可以像操作本地对象一样操作代理。</p>
<ul>
<li><strong>场景</strong>：分布式系统或网络通信中，客户端与远程服务之间通过代理进行交互。</li>
<li><strong>示例</strong>：Java RMI（远程方法调用）或 gRPC 中的客户端存根。现实中的大使馆</li>
</ul>
<hr>
<h3 id="2-虚拟代理（Virtual-Proxy）"><a href="#2-虚拟代理（Virtual-Proxy）" class="headerlink" title="2. 虚拟代理（Virtual Proxy）"></a>2. <strong>虚拟代理（Virtual Proxy）</strong></h3><p>当创建一个消耗大量资源的对象时，代理可以推迟对象的创建，并在真正需要时才实例化它（即延迟加载）。</p>
<ul>
<li><strong>场景</strong>：需要优化性能或延迟加载资源的场景，例如加载大文件、大图片等。</li>
<li>示例：<ul>
<li>加载大图片时，只在显示时才真正加载。</li>
<li>数据库连接池中的连接代理。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-保护代理（Protection-Proxy）"><a href="#3-保护代理（Protection-Proxy）" class="headerlink" title="3. 保护代理（Protection Proxy）"></a>3. <strong>保护代理（Protection Proxy）</strong></h3><p>当需要控制对对象的访问权限时，代理可以提供额外的权限检查功能。</p>
<ul>
<li><strong>场景</strong>：需要对不同用户角色（如管理员和普通用户）进行访问控制的场景。</li>
<li>示例：<ul>
<li>操作系统中的文件访问控制。</li>
<li>公司内部的权限管理系统。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-智能引用（Smart-Reference）"><a href="#4-智能引用（Smart-Reference）" class="headerlink" title="4. 智能引用（Smart Reference）"></a>4. <strong>智能引用（Smart Reference）</strong></h3><p>在访问某个对象时，代理可以在实际操作前后执行一些附加操作，例如记录访问日志、统计引用计数、监控性能等。</p>
<ul>
<li><strong>场景</strong>：需要跟踪或管理对象的引用与访问。</li>
<li>示例：<ul>
<li>引用计数机制，自动管理对象的生命周期。</li>
<li>日志记录代理，记录对某些重要对象的访问情况。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-缓存代理（Caching-Proxy）"><a href="#5-缓存代理（Caching-Proxy）" class="headerlink" title="5. 缓存代理（Caching Proxy）"></a>5. <strong>缓存代理（Caching Proxy）</strong></h3><p>代理保存一些已有的计算结果，当客户端请求时，直接返回缓存值而不是重新计算。</p>
<ul>
<li><strong>场景</strong>：需要频繁访问资源但不希望重复计算的场景。</li>
<li>示例：<ul>
<li>数据库查询结果的缓存。</li>
<li>大型计算任务结果的缓存。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-防火墙代理（Firewall-Proxy）"><a href="#6-防火墙代理（Firewall-Proxy）" class="headerlink" title="6. 防火墙代理（Firewall Proxy）"></a>6. <strong>防火墙代理（Firewall Proxy）</strong></h3><p>代理用于保护对象，使其不直接暴露在潜在的风险环境中。</p>
<ul>
<li><strong>场景</strong>：需要保护内部资源免受外部非法访问时。</li>
<li>示例：<ul>
<li>网络层中的防火墙代理。</li>
<li>内网与外网之间的网关。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>GoF 提到的代理模式适用性主要聚焦于以下几点：</p>
<ol>
<li>优化性能（如虚拟代理、缓存代理）。</li>
<li>控制访问权限（如保护代理、防火墙代理）。</li>
<li>隔离复杂性（如远程代理、智能引用）。</li>
</ol>
<p>​	通过代理，<strong>访问的灵活性</strong>和<strong>系统的扩展性</strong>得到了极大增强。代理模式的适用性非常广泛，可以根据实际需求选择合适的代理类型。其实吧，这上面的几个代理模式都不重要，没有必要去深入了解，这些都是在一些代理模式中的实际应用场景中抽离出来的普适性质。主要还是得去看UML类图和自己去搓一遍码才能深入理解。</p>
<hr>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><hr>
<p><img src="/2024/12/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/1.png" alt="img"></p>
<hr>
<p>​	可以看到，代理模式对应的类图相对于之前的享元模式等都是算简单的那一批了。</p>
<p>​	<em>圖中包含三大類別：</em></p>
<blockquote>
<p><code>**Subject**：是一個抽象類別或介面，定義*</code><em>Proxy</em><code>*和*</code><em>RealSubject</em><code>*的共同介面，當任何有使用*</code><em>RealObject</em><code>*的地方皆能使用*</code><em>Proxy</em>&#96;<em>。</em></p>
<p><code>***RealSubject***</code><em>：被代理的角色，也就是</em><code>*Proxy*</code><em>所代表的真實物件。</em></p>
<p><code>***Proxy***</code><em>：保存一個參考使得代理可以存取實體，並提供一個與</em><code>*Subject*</code><em>相同的介面，這樣代理就可以用來代替真實物件。</em></p>
</blockquote>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><strong>三个类：</strong>	</p>
<hr>
<p><strong>Subject类</strong></p>
<p>​	这个类是所有进行交互的类的父类，也就是说，这是一个定义了接口规范的类，之后的代理人类，幕后人类，用户层类都是使用这个接口规范的。还是那句话，你实际设计中可能没有这个这个类，但是没有这个类不太可能。</p>
<hr>
<p><strong>RealSubject类</strong></p>
<p>​	这个类是幕后人类，当然，这些个名字都是我瞎编的，无所谓了。在代理模式中，这个就是那个会被代理的类。通过一个接口规范类的继承可以大大简化我们设计阶段的接口问题，何乐而不为。</p>
<hr>
<p><strong>Proxy类</strong></p>
<p>​	这个类就是我们这个类图中的代理人类了，这个类直接与我们的RealSubject类接触。并且，一般来书，其接触的类只会有有限个代理人且不能随便扩展，不然那不就成公交车了。这个类进行了用户层与幕后层之间的直接联系，好处在之前已经说过了就不再赘述。</p>
<blockquote>
<p>​	由于代理模式的UML类图是相对简单的，所以我们更需要靠代码来进行进一步的理解。</p>
</blockquote>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>​	代理模式的代码简单来写时相当简单的，但是吧，实际的应用场景并没有遇到过，之后有机会再看吧。</p>
<p>​	这里直接给出三个类的代码，这次不会进行细致分析，只简单过一遍</p>
<p>​	</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象主题角色：声明真实主题和代理主题的共同接口。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Communication</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">commuication</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Communication</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	在这个类中，定义了抽象的接口。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//幕后人：定义了代理角色所代理的事物</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Speaker</span> : <span class="keyword">public</span> Communication &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">commuication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Speaker is speaking.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	在这个类中去定义实际的行为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代理主题角色：保存一个引用使得代理可以访问实体，并提供一个与真实主题角色相同的接口，这样代理就可以用来代替真实主题。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Communication &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Proxy</span>() &#123;</span><br><span class="line">        is_Start = <span class="literal">true</span>;<span class="comment">//只要创建了就是开启代理</span></span><br><span class="line">        speaker = <span class="keyword">new</span> <span class="built_in">Speaker</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> is_Start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStart</span><span class="params">(<span class="type">bool</span> isStart)</span> </span>&#123;</span><br><span class="line">        is_Start = isStart;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">commuication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_Start) &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;开始代理&quot;</span>&lt;&lt;endl;</span><br><span class="line">            speaker-&gt;<span class="built_in">commuication</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;没有代理权限&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Proxy</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> speaker;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> is_Start;</span><br><span class="line">    Speaker* speaker;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	这就是一个相当简单的代理类的实现了。可以看到，这里简单的设置了一些权限位进行一些标识。通过这些个标识，可以看到当前代理是否存在一些权限，这里获取权限的实现可以交给别的类来做来实现单一职责。</p>
<p>​	其他其实没什么需要注意的，还有一点，就是这里的代理类跟幕后人类是一个组合的关系。这不是一定的，但是代理人类中需要保留一个幕后人类的这一设定一般来说是一定的。毕竟只有保留了这个简单的引用，我们才能够实现代理。就比如，一个国家的大使馆中必须存在实际的工作人员，那么这个大使馆才能实现这个代理的能力。不然，它就是一座挂着名字的空房而已。</p>
<hr>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>​	代理模式相对来说是一个相对好理解的结构型设计模式了，通过一层代理封装实现用户层与实现层之间的隔离。其实很多设计模式都可以看到这一点，只是代理模式进行了一定程度上的特化，将这种功能上的封装特化为代理模式而已。</p>
<blockquote>
<p>​	作为看到的最后一种结构型设计模式，其的使用频率跟我们前面创建型设计模式中的原型模式中好像有点相似。毕竟对于代理这种思想的引入是很自然的，就像原型模式在工厂等创建型设计模式中的使用一样。所以啊，得找点项目来搓才能更好的理解这些个设计模式啊</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><em><strong>该文档进行设计模式的装饰模式的介绍</strong></em></p>
<h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>​	装饰模式，重要就在于<strong>装饰</strong>俩字。装饰模式存在的意义是在于不改变一个对象本身的基础上去给对象添加添加额外的新行为。这种模式可以用一种现实生活中的一个行为进行类比。最贴近的就是一个裸人不断的穿上衣服，这个不断穿衣服的过程就可以视为装饰模式的目的。体现在具体类的设计中就是对于一个类的属性的不断扩充。</p>
<p>​	我们再来从设计模式三原则的角度来分析一下。主要看到开放封闭原则。我们在设计中如果想要去添加一个类的属性，由于开放封闭原则，我们是不希望去直接修改类的设计的。那么我们就需要另外一种方法来进行这个属性的扩充，这种设计的方法或者说模式就被定义为装饰模式。</p>
<p>​	总的来说，这种模式的真正意义就在于解决<strong>类的扩展性问题</strong></p>
</blockquote>
<span id="more"></span>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>要了解设计模式还是得回到具体的例子中去，我们举个网络传输的例子</p>
<img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/example.png" alt="example" style="zoom:80%;">

<blockquote>
<p>图中其实已经显示的很明确了，在网络传输的模型中，每层模型其实就相当于一个<strong>装饰器</strong>。每经过一层模型，我们的数据就会多一些属性，而这些属性就是装饰器给它进行添加的。在进入下一层后，我们会保留在这一层中获取到的新属性。或者这么理解，即使你当前数据已经经历过了一个装饰器的装饰，但是当你到达下一个装饰器的时候，你可以将这个数据对象看做是一个没有经历过装饰的数据。</p>
</blockquote>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>​	对于装饰模式提到的装饰方法，其实我们一般能够想到俩种装饰技巧</p>
<p>​	第一种就是最直观的<strong>继承</strong>，这种很好理解，你继承了一个类就继承了这个类的属性</p>
<p>​	你再在这个新类中去添加一些属性就可以实现这种封装了</p>
<p>​	第二种方法是装饰模式中常用的方法，使用<strong>关联机制</strong></p>
<p>​	这个你去看关联关系的UML类图也能够一眼看出来(你都看到这了不至于连这个都不知道吧)</p>
<h3 id="区别-优劣"><a href="#区别-优劣" class="headerlink" title="区别(优劣)"></a>区别(优劣)</h3><blockquote>
<p>​	既然这俩都能够实现装饰，那我们更常用<strong>关联机制</strong>下的装饰模式的原因以及这俩的优劣呢？</p>
</blockquote>
<h4 id="继承机制"><a href="#继承机制" class="headerlink" title="继承机制"></a>继承机制</h4><blockquote>
<p>​		使用继承的直接优点就是简单，我们需要一个新的属性，就直接在这个子类中去添加属性就可以了，但是这种设计也带来	了一些问题。回想一下我们C++中继承类的创建。这种类的创建其实是静态的。</p>
</blockquote>
<p>​		或者这么说吧，你的子类对象创建其实是需要创建一套属于子类自己的数据的，也就是说，包括了父类的对象也是在构建子类对	象时进行初始化的，这其实会导致一个什么问题呢，就是我们其实很难去控制这个子类包含的基类数据。因为这是一个属于自己的副	本，那么当我们想将这个子类再装饰上另一个子类时，这里的设计其实会比较混乱，即使你会说可以使用父类指针，但事实上这种设	计会导致在后续中我们的冗余数据会增多。因为在装饰时我们并不是使用现有的进行装饰，而是创建了一个副本进行装饰的，这个就	是整个继承机制的最大弊端。</p>
<p>​		而且在传统的继承模型中，我们是通过类层次结构来扩展功能的，但这会导致子类的功能是预先定义好的。如果想要动态地扩展	或修改对象的功能，传统的继承设计就显得不够灵活。例如：</p>
<p>​		如果我们想给一个已有的类添加新的行为，通常需要通过继承来创建新的子类，这种方式是静态的，需要在编译时确定。如果某	个子类已经被创建，我们无法在运行时再灵活地对其进行修改或扩展，不能随时给对象增加新的功能。这就是静态继承的局限性。</p>
<h4 id="关联机制"><a href="#关联机制" class="headerlink" title="关联机制"></a>关联机制</h4><blockquote>
<p>​		关联机制，顾名思义就是使用关联关系来实现的机制，这是一种更加灵活的方法，通过将一个类的对象嵌入到另一个新对	象中，有另一个对象来进行决定是否调用嵌入对象的api方法以及决定是否对于这个对象的行为进行扩展。我们将这么一个新对	象称之为<strong>装饰器</strong>。</p>
</blockquote>
<p>​		为了使得装饰器以及被装饰器装饰的对象相对于客户端来首透明，我们规定这俩者必须实现相同的接口。通过这样的设计，客户	端使用时不需要去关注这个类是否已经被装饰过。</p>
<p>​		我们可以在被装饰的类中去调用在装饰器类中定义的方法，来为这个类实现更多的功能。而且由于我们前面规定的接口统一而衍	生出来的透明性，这里就实现了我们前面的递归嵌套，即对于已经装饰过的对象可以继续作为新的被装饰的对象进行装饰。这种架构	下我们可以去递归嵌套多个装饰，从而添加任意多的功能。</p>
<p>​		也就是说，我们以关联机制来实现的装饰模式其实是以对客户来说透明的方式来动态的给一个对象加上更多的属性，换句话说，	客户端并不会觉的对象在装饰前后有什么不同，这句话说的有点歧义，不过你需要自己理解一下。装饰模式可以在不需要创建额外更	多的子类的情况下去对对象的功能进行扩展，这个就是装饰模式的模式动机。</p>
<p>​		我再对这里进行一下解析，可能对于前面的动态添加有点误会。简单来看吧，我们只需要在程序编译时去设计出对应的装饰器类	并进行实例化，然后我们就可以在代码中进行设计，在必要时将这些个装饰类绑定上我们需要的类对象，需要注意的是，我们这些装	饰类中，一般都存在一个父类指针用于指向一个相对唯一的对象，这个将会由一定区域内的代码进行使用。接着，当我们想要使用这	个装饰器时，我们只需要去调用对应的类方法即可，此时装饰器就能够实现我们的功能。就比如对应装饰api的多次调用应该实现对	于包含的类对象的多次装饰行为。</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/1419489-20190630151918778-1393745886.png" alt="img"></p>
<blockquote>
<p>​	<strong>在任何一个设计模式中，它的UML类图都是重中之重。</strong></p>
</blockquote>
<h3 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a>继承问题</h3><blockquote>
<p>​	这里你第一眼可能会注意到其中的<strong>继承</strong>关系。在这个类图中，你可以看到对应的所有子类的父类都是Component类。为什么呢，不是说我们不应该使用继承关系来实现吗？</p>
</blockquote>
<p>​	这里我们就需要来进行一些实际的分析了。首先我们应该明白，事实上在实际设计中，能够完全符合设计模式原则的项目是少之又少的，各个模式的具体应用落到项目中后，不免会发生一些变形，就比如这里。我们所有的类都是由Compontent类出来的，为什么呢？</p>
<p>​	这里其实就考虑了一个我们接口设计规范方面的问题了。在我们最理想的设计下，我们是期望我们的抽象装饰类是不依赖于这个Compontent类的。我们期望我们的封装类只包含对应的抽象构建类指针和对应的接口。我们实际上也完全可以这么做，但是我们这里为什么还是将这个装饰类从抽象构建类继承下来的呢。这里就是我们前面提到的接口规范。</p>
<h3 id="接口规范"><a href="#接口规范" class="headerlink" title="接口规范"></a>接口规范</h3><p>​	这我们一个项目的接口规范设计中，这个一般是需要在项目初期就进行确定的。但是吧，如果是手动去规定一个个类中的命名格式，其实是很不切实际的，毕竟这么做的工作量很大，而且一不小心就会出错。所以这里我们就考虑通过继承这种强耦合来实现我们整个装饰模式的接口规范。</p>
<p>​	我们前文已经提到，我们在装饰模式中，需要尽可能的实现装饰前类和装饰后类都尽可能的对用户<strong>透明</strong>。这种透明其实可以简单的理解为:通过学习一个类的api方法，我们基本可以通过同名api调用对应的所有类似的类，或者说继承下来的类以及那些通过设计模式实现的具有层次关系的类。这个就是我们的接口规范所能能做到的事。而这里巧妙的运用了继承这种前耦合的关系来进行设计，大大简化了设计的难度。</p>
<h3 id="妥协"><a href="#妥协" class="headerlink" title="妥协"></a>妥协</h3><p>​	对于这个抽象构件类，既然我们在这个装饰模式的设计中，我们需要其作为我们的接口规范，那么我们就还需要对其进行一些属性的限定。在这个抽象构件类中，我们一般需要为其添加任何成员变量，对于不必要的api，我们都不予以实现，一般的api都使用纯虚函数进行限定。通过一系列的规则设置，我们能够了解到这个接口类的规范以及系列子类的接口，大大简化了设计难度以及了解难度。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>​	我们回来对这个结构进行分析，其实我们可以看到，这种继承的妥协是十分<strong>优雅</strong>的。你看，从抽象构建类中继承下来的具体构建类以及抽象装饰者类中都将具有相同的接口，那么，在我们的抽象装饰者类中，我们就已经可以对于接口进行一层最简单的装饰了，就是在这个装饰者类中的同名函数去调用我们的成员指针所拥有的成员函数。这种对于默认行为的简单规定，将给我们这个抽象装饰类的具体装饰子类的设计省去很多麻烦。</p>
<p>​	<em><strong>多优雅吧，你看。</strong></em></p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><blockquote>
<p><em><strong>所有的代码和文档我都会放在另外一个仓库里，自行访问我的gitHub账号获取</strong></em></p>
</blockquote>
<h3 id="抽象构件类"><a href="#抽象构件类" class="headerlink" title="抽象构件类"></a>抽象构件类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//战士的基类    </span></span><br><span class="line"><span class="comment">//抽象接口类，以及一些十分基本的属性，这些不会很影响原则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solider</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solider</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Solider</span>(string name):<span class="built_in">m_name</span>(name)&#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_name;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fight</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Solider</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string m_name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这个是我们上面那个类图中的<strong>抽象构件类</strong>层次。在我这个类中，我添加了一个成员属性去进行标识，其实这个属性你完全可以丢到等下的子类中，不过丢到这里也无伤大雅了。需要注意的是，如果你一定要添加一些属性在这个抽象基类中，那么这些个属性应该是一些相对简单的，可以通过简单的方法进行操作的，所有比较复杂的操作都不应该被放到基类中。</p>
<p>​	可以看到，我们这里保留了几个虚方法，在这个层次下定义的虚方法将是所有子类中所需要实现的属性，也就是说，通过在抽象基(母)类中去定义抽象方法，我们可以去规定所有的子类所必须实现的一些属性，无论对应的实现类中是否还添加了自己的方法。</p>
<h3 id="抽象装饰类"><a href="#抽象装饰类" class="headerlink" title="抽象装饰类"></a>抽象装饰类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//恶魔果实基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">evil</span>: <span class="keyword">public</span> Solider</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSolider</span><span class="params">(Solider* solider)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_solider=solider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Solider* m_solider=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这个其实就是我们类图中的<strong>抽象装饰类</strong>层次。可以看到，在抽象装饰类中，我们只是添加了一个父类的指针。其实我们还可以对这种架构进行进一步的分析。</p>
<p>​	我们其实可以把装饰类和构件类先组合到一起，如果这样的话其实就是继承下的功能扩展，而且前面的缺陷也已经提到过了就不再赘述。这里之所以将抽象装饰类给它分离出来其实就是为了贴合我们三原则中的<strong>单一职责原则</strong>，我们等下再结合下面再进行分析。</p>
<p>​	其实在这个抽象装饰基类中，我们还可以在这个层次中去添加一些方法，如果添加了这些个方法，那么这些个方法将会像抽象装饰类和一层的具体构件类继承抽象构件基类方法一般去继承抽象装饰类的方法。不过由于层次间的隔离，所以这些由抽象装饰类派生出来的子类的方法的顶层只是抽象装饰类。因此，为了保证接口规范，如果我们一定需要在抽象装饰类中去添加方法的话，我们需要保证这些方法的接口应该跟我们抽象构件类的接口相似。而且由于<strong>单一职责原则</strong>，所有的这些类的功能应该是比较单一的，所以不应该出现接口功能会相差很大导致需要我们去在抽象装饰类中去添加属性的情况。</p>
<blockquote>
<p>​	在抽象装饰类中，我们需要做的其实就是明确我们需要添加的方法。如果必要时，为了可读性，我们应该在抽象装饰类中去添加当前层次的上层需要我们实现的函数，以避免我们需要逐层往上去寻找所有需要实现的方法。</p>
</blockquote>
<h3 id="具体构件类"><a href="#具体构件类" class="headerlink" title="具体构件类"></a>具体构件类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//黑胡子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teach</span> : <span class="keyword">public</span> Solider</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> Solider::Solider;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout&lt;&lt;m_name&lt;&lt;<span class="string">&quot; with great power.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这个类对应了我们UML类图中抽象构件类下的第一层的<strong>具体构建类</strong>，这个类规定了我们的一个基础具体构建的属性，在这个类中，我们除了必须要去实现抽象类方法以外，我们还可以对属性进行添加，因为这里的性质就是对应着我们生活中的产品。当然，在这种架构下，在这个类中添加的属性是不会被装饰类中所发现的(如果你不去专门的通知的话)。</p>
<blockquote>
<p>​	因此，在这一层次的具体构件类中去添加属性得慎之又慎</p>
</blockquote>
<p>​	即使我们添加了属性，这个属性由于单一职责原则也不应该脱离我们整个类的设计初衷，所以这些属性应该与我们的抽象基类方法之间存在着一些互动。</p>
<h3 id="具体装饰类"><a href="#具体装饰类" class="headerlink" title="具体装饰类"></a>具体装饰类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暗暗果实</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DarkFruit</span>:<span class="keyword">public</span> evil</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> evil::Solider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_solider-&gt;<span class="built_in">fight</span>();</span><br><span class="line">        cout&lt;&lt;m_solider-&gt;<span class="built_in">getName</span>()&lt;&lt;<span class="string">&quot;eat darkfruit,has dark ability.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">warning</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">warning</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;m_solider-&gt;<span class="built_in">getName</span>()&lt;&lt;<span class="string">&quot; you ate dark fruit,and you can&#x27;t move when you using ability.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这个类的层次就是我们前面的<strong>具体装饰类</strong>，这个类中，我们需要去实现所有的由抽象构件基类与上层抽象装饰类需要我们去实现的方法。不过，如果我们设计的架构良好，我们将不必去关注我们的上层到底存在了多少层套娃，只需要去关心最近一层的方法接口，这里的设计其实存在一点注意的细节，就是由于我们的抽象装饰类是抽象类，所以其中可能还一些来自抽象构件类的可以实现的方法，我们需要在子类中去实现这些可能存在的方法。当然，在一般的项目中，这些应该有一些清晰的指引的。</p>
<p>​	在这里我们就没有对抽象装饰类进行方法的再一次扩充，所以我们可以看到这里我们只需要实现我们抽象构件类要求的方法即可。除此之外，我们可以看到我们的具体装饰类中其实实现了自己的方法，其应用在了要求实现的接口中。这里其实装饰器类的核心，正是这里的嵌套调用起到了装饰的作用。</p>
<blockquote>
<p>​	对于这里，我们举出的其实就只是一些输出的例子。那么如果存在数据处理方面的要求时我们需要怎么做呢？</p>
</blockquote>
<p>​	在设计中，我们其实不想要我们期望的数据本身被修改，在这里就是我们的抽象构件基类中元素name，但是我们还是需要对这些数据进行处理的话，我们势必就需要一些副本来进行数据的处理的，在一些代码中，你可以看到是在抽象装饰基类中去进行一些成员的拷贝再在具体装饰类中去进行对应的操作的。这其实是取决于我们的具体装饰类的行为，如果我们具体装饰类行为普遍需要数据操作，那么我们就会考虑在基类中去添加对应的方法。但如果只是特殊的几个元素，自然也就没必要在基类中去声明了，只在特定的类中去修改即可。</p>
<blockquote>
<p>由于我还没去理解网络传输，我不太敢确定具体的传输过程，不过我可以应用一下这个场景。就是说你这个数据说是通过协议来进行了传输，但是你本地还是保留了你要传输的数据的。也就是说，你在这里传输数据的过程中，你至少是会对一些数据进行保护的，这里最浅显来看就是我们本地的要传输的数据始终是在本地有一份的。也就是说，这种多层的装饰，一般始终会对上一层的数据进行保护，不会直接去修改原本的数据，即使要使用，要修改，一般也只会涉及到副本。</p>
</blockquote>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">text</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Teach* obj=<span class="keyword">new</span> <span class="built_in">Teach</span>(<span class="string">&quot;黑胡子&quot;</span>);</span><br><span class="line">    obj-&gt;<span class="built_in">fight</span>();</span><br><span class="line">    evil* dark=<span class="keyword">new</span> DarkFruit;</span><br><span class="line">    dark-&gt;<span class="built_in">setSolider</span>(obj);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;===========&quot;</span>&lt;&lt;endl;</span><br><span class="line">    dark-&gt;<span class="built_in">fight</span>();</span><br><span class="line">    <span class="keyword">delete</span> dark;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;===========&quot;</span>&lt;&lt;endl;</span><br><span class="line">    obj-&gt;<span class="built_in">fight</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>​	通过上面那些，我们其实可以了解到装饰模式下的一个本质</p>
<blockquote>
<p>​	一个对象，只有经历过装饰了，那么它才能够具有这个装饰类的属性。如果我们将这个装饰类给从这个装饰完的类中剥离出来，那么这个类将会失去这些被赋予的属性。</p>
</blockquote>
<p>​	上面那个测试程序中就体现了这一点，我们使用了抽象构件进行了一个具体对象的构建，这个对象的输出也只是这个实现类对应的自己的方法，然后我们通过这个构件去为其调用具体装饰类的构建，通过调用对应的同名接口，我们可以看到其产生了不同的行为。接下来，我们将这个装饰类给他删除了并重新调用了具体构件类的方法，可以看到这个类输出的还是进入装饰类之前的方法。由此也证明了上面的那句话。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑胡子 with great power.</span><br><span class="line">===========</span><br><span class="line">黑胡子 with great power.</span><br><span class="line">黑胡子eat darkfruit,has dark ability.</span><br><span class="line">黑胡子 you ate dark fruit,and you can&#x27;t move when you using ability.</span><br><span class="line">===========</span><br><span class="line">黑胡子 with great power.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2024/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><blockquote>
<p>由于一些原因，我需要先学观察者模式，其实就是我需要这个模式去进行课设()</p>
</blockquote>
<hr>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><blockquote>
<p>​	其实所有的设计模式如果只是在看的阶段去过一遍你的感触其实不会很深。相反，如果你在设计中因为一些设计导致出现了一些问题，需要一些设计模式来进行弥补的话，这种学习将会是很深刻的。当然啦，你如果一点设计模式都没有学过，你其实都不会意识到你需要这些设计模式。</p>
<p>​	所以，在我的设想中，一个设计模式好的学习流程应该是先去系统的学一学一些设计模式，就比如创建型设计模式中的几种，然后去进行使用，在使用的阶段你其实不时就会发现你的创建型设计模式和结构型设计模式通常会出现一些问题。或者吧，也可以先依照设计模式的三原则去进行设计架构，然后你一定会发现使用三原则的话会导致的一些疑惑的。</p>
<p>​	就比如我的课设，我在进行重构，想要重新规范下三原则中的单一职责原则时，我想要进行数据模块和渲染模块间的解耦，然后发现这种解耦会导致我的渲染操作不知道在哪里调用，这时我就回来看设计模式，发现这种问题可以通过行为模式中的观察者模式来解决，然后我就自我驱动的去学了，这才是一个学习的正反馈过程啊。</p>
</blockquote>
<hr>
<span id="more"></span>

<h2 id="存在意图"><a href="#存在意图" class="headerlink" title="存在意图"></a>存在意图</h2><blockquote>
<p>​	定义对象建一种一对多的依赖关系，当一个对象的状态发生转变事，所有依赖于它的对象都得到通知并且自动更新。</p>
</blockquote>
<p>​	</p>
<h2 id="使用的动机"><a href="#使用的动机" class="headerlink" title="使用的动机"></a>使用的动机</h2><p>​	在实际的设计过程中，我们常常会遇到一个问题。就是当我们对于一个系统进行解耦的时候，我们把它分割为了一系列的模块。就比如，你在原本的设计中设计了一个可以自己实现数据处理和结构渲染的类。现在你要对这个类进行进一步的解耦，我们先不考虑它是怎么解耦的。</p>
<p>​	我们目前需要看的是，这种解耦会出现的副作用，其中最明显的就是在我们解耦过后，我们原本代码中合作的数据处理模块和渲染模块之间无法协调工作了，这是由于类的特殊性导致的，如果使用嵌套类来实现这只新的模块分割倒也是一种解决方案，但是这种设计又违反了我们的开放封闭原则。所以我们需要一种机制来实现这种独立出来的类的联动。当然，是有其他的一些应用场景的，但是我还没碰到过。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>​	就比如我们的数据模块和渲染模块间的联动，我们期望的是当我们数据发生变动时我们能够实时的去反应出这种变化。这在我们原有的一个系统中只需要去在数据变更时去进行对应的渲染代码执行即可。但是我们现在已经不能够直接去调用渲染代码了，但是我们还是需要这个功能。此时就需要一种机制去进行通知对应的渲染模块去进行工作，而观察者模式恰恰好能够充当这个角色。</p>
<p>​	说了这么多其实还是实际项目中的应用情况。我们来举几个生活中的例子。</p>
<p>​	在现实生活中，我们在任何一个视频网站上，通常都有关注这个功能，当我们关注之后，这个博主只要一更新内容，我们如果有对应的设置的话，我们就能收到对应的通知。同时，一个博主可能存在着许多粉丝，相应的，所有这些粉丝都能够收到对应的推送。这就是一种<strong>发布-订阅模式</strong>。在这种模式中，博主和用户这俩个账号是相对独立的。其中是存在着一种机制来进行实时的通知的。正是由观察着模式来实现这种功能。</p>
<hr>
<h2 id="简单概括"><a href="#简单概括" class="headerlink" title="简单概括"></a>简单概括</h2><p>​	在观察者模式中，一般存在着俩种角色。一个是<strong>订阅者</strong>，一个是<strong>发布者</strong>。一个发布者可能有着多个订阅者。但是一般来说一个订阅者对于发布者是一对一的的。当然实际中，你可能会说一个人可以订阅多个博主，但是这也是不冲突的。这用文字是不好进行阐述的，但是你应该能够理解。</p>
<p>​	通过进行观察者模式，我们实现了一种通知机制，在发布者发布一些信息之后，所有的订阅者应该都能够收到对应的信息。至于订阅者收到这个信息后会进行一个什么样的处理，这个是观察者模式中不关注的。</p>
<blockquote>
<p>​	在观察者模式中，最重要的就是通知机制。这个会在接下来的UML类图中去进行分析。</p>
</blockquote>
<hr>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2024/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/eb9aece31234e8ef95f7e2e0399e5915.png" alt="img"></p>
<blockquote>
<p>观察者模式的UML类图是需要重点分析的，需要重点理解的就是观察者模式中的通知机制。</p>
</blockquote>
<p>​	这里我们将只进行抽象发布者类和抽象订阅者类的分析，其他的子类都不是很重要。</p>
<p>​	首先可以看到在途中ConcreteObserver和ConcreteSubject是一个互相聚合的关系。我们就是通过这种互相聚合来实现通知机制的。</p>
<p>​	</p>
<h3 id="ConcreteObserver类"><a href="#ConcreteObserver类" class="headerlink" title="ConcreteObserver类"></a>ConcreteObserver类</h3><p>​	这个类就是我们对应的观察者类。这个设计中使用了一个name作为信息的接收。当然，这个成员也可以是订阅者的名字，不过这个不重要。主要是看到另外的一个成员，一个指针链表，在这个指针链表中，储存的是当前观察者对应的发布者的指针。也就是说，在订阅者的属性中，是存在一个成员用于管理发布者的信息的。其实你应该很可以理解这个存在的意义，就比如你社交软件中关注的博主。这个其实就是你对应的发布者。订阅者可以通过这个list链表去找到其的订阅者信息并以此进行通知操作。</p>
<p>​	这个其实就是一个对于前面一对多的扩展，实现了一个人可以同时关注多个博主的功能。当然，这里的信息处理事很薄弱的。</p>
<blockquote>
<p>​	还需要来进行着下面的系列成员函数的分析。</p>
</blockquote>
<h4 id="addSubject函数"><a href="#addSubject函数" class="headerlink" title="addSubject函数"></a>addSubject函数</h4><p>​	这个函数的作用其实就写在明面上了，就是添加我们的订阅者，通过一个指针去实现对于发布者的添加，实际上就是添加到自己的发布者链表中去进行管理。</p>
<h4 id="deleteSubject函数"><a href="#deleteSubject函数" class="headerlink" title="deleteSubject函数"></a>deleteSubject函数</h4><p>​	这个函数同样很好理解，就是简单的吧我们指定的一个发布者从我们的成员链表中去移除。没什么好说的。</p>
<h4 id="update函数"><a href="#update函数" class="headerlink" title="update函数"></a>update函数</h4><p>​	这个是整个类的核心，用于进行事件的通知，在这UML类图中是体现不出它到底是怎么进行一个通知的，简单来说一下吧，这其实是一个被调用的函数，而且调用对象一般是对应的发布者，发布者能够通过这个接口来进行信息的传递。</p>
<hr>
<h4 id="ConcreteObsertver类"><a href="#ConcreteObsertver类" class="headerlink" title="ConcreteObsertver类"></a>ConcreteObsertver类</h4><p>​	这个类就是我们的发布者基类了，在这个基类中，很多属性都跟订阅者很相似，我们这里就不加以赘述了。这里主要看到一个函数。就是这里的send函数</p>
<h4 id="send函数"><a href="#send函数" class="headerlink" title="send函数"></a>send函数</h4><p>​	这个函数的作用已经写的很明白了，就是发送信息。它的参数就是它的信息。但是UML类图是体现不出发送这种操作的，还是得等等下的代码分析，不过可以简单的说一下，这里的发布信息就是通过对应的成员链表去进行通知，去进行一次链表的遍历，并依次调用每个成员对应的接收信息的方法去进行推送。</p>
<hr>
<p>​	</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>​	在观察者模式中，最重要看的是它的代码，毕竟相对于其他模式，观察者模式在其的UML类图中暴露的信息有限，但是我并不想再进行分析了，我要回去搓我的课设了，所以我要挖一个我可能永远也不会填的坑了。</p>
<p>​	自己分析去吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象观察者（订阅者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string &amp;message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者（订阅者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subscriber</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Subscriber</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> : name(name) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string &amp;message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Subscriber &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; received message: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125; <span class="comment">// 用于识别订阅者</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象发布者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Publisher</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Publisher</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">subscribe</span><span class="params">(std::shared_ptr&lt;Observer&gt; observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">unsubscribe</span><span class="params">(<span class="type">const</span> std::string &amp;observerName)</span> </span>= <span class="number">0</span>; <span class="comment">// 通过标识符移除</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notify</span><span class="params">(<span class="type">const</span> std::string &amp;message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体发布者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsPublisher</span> : <span class="keyword">public</span> Publisher &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Observer&gt;&gt; subscribers; <span class="comment">// 订阅者列表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">subscribe</span><span class="params">(std::shared_ptr&lt;Observer&gt; observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        subscribers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unsubscribe</span><span class="params">(<span class="type">const</span> std::string &amp;observerName)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        subscribers.<span class="built_in">erase</span>(</span><br><span class="line">            std::<span class="built_in">remove_if</span>(subscribers.<span class="built_in">begin</span>(), subscribers.<span class="built_in">end</span>(),</span><br><span class="line">                           [&amp;observerName](<span class="type">const</span> std::shared_ptr&lt;Observer&gt; &amp;subscriber) &#123;</span><br><span class="line">                               <span class="keyword">auto</span> concreteSubscriber = std::<span class="built_in">dynamic_pointer_cast</span>&lt;Subscriber&gt;(subscriber);</span><br><span class="line">                               <span class="keyword">return</span> concreteSubscriber &amp;&amp; concreteSubscriber-&gt;<span class="built_in">getName</span>() == observerName;</span><br><span class="line">                           &#125;),</span><br><span class="line">            subscribers.<span class="built_in">end</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">(<span class="type">const</span> std::string &amp;message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;subscriber : subscribers) &#123;</span><br><span class="line">            subscriber-&gt;<span class="built_in">update</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建发布者</span></span><br><span class="line">    <span class="keyword">auto</span> publisher = std::<span class="built_in">make_shared</span>&lt;NewsPublisher&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建订阅者</span></span><br><span class="line">    <span class="keyword">auto</span> subscriber1 = std::<span class="built_in">make_shared</span>&lt;Subscriber&gt;(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> subscriber2 = std::<span class="built_in">make_shared</span>&lt;Subscriber&gt;(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅新闻</span></span><br><span class="line">    publisher-&gt;<span class="built_in">subscribe</span>(subscriber1);</span><br><span class="line">    publisher-&gt;<span class="built_in">subscribe</span>(subscriber2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布新闻</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Publishing news...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    publisher-&gt;<span class="built_in">notify</span>(<span class="string">&quot;Breaking News: Observer Pattern in Action!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消订阅</span></span><br><span class="line">    publisher-&gt;<span class="built_in">unsubscribe</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次发布新闻</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nPublishing more news...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    publisher-&gt;<span class="built_in">notify</span>(<span class="string">&quot;Update: Observer Pattern Still Relevant!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2024/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>​	定义一系列的算法，将它们一个个封装起来，并且使得它们可以相互替换。策略模式使得算法可以独立使用与它的用户而变化。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><blockquote>
<p>​	在我们使用的许多编辑器乃至编译器中，我们通常可以看到一些不同的换行符算法，有windows的\r\n，linux的\n，Mac用的\r等。将这些个换行符算法硬编码进我们使用的编辑器或者编译器软件中是不可取的。实际你也可以看到，基本所有的编辑器和编译器都有自己的切换换行符的功能。那么，原因是什么呢?</p>
</blockquote>
<span id="more"></span>

<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol>
<li><strong>复杂性增加</strong><ul>
<li>如果将换行算法直接嵌入到需要换行功能的程序中，会导致代码臃肿且难以维护。</li>
<li>支持多种换行算法的需求进一步加剧了这一问题。</li>
</ul>
</li>
<li><strong>灵活性受限</strong><ul>
<li>如果需要更改换行算法，不希望仍然支持之前的算法。例如，从 Windows 换行标准切换到 Linux 或 macOS 的标准，可能希望只支持新的规则。</li>
<li>继续支持不需要的旧规则可能导致解析问题。</li>
</ul>
</li>
<li><strong>扩展性受限</strong><ul>
<li>当功能被硬编码后，添加新算法或修改现有算法变得十分困难。</li>
</ul>
</li>
</ol>
<p>​	</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>​	也就是说，我们策略模式出现的动机就是为了解决上诉这种硬编码会导致的缺陷。所谓<strong>策略</strong>，就是在一个人面对不同事情时选择的不同应对方法，就比如你在window平台上设计时需要去使用window的换行符，你在linux平台开发时需要去使用linux的换行符。这些都是一种策略模式的体现。</p>
<p>​	也就是说，策略模式最本质的作用，就是通过一种策略来代替一种硬编码的步骤，使得用户能够自己选择当前要使用的方法，或者程序自己选择要使用的方法以取代全部的一种硬编码程序。也就是说，这是一种对于程序的进一步的解耦。</p>
<blockquote>
<p>通过<strong>解耦算法的选择与其具体实现</strong>来提高程序的灵活性和可维护性。</p>
</blockquote>
<p>​	就拿上面那个换行符算法举例，当我们使用策略模式来设计我们的编辑器后，我们能够在编辑器中去自由选择我们当前想要使用的换行符版本，这种动态选择提供了很高的灵活性，显著的提升了我们使用时的灵活性，将这个扩展到我们的类的设计中也是如此。</p>
<p>​	而且我们在考虑一下，如果我们使用策略模式来设计我们的换行符算法，那就意味着如果我们后续还需要对这个换行符算法进行添加或者修改的话，我们只需要去修改对应的区域或者添加新的算法即可，不必去修改现有的选择模块，这也是一种策略模式下的原则遵守和优势。</p>
<hr>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2024/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/735104bbfb7d801a684b9fc3fcd628b4.png" alt="img"></p>
<blockquote>
<p><strong>百闻不如一见，UML类图，启动</strong></p>
</blockquote>
<p>​	首先，策略模式的UML类图是相对简单的，毕竟从本质来看，它关注的其实主要就来个模块，一个模块时选择模块，另一个是算法模块，选择模块时面向用户层的接口，通过这个模块隔离了用户层与算法实现，同时提供了用户选择算法的方式。</p>
<p>​	至于算法层，只需要关注自身的实现，关注与选择模块的接口对接即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------+         +----------------+</span><br><span class="line">|  Context       |         |   Strategy     |</span><br><span class="line">|----------------|         |----------------|</span><br><span class="line">| setStrategy()  |&lt;&gt;------&gt;| + execute()    |</span><br><span class="line">| execute()      |         |----------------|</span><br><span class="line">+----------------+         +----------------+</span><br><span class="line">        |</span><br><span class="line">        |-----------------------------------------+</span><br><span class="line">        |                                         |</span><br><span class="line">+------------------+                  +------------------+</span><br><span class="line">| ConcreteStrategyA|                  | ConcreteStrategyB|</span><br><span class="line">|------------------|                  |------------------|</span><br><span class="line">| + execute()      |                  | + execute()      |</span><br><span class="line">+------------------+                  +------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	更为简单的一个UML类图。虽然有点糙，凑活这看吧</p>
<h3 id="类图要点："><a href="#类图要点：" class="headerlink" title="类图要点："></a><strong>类图要点：</strong></h3><ul>
<li><code>Context</code>（选择模块）：持有 <code>Strategy</code> 的引用，用于调用具体算法。</li>
<li><code>Strategy</code>（算法模块）：定义算法的统一接口，提供一个抽象的算法约束。</li>
<li><code>ConcreteStrategyA</code>、<code>ConcreteStrategyB</code>（具体算法实现）：实现 <code>Strategy</code> 接口，分别提供具体的算法逻辑。</li>
</ul>
<p>​	在这里我们在选择模块中没有列出引用这个属性，但是我们使用这个聚合关系来表示了。不对，你都看到这里了，不应该不知道这个啊，我还写个蛋啊。</p>
<p>​	在这个类图中其实没有显示出到底是一种什么个选择的逻辑，这个是等下我们的代码的工作。在这个类图中，我们主要来分析下我们设计的解耦性。</p>
<h3 id="设计的解耦性"><a href="#设计的解耦性" class="headerlink" title="设计的解耦性"></a>设计的解耦性</h3><ul>
<li><p><strong>对用户：</strong></p>
<ul>
<li><p>用户只需与 <code>Context</code> 交互，完全无需了解具体算法的实现逻辑。</p>
</li>
<li><p><code>Context</code> 提供了灵活的接口，让用户能够动态选择策略或依赖默认策略。这种灵活的选择可能是用户自己的选择也可能是程序自己的旋转，但是一般来说，这种选择都不是有if-else实现的，毕竟你策略模式的一种存在意义就是代替这种令人反感的长嵌套语句</p>
<blockquote>
<p><strong>你可能会疑惑那得怎么动态选择，别急，接着看</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>对算法：</strong></p>
<ul>
<li>各种算法被封装为独立类，彼此互不干扰。它们只需实现 <code>Strategy</code> 接口，与 <code>Context</code> 保持对接即可。</li>
<li>新增算法时，只需增加一个新的具体策略类，无需修改 <code>Context</code> 和其他策略。</li>
</ul>
</li>
</ul>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><blockquote>
<p><strong>实践才是检验真理的唯一方法</strong></p>
</blockquote>
<p>​	其实这里给的代码实例大部分还是为了写而写的，所以其实并没有什么实际应用的价值。而这些存在的意义是给你阐述这些的存在，并在实际的应用中去尝试使用，就比如，我学完策略模式将会把我课设中的数据模块再次进行解耦，将其分割为可以单步执行渲染和一直渲染到底的俩种策略模式，不过那都是后话了，我们先来看代码。</p>
<h3 id="对比示例"><a href="#对比示例" class="headerlink" title="对比示例"></a>对比示例</h3><h4 id="使用-if-else-的实现（不推荐）"><a href="#使用-if-else-的实现（不推荐）" class="headerlink" title="使用 if-else 的实现（不推荐）"></a>使用 <code>if-else</code> 的实现（不推荐）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLineBreak</span><span class="params">(<span class="type">const</span> std::string&amp; os)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (os == <span class="string">&quot;Windows&quot;</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Line break: \\r\\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (os == <span class="string">&quot;Linux&quot;</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Line break: \\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (os == <span class="string">&quot;Mac&quot;</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Line break: \\r&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Unknown OS!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextEditor editor;</span><br><span class="line">    editor.<span class="built_in">printLineBreak</span>(<span class="string">&quot;Linux&quot;</span>);  <span class="comment">// Output: Line break: \n</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li><p><code>printLineBreak</code> 方法中耦合了换行逻辑的选择和实现，扩展性差,破坏了单一职责原则。</p>
</li>
<li><p>增加新的操作系统时，必须修改方法内部的条件分支，破坏了开放封闭原则。</p>
</li>
<li><p>我们在修改时必须对所有的算法都进行维护，可能需要进行全部的实例化占用空间，也可能会使用懒加载机制来复杂使用逻辑。</p>
</li>
</ul>
<h4 id="使用策略模式的实现（推荐）"><a href="#使用策略模式的实现（推荐）" class="headerlink" title="使用策略模式的实现（推荐）"></a>使用策略模式的实现（推荐）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineBreakStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">LineBreakStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">formatLineBreak</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsLineBreak</span> : <span class="keyword">public</span> LineBreakStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">formatLineBreak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\\r\\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxLineBreak</span> : <span class="keyword">public</span> LineBreakStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">formatLineBreak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacLineBreak</span> : <span class="keyword">public</span> LineBreakStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">formatLineBreak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\\r&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;LineBreakStrategy&gt; strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(std::unique_ptr&lt;LineBreakStrategy&gt; newStrategy)</span> </span>&#123;</span><br><span class="line">        strategy = std::<span class="built_in">move</span>(newStrategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLineBreak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strategy) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Line break: &quot;</span> &lt;&lt; strategy-&gt;formatLineBreak() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No strategy set!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextEditor editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态选择策略</span></span><br><span class="line">    editor.<span class="built_in">setStrategy</span>(std::<span class="built_in">make_unique</span>&lt;LinuxLineBreak&gt;());</span><br><span class="line">    editor.<span class="built_in">printLineBreak</span>();  <span class="comment">// Output: Line break: \n</span></span><br><span class="line"></span><br><span class="line">    editor.<span class="built_in">setStrategy</span>(std::<span class="built_in">make_unique</span>&lt;WindowsLineBreak&gt;());</span><br><span class="line">    editor.<span class="built_in">printLineBreak</span>();  <span class="comment">// Output: Line break: \r\n</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优势：</p>
<ol>
<li>避免了 <code>if-else</code> 的分支判断，代码简洁清晰。</li>
<li>新增策略只需添加新的策略类，无需修改现有代码。</li>
<li>动态选择和切换策略，灵活性更强。</li>
</ol>
<p>​	</p>
<blockquote>
<p><strong>那么，代价是什么?</strong></p>
</blockquote>
<p>​	从上面来段代码我们其实可以看到最直观的一点就是，策略模式设计下的程序相对来说会存在更多的子类，这些子类都是对应的子算法类，这样会导致这个程序看起来很臃肿。</p>
<p>​	同时，无论是使不使用策略模式下的设计，我们其实都会存在一种问题，就是我们如果要选择一种算法，我们就必须知道一种算法的存在，这个其实就跟我们平时使用的很多软件一样，特别是编译器这种集成度很高的软件。</p>
<p>​	通常来说，为了集成到图形化界面上并提供一些多元化的选择，设计者会将功能的选择绑定到按钮上，而程序中的交互按钮又乱七八糟，很多按钮对很多用户来说只是个黑盒，这无疑还是会提高用户的使用难度。</p>
<p>​	而且在很多情况下，我们可能会碰到一些策略算法类之间存在部分逻辑重叠的情况，这会导致代码的重复，不过这种也可以通过基类的方法提取来解决。</p>
<p>​	我为什么提出这一点，其实是为了说明在我们提出一个模式的缺点后，我们应该做的不是去记住这些缺点然后接受它，而是应该通过我们已有的或者将来可能会有的知识来进行我们现有的缺点的一些个隐藏，这个才是举出缺点的意义。而不是，好，这个模式有这些缺点，那我就记住它，当我被问到这些时，我一五一十的去吧这些缺点说出来，这是没有意义的。</p>
<p>​	</p>
<blockquote>
<p>​	但是，总的来说，策略模式的这种优化，还是利大于弊的。因为设计模式关注的过程大多还是程序开发的这个过程，策略模式的设计思想本质就是让每种策略自成一体，通过接口与上下文对接，从而取代臃肿的条件分支语句，使代码更加模块化、可扩展和易维护。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	策略模式的核心思想是<strong>通过封装变化和动态选择策略，来提升代码的灵活性和可维护性</strong>。尽管它可能会增加类的数量和一定的设计复杂度，但其在算法扩展性和代码清晰度上的优势使得它在实际开发中广受欢迎。</p>
<p>​	通过合理设计和优化，策略模式能够很好地实现<strong>高内聚、低耦合</strong>的设计目标，帮助我们构建更易维护、更具扩展性的系统。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2024/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​	为请求创建一个接收者对象的链。该模式使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连接成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>​	责任链模式其实在现实生活中非常的常见，最简单的一种架构就是一个公司中对于一个员工提出的需求的处理。就比如，这个员工可能会想要加薪，可能要请假，可能想辞职。总总这些，都是员工的一些可能的行为，在提出这些需求后，员工会将这些需求提交给他的上级。就比如他的部门的老大。</p>
<p>​	他部门的老大会看当前他是否存在权利能够处理当前提出的需求，就比如如果一个员工想要请个小假，这种权利一般来说一个部门老大还是有的，相反，如果员工想要的是进行升职加薪这种，那对应的部门老大这个层级是没有权利去审批这事的。那么，我们先不去考虑哪种请求会被吞的情况。</p>
<p>​	一般情况下，如果一个层级的人物没有权利去处理下一级传递上来的请求，那么这个请求将会被当前任务再次提交给上级，在这种情况下，这个相对的上级还会去考虑当前自己是否有权利去处理这件事，然后做出抉择，我是需要去进行当前时间的审批处理还是我仍然没有权利去处理这件事而导致再次的往上去传递信息。这种不对的递归往上传递信息，直到信息被处理后再进行返回的结构，就是责任链模式的一种实例。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>​	可以想象到，在责任链模式中，我们不应该存在一个信息没有被处理的情况，在现实中也是如此，在生活中，一个公司的最上层应该拥有着对于下面的所有请求的处理权限，在这里也是如此。当然，在责任链模式中不同的是，现实中你可能会看到上层去处理一些下层处理的是，但是在责任链模式中，这种行为是不被允许的。</p>
<p>​	你可以把责任链模式看做一层层的筛网，每层筛网的大小不同，会筛去符合当前权限的事件，如果当前筛网上还存在着时间没有处理，那么这些时间就会被转移到下一层筛网进行处理，直到所有的事件都被处理。这种对于事件的处理机制，才是责任链模式的核心。</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2024/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/image-20241228094455900.png" alt="image-20241228094455900"></p>
<blockquote>
<p>​	这里使用了我看的课的一个UML类图，这个类图中的职责其实已经写的很清楚了，都看到行为性模式了你自己也应该看的懂这个类图了，这里就简单过一遍就行。</p>
</blockquote>
<p>​	</p>
<h3 id="AbstractManager类"><a href="#AbstractManager类" class="headerlink" title="AbstractManager类"></a>AbstractManager类</h3><p>​	这个类是我们全部责任链上的类的基类，可以看到，这个类中定义了一系列的方法来进行我们责任对象的行为规定。其中的函数我们不需要去进行详细了解，我们来抽象俩个在这个抽象类中必不可少的几个属性。</p>
<h4 id="抽象成员指针"><a href="#抽象成员指针" class="headerlink" title="抽象成员指针"></a>抽象成员指针</h4><p>​	在责任链模式中，对于链上的每一个元素，我们至少要提供一种能够往上去传递信息的方法，在这里我们就是通过一个成员指针来实现它的链式结构来实现的，通过这个成员指针，我们将能通过这个成员指针去递归的进行信息的处理，还是那个问题，有些操作是无法再UML类图上展示出来的，还是得等到之后的代码去进行分析。</p>
<h4 id="信息处理api"><a href="#信息处理api" class="headerlink" title="信息处理api"></a>信息处理api</h4><p>​	在每个管理层中，都应该存在能够处理下层传递的api接口，在这里面你其实也很清楚它到底是谁，这里就不再赘述。这里使用了枚举变量来进行我们处理信息的一次分类，这个无所谓，你但可以使用自己的一套数据来进行识别。</p>
<h3 id="实例子类"><a href="#实例子类" class="headerlink" title="实例子类"></a>实例子类</h3><p>​	这里面的系列抽象子类其实没有什么分析的价值，在这里面，对于具体子类，其实就是继承了父类的方法并且进行了一些对于自己信息处理的特化。唯一优点讨论价值的就是它的责任链的构建，每个子类都只关注与它联系的上一层的子类的指针，对于其他的层次，子类并不关注。</p>
<blockquote>
<p>对于请求发出类，这里就不再进行分析了，没意思。</p>
</blockquote>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">RequestType</span> &#123;</span><br><span class="line">    Leave,       <span class="comment">// 请假</span></span><br><span class="line">    Raise,       <span class="comment">// 加薪</span></span><br><span class="line">    Resignation  <span class="comment">// 辞职</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">    RequestType type;</span><br><span class="line">    std::string description;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Request</span>(RequestType t, <span class="type">const</span> std::string&amp; desc) </span><br><span class="line">        : <span class="built_in">type</span>(t),	 <span class="built_in">description</span>(desc) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这里就是一些属性的抽离定义了，没什么好说的。</p>
<h3 id="抽象处理者"><a href="#抽象处理者" class="headerlink" title="抽象处理者"></a>抽象处理者</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::shared_ptr&lt;Handler&gt; next; <span class="comment">// 下一个处理者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Handler</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNext</span><span class="params">(std::shared_ptr&lt;Handler&gt; nextHandler)</span> </span>&#123;</span><br><span class="line">        next = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canHandle</span>(request)) &#123;</span><br><span class="line">            <span class="built_in">processRequest</span>(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next) &#123;</span><br><span class="line">            next-&gt;<span class="built_in">handleRequest</span>(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;请求未被处理：&quot;</span> &lt;&lt; request.description &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">canHandle</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	可以看到，在这个处理者中，我们定义了一系列的抽象方法提供使用，其他的没什么意思，主要是这个处理请求的函数。</p>
<p>​	在这个处理函数中，我们会先去考虑当前是否存在权限去进行处理，如果有就直接处理并且返回。如果没有权限，那么就去递归调用责任链条中的下一层角色，直到被返回为止。</p>
<p>​	理论上，一定是存在角色能够处理我们这个事件的。当然，如果你输入的是一个额外的请求，不符合我们规定的请求，那抱歉，我们将无法处理，并且将会一直返回到底。</p>
<h3 id="具体处理者"><a href="#具体处理者" class="headerlink" title="具体处理者"></a>具体处理者</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体处理者：部门主管</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Supervisor</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandle</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.type == Leave;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;主管批准请求：&quot;</span> &lt;&lt; request.description &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者：部门经理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandle</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.type == Raise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;经理批准请求：&quot;</span> &lt;&lt; request.description &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者：CEO</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CEO</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandle</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// CEO可以处理所有请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CEO批准请求：&quot;</span> &lt;&lt; request.description &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这一个就更没有什么好说的了，就是一些具体的处理逻辑而已。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建责任链</span></span><br><span class="line">    <span class="keyword">auto</span> supervisor = std::<span class="built_in">make_shared</span>&lt;Supervisor&gt;();</span><br><span class="line">    <span class="keyword">auto</span> manager = std::<span class="built_in">make_shared</span>&lt;Manager&gt;();</span><br><span class="line">    <span class="keyword">auto</span> ceo = std::<span class="built_in">make_shared</span>&lt;CEO&gt;();</span><br><span class="line"></span><br><span class="line">    supervisor-&gt;<span class="built_in">setNext</span>(manager);</span><br><span class="line">    manager-&gt;<span class="built_in">setNext</span>(ceo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建请求</span></span><br><span class="line">    <span class="function">Request <span class="title">leaveRequest</span><span class="params">(Leave, <span class="string">&quot;请假一天&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Request <span class="title">raiseRequest</span><span class="params">(Raise, <span class="string">&quot;加薪申请&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Request <span class="title">resignationRequest</span><span class="params">(Resignation, <span class="string">&quot;辞职申请&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试责任链</span></span><br><span class="line">    supervisor-&gt;<span class="built_in">handleRequest</span>(leaveRequest);</span><br><span class="line">    supervisor-&gt;<span class="built_in">handleRequest</span>(raiseRequest);</span><br><span class="line">    supervisor-&gt;<span class="built_in">handleRequest</span>(resignationRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这个也没有什么好说的，主要来看这里的日志输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\ASUS\Desktop\CS\CS_STUDY\designPattern\19-责任链模式&gt; .\test.exe</span><br><span class="line">主管批准请求：请假一天</span><br><span class="line">经理批准请求：加薪申请</span><br><span class="line">CEO批准请求：辞职申请</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	可以看到，这里是正确的处理了我们提出的请求的，所以，可以看到，这种模式的作用也就在这。通过对于上层权利的不断下发，当然，上层还是保留着对应的权利的，可以实现在多个环节对于信息的处理，我们可以在各个环节中去细化信息处理的细节而不去影响其他环节上的代码。这种分包式的设计，使得各个环节上的功能更加容易扩展，同时也遵守了开放封闭原则。</p>
<h2 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h2><p>责任链模式（Chain of Responsibility）是一种行为设计模式，其核心意义在于通过<strong>链式传递的方式解耦请求的发送者和处理者</strong>，从而实现系统的灵活性和可扩展性。</p>
<p>以下是责任链模式的具体意义：</p>
<hr>
<h3 id="1-降低耦合性"><a href="#1-降低耦合性" class="headerlink" title="1. 降低耦合性"></a>1. <strong>降低耦合性</strong></h3><ul>
<li>责任链模式通过将请求的发送者和具体处理者分离，使二者之间不再直接关联：<ul>
<li>发送者只需要将请求传递给链的起始节点，无需关心请求最终由谁处理。</li>
<li>每个处理者只需关注自己的能力范围，并决定是否处理或将请求传递给下一个处理者。</li>
</ul>
</li>
<li>这种分离提高了系统的模块化，使得代码更易于维护。</li>
</ul>
<hr>
<h3 id="2-增强灵活性"><a href="#2-增强灵活性" class="headerlink" title="2. 增强灵活性"></a>2. <strong>增强灵活性</strong></h3><ul>
<li>可以动态地调整链中的处理者以及处理顺序，而不会影响其他部分：<ul>
<li>通过新增处理者类实现新功能。</li>
<li>通过重组链条调整优先级或职责分配。</li>
</ul>
</li>
<li>在运行时可以改变链的结构，从而适应不同的需求场景。</li>
</ul>
<hr>
<h3 id="3-实现职责分离"><a href="#3-实现职责分离" class="headerlink" title="3. 实现职责分离"></a>3. <strong>实现职责分离</strong></h3><ul>
<li>每个处理者只关注自身的业务逻辑：<ul>
<li>将单一职责原则（SRP）落实到代码中，避免将多个职责耦合到一个类中。</li>
<li>每个类的职责单一，易于测试和复用。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-支持请求的动态处理"><a href="#4-支持请求的动态处理" class="headerlink" title="4. 支持请求的动态处理"></a>4. <strong>支持请求的动态处理</strong></h3><ul>
<li><p>请求可以在责任链中</p>
<p>动态传递</p>
<p>，直到某个处理者能够处理它：</p>
<ul>
<li>无需显式指定处理者，由链上的逻辑决定。</li>
<li>这种动态决策使得请求的处理更加灵活。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-容错与扩展能力"><a href="#5-容错与扩展能力" class="headerlink" title="5. 容错与扩展能力"></a>5. <strong>容错与扩展能力</strong></h3><ul>
<li>如果请求无法被任何处理者处理，可以通过链末端的逻辑提供默认处理方案或报错机制：<ul>
<li>避免请求被丢弃或未响应的情况。</li>
</ul>
</li>
<li>责任链模式支持扩展，例如添加一个新的处理者以处理特殊的请求，而不影响现有链条。</li>
</ul>
<hr>
<h3 id="6-现实中的类比"><a href="#6-现实中的类比" class="headerlink" title="6. 现实中的类比"></a>6. <strong>现实中的类比</strong></h3><ul>
<li><p>责任链模式的意义也体现在现实场景中</p>
<p>，例如：</p>
<ul>
<li><strong>公司审批流程</strong>：如请假申请，会从部门主管到经理再到CEO逐级审批。</li>
<li><strong>技术支持系统</strong>：用户请求会先经过一级客服，若无法处理则转给二级客服，直至请求被解决。</li>
</ul>
</li>
</ul>
<p>这种模式将复杂的职责分配抽象为“链式传递”，使流程自然且易于理解。</p>
<hr>
<h3 id="使用责任链模式的场景"><a href="#使用责任链模式的场景" class="headerlink" title="使用责任链模式的场景"></a>使用责任链模式的场景</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ol>
<li>多个处理者可以处理同一类请求，但实际处理者不确定：<ul>
<li>如权限校验、事件分发等。</li>
</ul>
</li>
<li>请求的处理逻辑需要解耦，避免硬编码依赖：<ul>
<li>如日志处理、UI事件处理等。</li>
</ul>
</li>
<li>需要灵活的责任分配和动态调整：<ul>
<li>如任务分发系统、策略模式的动态实现。</li>
</ul>
</li>
</ol>
<h4 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a><strong>不适用场景</strong></h4><ol>
<li>处理链过长且复杂：<ul>
<li>过多的处理者可能导致性能下降。</li>
</ul>
</li>
<li>请求需要明确的唯一处理者：<ul>
<li>如果明确知道请求由哪个处理者完成，则责任链模式可能不适合。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>责任链模式的意义在于通过链式传递，将职责分离、降低耦合，同时提高灵活性和可扩展性。它在解决复杂的职责分配问题时表现出色，尤其是在处理多层审批、事件分发等场景中，使得系统结构更清晰、更易于维护。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2024/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>​	</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​	<strong>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请 求排队或者记录请求日志，可以提供命令的撤销和恢复功能</strong>。</p>
<h2 id="粗略理解"><a href="#粗略理解" class="headerlink" title="粗略理解"></a>粗略理解</h2><p>​	奇怪，我对于这个命令模式就是有点疑惑，我就是不知道它到底是一个什么情况。让我简单先敲一遍，兴许就能理解问题了。</p>
<p>​	先举一种简单的现实生活中的命令模式来进行理解。就是餐馆的一个点餐系统。在现实生活中，你需要去思考你到底要选择那一道菜，然后你需要去考虑把你选择的这些个菜单送给服务员，然后服务员会将这些菜送给后厨，然后用户就只需要等待。</p>
<p>​	但是我们有没有考虑过没有服务员这种情况呢，如果没有服务员，我们就需要去直接与后厨进行对接。这想想都不现实对吧。在程序设计中，这其实也是一种哲学。当我们程序设计得在用户实现一个功能直接调用底层的api时，这种设计是极其糟糕的。当然我这句话的描述有点问题，主要就是这里的用户是指使用设计好的程序的用户，而不是程序设计阶段的。</p>
<p>​	这种没有服务员的情况其实就是一种用户请求与具体实现之间的强耦合。再举一个甲乙方的例子来看。当甲方下发一个需求的时候，具体的乙方一般是不会看到这个甲方来直接去找到对应的员工来实现对应的功能的。相反，我们通常是把这个命令发送给乙方的对接部门，然后通过一些处理，这些命令会被分包并且下发给对应的实现部门。</p>
<p>​	我好像有点理解了。所谓的命令模式，要实现的就是一个命令发出者与命令实现之间的一个解耦。这时就需要我们去进行在中间的一层代理，在点餐系统中这是服务员。在项目对接中这个可能是项目经理。但是不变的是，在这种对接中，我们解开了命令发出者和命令执行者之间的强耦合。</p>
<p>​	通过这种解耦，客户将不用去后厨直接找到对应的厨师进行下单。只需要更具餐馆的规范去进行我们需求的发出，服务员负责添加这些需求到对应的列表中，而服务员接下来还负责将这些个需求按一定顺序发送给对应的后厨部门进行完成，这种分层式的设计使得用户不再需要去了解底层复杂的东西，只需要去了解餐馆提供的简单的菜单即可，其他的逻辑由下面的命令转发者和命令执行者进行操作。</p>
<p>​	到这里我其实明白了之前的误解。在理解命令模式中，不要在一开始就想得太多。类似与服务员这种消息转发者能够处理一些非常简单的消息转发，就比如用户想要那道菜，服务员就通知后厨做那道菜。除此之外，用户可能还会点套餐，这是一套复杂的命令，可能需要多个处理动作配合使用，这个也是服务员这个中间层需要做的事，但是一开始我们并不需要去拘泥在这里，可以从简单的地方出发。</p>
<p>​	还有，当我们需要添加菜单时，我们至少也需要去为对应的后厨添加对应的处理动作，这也是我之前存在疑惑的地方，不过现在也解开了一点了。</p>
<blockquote>
<p>总的来说，我现在感觉命令模式的核心在于:命令的处理与转发，通过引入一个具有转发行为的类来进行解耦</p>
</blockquote>
<p>在最简单的命令模式中，这个转发可以是一个不做任何处理的转发，其他复杂情况再说，现在先从简单的入手。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>​	在我看来，理解命令模式中，去看代码甚至比看UML类图更加重要。至少我第一次看的视乎类图根本看不懂它在说什么。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Receiver: 后厨</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Kitchen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareDish</span><span class="params">(<span class="type">const</span> std::string&amp; dish)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Kitchen is preparing: &quot;</span> &lt;&lt; dish &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Command: 命令接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Command</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteCommand: 具体命令类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrepareDishCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Kitchen* kitchen;</span><br><span class="line">    std::string dish;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrepareDishCommand</span>(Kitchen* k, <span class="type">const</span> std::string&amp; d) : <span class="built_in">kitchen</span>(k), <span class="built_in">dish</span>(d) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        kitchen-&gt;<span class="built_in">prepareDish</span>(dish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这里的几个类就是命令模式中的基本单位:命令的基本构成。在一个具体的命令中，需要包含这个命令具体的执行部门，所以这里保留了一个后厨的一个指针，用于进行执行部门的指定。我猜想，如果在后期需要对这个后厨部门进行划分，会将这个执行部门进行派生，至于继承还是聚合组合，那不是我们现在考虑的问题。</p>
<h3 id="转发者"><a href="#转发者" class="headerlink" title="转发者"></a>转发者</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Invoker: 服务员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Waiter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Command&gt;&gt; orders;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">takeOrder</span><span class="params">(std::shared_ptr&lt;Command&gt; command)</span> </span>&#123;</span><br><span class="line">        orders.<span class="built_in">push_back</span>(command);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; order : orders) &#123;</span><br><span class="line">            order-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        orders.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	可以看到，这里的转发者维护了一个命令队列，所有的客户给出的命令将会储存在这个队列中。我们还可以观察到这里的命令实际执行情况，其实就是一次程序控制流的转移，将当前的执行权限交给命令类进行自我的执行来实现对应的功能。</p>
<p>​	这里当然还可以进行一系列的扩展，就比如进行消息的撤销等操作，可以自行添加。</p>
<p>​	总的来说，这里的转发类重要的是这里的命令处理方法。通过储存客户端发出的所有命令，在适当的时机通过自身设定的命令执行顺序来进行对应的执行。而这里的执行，就跟很多设计模式一样，实际上就是进行一次程序控制流的转移，将程序控制流从当前的中转类转移到对应的命令处理程序中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client: 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建接收者</span></span><br><span class="line">    Kitchen kitchen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建具体命令</span></span><br><span class="line">    <span class="keyword">auto</span> steakCommand = std::<span class="built_in">make_shared</span>&lt;PrepareDishCommand&gt;(&amp;kitchen, <span class="string">&quot;Steak&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> pastaCommand = std::<span class="built_in">make_shared</span>&lt;PrepareDishCommand&gt;(&amp;kitchen, <span class="string">&quot;Pasta&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建调用者</span></span><br><span class="line">    Waiter waiter;</span><br><span class="line">    waiter.<span class="built_in">takeOrder</span>(steakCommand);</span><br><span class="line">    waiter.<span class="built_in">takeOrder</span>(pastaCommand);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务员发送订单</span></span><br><span class="line">    waiter.<span class="built_in">sendOrders</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里其实就没有什么好说的，需要注意的是，在命令模式中，我们需要在程序一开始进行所有的命令的初始化，之后我们所有发出的命令本质上其实就是保留了一份对应的指针。当然，你可以在每次调用时都进行副本的一次创建，不给你也应该知道这种模式的坏处。</p>
<p>下面给出一个不是很美的UML类图，我自己都没去看()</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2024/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/d99bb4bb90aeefcc2db7233d91cc5a2c.png" alt="img"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2025/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​	用一个中介对象来封装一系列的对象交互。中介者使得各对象不需要显示的相互引用，从而是其耦合松散，而且可以独立地改变他们的交互。</p>
<span id="more"></span>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>​	其实这个中介者模式也相对来说比较好理解。重点就是在<strong>中介者</strong>者三个字上。</p>
<p>​	还是举现实中的例子进行分析，最直观的就是现实中的房产中介。通过房产中介，我们可以去看到一系列的房子的信息，即使我们并不了解这些个房子之后真正的售卖者。我们只需要通过这些个房产中介，就可以完成对于一个房产信息的了解，一个房子的购买等。总的来说，这个其实就是对于买房和卖房者这俩方之间的一处解耦合。这种解耦合的目的也十分明确，就是我们想让我们买房是不必依赖于卖房的一方。</p>
<p>​	通过房产中介这一角色，卖房一方可以将其的信息交由中介来进行管理，只需要付出相应的代价即可。同时，买房的一方也不再需要去直接联系卖房的一方，省去了很多寻找的功夫，只需要去了解中介提供的统一接口即可。同时，对应的也需要付出相应的代价。在现实生活中，这些个代价一般都是钱，那么在程序设计中，这个代价对应的就是我们的类的一定的访问权限。</p>
<p>​	如果我们对于这些角色间的关系使用连线来表示的话你应该就能够很清晰的了解这个关系的作用，在使用中介者模式之前，我们每个卖房者和买房者之间都有一条联系进行连接，这样的情况下双方角色一多就会出现一个非常复杂的关系网。如果改用中介者模式呢。在中介者模式下，我们在卖房者和买房者之间添加了一层缓冲，双方都可以通过这一层去进行与另一方的联系而不必要去直接联系，可以预见的是，在这种情况下，我们的结构图将会变得更加简洁明了。双方的联系只会连接到中介者这一端，有中介者这个节点进行各个连线之间的调度，控制连线之间的双边关系。</p>
<p>​	在这种架构下，双方不需要去了解相互之间到底应该怎么进行沟通，只需要了解这个中介公司的要求即可，通过这个中介的接口，可以实现对于自身的一定程度上的委托，有这个中介来进行自身的一定的管理。</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>​	当然，这种架构本身也存在着一些缺陷，这个我们应该也能够简单的理解。就现实情况而言，当你想要通过一个中介想把自己的一定信息挂上，你需要考虑什么？最直接的就是我要做的手续吧，然后呢，就是我使用这个中介平台的代价吧。这个手续在程序中的直观体现就是我们实现中介功能的这个类吧。如果一个类绑定到对应的中介类中的步骤太麻烦，那么是否绑定就需要斟酌一下了。</p>
<p>​	除此之外，还有什么？我们是否需要考虑一下我们使用这个中介类的代价，在程序中的体现就是我们这个中介类对于其所管理的类的访问权限，如果这个中介类需要的权限太多，那我们是否进行托管也需要考虑考虑吧。在程序设计中，这个的直观体现就是我们的中介类的设计复杂度，当我们的中介类包含了很多操作的时候，势必就需要使用对应的信息，但是是否暴露这些信息是由对应的角色决定的。</p>
<p>​	总的来说，中介模式的使用，需要权衡当前需要的功能及对应的中介类的代价，选择符合自己当前需求的方案，当然，这句话说了就等于没说，自己用用才能体会。</p>
<hr>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/2025/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/image-20250104095044211.png" alt="image-20250104095044211"></p>
<p>这里的UML类图其实很清晰了，我们来进行一下简单的分析</p>
<p>​	首先，我们需要明确一下再这个类图。在这个类图中，存在着俩个抽象基类，这俩个抽象基类代表的就是我们前面说过的使用中介的对象和作为中介的对象。这里的抽象Country就是我们的抽象使用者，而MediatorOrg就是我们的抽象中介者类对象。</p>
<h3 id="抽象使用者Country类"><a href="#抽象使用者Country类" class="headerlink" title="抽象使用者Country类"></a>抽象使用者Country类</h3><p>​	这个类中其实很经典，主要就是定义了一些我们的具体使用者的一些接口，定义了一些接口规范，本质上其实也没有什么好说的。可以看到的是，在这个抽象对象中，保留了一个对于我们中介类的一个指针获取对应的中介类的接口使用权限(这里打错了，将就着看就行)。</p>
<p>​	通过这个接口，我们可以去看到对应的中介者类给我们提供的行为，接下来就看这个类。</p>
<h3 id="抽象中介者MediatorOrg类"><a href="#抽象中介者MediatorOrg类" class="headerlink" title="抽象中介者MediatorOrg类"></a>抽象中介者MediatorOrg类</h3><p>​	这个类也没什么好说的，主要就是包含了一个成员用于使用当前中介类的成员的注册，这个map包含了所有的成员相关信息，没什么好说的。这里主要的就是一个通知函数，但是在UML类图中去看一个函数的实现是不现实的，这个留到等下的代码实例中去分析。只需要注意的是，在这些个中介者类中，包含了一些用于连接的双方进行通信的一些方法。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><pre><code> 中介者模式的代码其实很简单，我也没有什么分析的欲望，自己看一遍也基本了解架构了，毕竟已经到了设计模式的相对后期了，一些简单的我就不想再进行一遍遍的分析了，之后碰到有意思的再来吧。
</code></pre>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> string&amp; message, <span class="type">const</span> string&amp; sender)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addUser</span><span class="params">(<span class="type">const</span> shared_ptr&lt;<span class="keyword">class</span> Colleague&gt;&amp; user)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Mediator</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象同事类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">    shared_ptr&lt;Mediator&gt; mediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Colleague</span>(<span class="type">const</span> string&amp; name, shared_ptr&lt;Mediator&gt; mediator)</span><br><span class="line">        : <span class="built_in">name</span>(name), <span class="built_in">mediator</span>(std::<span class="built_in">move</span>(mediator)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">receiveMessage</span><span class="params">(<span class="type">const</span> string&amp; message, <span class="type">const</span> string&amp; sender)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot; received message from &quot;</span> &lt;&lt; sender &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">        mediator-&gt;<span class="built_in">sendMessage</span>(message, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Colleague</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h3 id="具体类"><a href="#具体类" class="headerlink" title="具体类"></a>具体类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatRoom</span> : <span class="keyword">public</span> Mediator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;shared_ptr&lt;Colleague&gt;&gt; users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> string&amp; message, <span class="type">const</span> string&amp; sender)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user-&gt;<span class="built_in">getName</span>() != sender) &#123;  <span class="comment">// 消息不发回给发送者</span></span><br><span class="line">                user-&gt;<span class="built_in">receiveMessage</span>(message, sender);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addUser</span><span class="params">(<span class="type">const</span> shared_ptr&lt;Colleague&gt;&amp; user)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        users.<span class="built_in">push_back</span>(user);</span><br><span class="line">        cout &lt;&lt; user-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; joined the chat room.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> : <span class="keyword">public</span> Colleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>(<span class="type">const</span> string&amp; name, shared_ptr&lt;Mediator&gt; mediator)</span><br><span class="line">        : <span class="built_in">Colleague</span>(name, mediator) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> string&amp; message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot; sends message: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">        mediator-&gt;<span class="built_in">sendMessage</span>(message, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> chatRoom = <span class="built_in">make_shared</span>&lt;ChatRoom&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> alice = <span class="built_in">make_shared</span>&lt;User&gt;(<span class="string">&quot;Alice&quot;</span>, chatRoom);</span><br><span class="line">    <span class="keyword">auto</span> bob = <span class="built_in">make_shared</span>&lt;User&gt;(<span class="string">&quot;Bob&quot;</span>, chatRoom);</span><br><span class="line">    <span class="keyword">auto</span> charlie = <span class="built_in">make_shared</span>&lt;User&gt;(<span class="string">&quot;Charlie&quot;</span>, chatRoom);</span><br><span class="line"></span><br><span class="line">    chatRoom-&gt;<span class="built_in">addUser</span>(alice);</span><br><span class="line">    chatRoom-&gt;<span class="built_in">addUser</span>(bob);</span><br><span class="line">    chatRoom-&gt;<span class="built_in">addUser</span>(charlie);</span><br><span class="line"></span><br><span class="line">    alice-&gt;<span class="built_in">sendMessage</span>(<span class="string">&quot;Hi everyone!&quot;</span>);</span><br><span class="line">    bob-&gt;<span class="built_in">sendMessage</span>(<span class="string">&quot;Hello Alice!&quot;</span>);</span><br><span class="line">    charlie-&gt;<span class="built_in">sendMessage</span>(<span class="string">&quot;Hey folks!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到其实真的是没有什么意思的，风紧扯呼，主要是很多的其实之前都有接触过，就不再赘述了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>中介者模式（Mediator Pattern）</strong> 是一种行为型设计模式，通过引入一个中介对象来封装多个对象之间的交互，从而降低对象之间的直接耦合性。对象不再直接引用或依赖彼此，而是通过中介者协调和管理它们的交互逻辑。</p>
<h4 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a><strong>核心要点</strong></h4><ul>
<li><strong>解耦</strong>：中介者模式将对象间的交互集中到中介者，避免了对象之间的直接依赖。</li>
<li><strong>灵活性</strong>：通过修改中介者，可以改变交互规则而不需要影响具体对象。</li>
<li><strong>复杂性转移</strong>：系统交互的复杂性由对象转移到了中介者，中介者可能会变得复杂。</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul>
<li>系统中对象之间存在复杂的多对多交互。</li>
<li>希望通过一个中心化的管理者来简化对象之间的关系。</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><ul>
<li>优点：<ul>
<li>降低类间耦合，提升系统可维护性和可扩展性。</li>
<li>将交互逻辑集中到中介者，便于管理。</li>
</ul>
</li>
<li>缺点：<ul>
<li>中介者可能变得复杂，容易成为“上帝对象”。</li>
</ul>
</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><ul>
<li>聊天室（所有用户通过聊天室交流）。</li>
<li>MVC 模式中，控制器作为中介者协调视图和模型的交互。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类图</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2-UML%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<p>UML类图是一个常用于面向对象程序设计的工具。用于图形化描述类的基本属性和类与类之间的关系。</p>
<p>类与类之间存在着5种关系。</p>
<span id="more"></span>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2-UML%E7%B1%BB%E5%9B%BE/1.jpeg" alt="1"></p>
<p>对于一个类的类图构造，有几个规则，直接上例子吧。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2-UML%E7%B1%BB%E5%9B%BE/2.jpeg" alt="2"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2-UML%E7%B1%BB%E5%9B%BE/3.jpeg" alt="3"></p>
<p>如图。首先，整个类图分为3块。</p>
<p>最上面一块为类名。这一块规则不多。如果你的类是一个可实例化的类，那么这个类名应该是正体字。相反，如果是一个虚类，那么这个类名就应该是一个斜体字。</p>
<p>第二块是类成员的区域。这一块有着一定的规范，一行的数据应该由(访问权限|成员名|:|类型名)组成。特殊的是，如果这个类成员是一个默认初始化的成员，那么需要在之后加上一个&#x3D;和对应的初始化对象。特殊的是，如果这个类成员是一个静态类成员，那么需要在这个成员处加上下划线进行标识。</p>
<p>来看一下我们访问权限的符号定义。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2-UML%E7%B1%BB%E5%9B%BE/4.jpeg" alt="4"></p>
<p>接下来进入第三个区域。这个区域是用于类成员函数的标识。基本组成结构是(访问权限|函数名|函数参数列表|:|函数返回值类型)。对于参数列表内部的组成，如果为空，那么()为空即可。若不为空，按照(参数名|参数类型)并按(,)分割的格式进行制作。特殊的是，如果这个成员函数是一个静态成员函数，那么需要加上一个下划线进行标识。如果是一个虚函数，那么需要写成斜体字，如果还是一个纯虚函数，那么需要在末尾加上一个&#x3D;0进行标识。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>UML类图</category>
      </categories>
      <tags>
        <tag>设计模式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>三个原则</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>接下来简单看一下类间的5种关系。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/1.jpeg" alt="1"></p>
<span id="more"></span>

<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/2.jpeg" alt="2"></p>
<p>每个类框的创建遵守之前的规则。而对于子类，我们可以看到这里只写出了子类重写的哪些函数(假设这些个子类没有额外的对象)。也就是说，对于子类来说，不需要对父类中的对象再进行描述，使用空心三角箭头就能表示继承关系并使得对应父类的成员不需要再被描述。</p>
<p>再来详细分析下，对于空心三角箭头，俩端分别连接父类和子类。其中，箭头指向的是父类，另一端连接的是子类。</p>
<p>接着来看到第二种类间关系，<strong>关联</strong>关系。</p>
<p>这种关系其实很常见，就是一个类中引用了一个类。这个类可能是别的类，也可能还是自身的类，依照引用关系和对象的不同存在多种关系。</p>
<p>1~单向关联关系</p>
<p>这种关系就是一个类中包括了另一个类(需要是一个与本类不同的类)，并且被包含的那个类不知道包含它的类的信息。父子或母子之类的关系的类建模</p>
<p>使用带箭头的实线进行连接</p>
<p>2~双向关联关系</p>
<p>这种关系就是一个类中包括了另一个类(需要是一个与本类不同的类)，被包含的类中也包含了包含它的类。学生与老师的类建模抽象。</p>
<p>使用不带箭头的实线进行连接</p>
<p>3~自关联关系</p>
<p>这种关系就是一个类中包含了指向本身同一种类的引用。就比如树的节点类。</p>
<p>使用指向自身的带箭头线进行连接。</p>
<p>当然，总总这些绘图线段都不是一定的，取决于使用的绘图软件。</p>
<p>接下来看下一种关系	<strong>聚合</strong>关系</p>
<p>这个关系乍看起来有点抽象。其实可以通过教室和学生，图书馆和藏书间的关系辅助理解。一个教室中可能会有多个学生，图书馆中也包含着系列藏书。这俩者之间构成了一个聚合关系。</p>
<p>对于聚合关系，就比如教室和学生这种。我们需要理清下这俩者之间的关系。无论教室还是学生，都是可以独立存在的，但是吧，教室中没有学生这些对象的话，其实是没有存在的意义的。对于独立存在的学生，不同于教室，他们独立存在是有着自己的意义的。从某种意义上这个也可以成为识别聚合关系的一种方法。	同时，这些聚合关系中，拥有的对象通常不只有一个。就比如教室中的学生，数量通常都是多个。在这种架构下，我们去取出其中的一个学生对于教室这个整体其实是没有很大影响的，当然这得是在一种至少不是很少的情况下的。你如果要说只有几个学生的这种情况我也无话可说。</p>
<p>以一种C++的类来看吧，如果一个类中包含了多个别的类的数组，当我们对这个主类进行析构的时候，这些个包含的子类并没有被析构的话，可以看做这些类之间是一种聚合的关系。</p>
<p>在这里我其实对聚合关系和关联关系有点疑惑。不过可以这么理解，类间关系是不一定存在一种的。或者说，类间关系是由类的属性而产生的，而不是由类间关系而产生的类。聚合关系某种程度上可以看做是关联关系的子类。聚合关系一定是关联关系，但是关联关系不一定是聚合关系。</p>
<p>如果类间是一个聚合关系，那么这些类之间应该使用空心菱形的直线进行连接。菱形与聚合的整体相连，另一端与对应的部分相连。</p>
<p>举出一个聚合类型的例子</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/3.jpeg" alt="3"></p>
<p>接下来看另一种关系	<strong>组合</strong>关系</p>
<p>使用实心菱形线段进行标识组合关系。与上相似故略过</p>
<p>组合关系也是一种整体和部分的关系。很多方面它跟聚合关系都很相似。但是这里相对于聚合关系不同的是，这里的部分其实是依赖于整体而存活的，当主对象被析构时，这个组合关系的部分类不应该还存活着。举个例子，就比如头和嘴巴，眼睛，眉毛等。后面的部分在整体消失时不应该还存在(你杠就是你对)。</p>
<p>这样看来，通过组合关系联系的各个类相对于聚合关系有着更为紧密的联系。以C++的视角来看的话，就是当组合关系中的整体类被析构的时候，它对应的部分类也应该被析构掉。</p>
<p>接下来来看类与类之间最弱的一种关系	<strong>依赖</strong>关系</p>
<p>依赖关系的判断有点抽象。可以用排除法来进行。如果一个类既不是继承.关联.聚合.组合关系，那么它就是一个依赖关系。你可以看出这个关系有多弱了吧。</p>
<p>当然，还是有不通过排除法来进行判断的方法的</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/4.jpeg" alt="4"></p>
<p>当我们一个类使用了另外一个类作为本类的函数参数。在函数参数内使用了别的类作为本类函数的一个局部变量，一个类中调用了别的类的静态方法。这三种情况下，这些个类之间构成了依赖关系。当然，其实这个相较于排除法其实更难判断了。</p>
<p>依赖关系使用带线头的虚线进行标识，由依赖的一方指向被依赖的一方。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/5.jpeg" alt="5"></p>
<p>对于类图关系，类之间是可能存在多种关系的，但是我们不需要将全部关系都列出来，我们只需要将这些类关系中最强的关系描述出来就行了。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>UML类图</category>
      </categories>
      <tags>
        <tag>UML类图</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2025/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​	提供一个方法顺序·访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
<span id="more"></span>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>​	在我看起来迭代器出现的原因其实很简单，也很符合我们的单一职责原则。这个模式出现的原因，就是为了去解决一个数据结构中可能存在的数据遍历问题。</p>
<p>​	搓过数据结构的都知道，你只搓出数据的底层表示是远远不够的，你还需要提供一个或多个方法去进行这些个数据的查找，遍历等。在C++中的stl库中也是如此，所有的数据类型中都给我们提供了一系列的迭代器接口供我们去对数据进行查找和遍历等。而这些个查找和遍历所应用的设计模式，就是迭代器模式。</p>
<p>​	总的来说，一个迭代器模式的出现就是一个为了方便用户去进行使用的初衷，通过对于一个数据结构提供一个查询的接口，去避免用户自己去进行底层数据的遍历。</p>
<p>​	这是一个很朴素的哲学，一路过来，我们都尽量避免我们的底层数据能与用户直接接触，因为这种接触是不可控的，我们无法控制这种交由用户自己处理的行为是否会出现什么问题。因此，为了程序的稳定，同时也为了使我们的程序更加的智能，我们通常需要去为我们设计的东西添加尽可能多的接口而不是去暴露我们的数据。而且，你应该也有体会，当现有的就存在一些简便的方法时，你一般不会去在现有的方法上再去设计一个功能相似的方法，这也是设计模式的一种哲学。</p>
<h3 id="补充的哲学思考"><a href="#补充的哲学思考" class="headerlink" title="补充的哲学思考"></a>补充的哲学思考</h3><ol>
<li><strong>接口即契约</strong>：<br>提供一个迭代器接口，就是在告诉用户“这是访问数据的唯一正确方式”，从而规范了用户的行为。这种契约精神不仅使程序更稳定，也为团队协作和代码复用带来了极大的便利。</li>
<li><strong>从用户角度出发</strong>：<br>当你设计一个程序时，始终要考虑用户的使用体验。迭代器模式的核心出发点就是“如何让用户以最简单的方式访问数据”，这体现了优秀设计的以人为本。</li>
<li><strong>避免重复发明轮子</strong>：<br>一般来首现有的迭代器接口已经很好地解决了数据访问问题，因此通常不需要重复设计功能相似的接口。这种“站在巨人肩膀上”的思维不仅高效，也能让你的设计更加稳健。</li>
</ol>
<blockquote>
<p>对于迭代器模式存在的意义，我们已经基本了解了，接下来我们直接进入对应的UML类图和代码实现吧</p>
</blockquote>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="/2025/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20250101180051284.png" alt="image-20250101180051284" style="zoom:80%;">

<p>​	借用一个UML类图进行分析</p>
<p>​	对于一个迭代器模式，我们首先需要知道的是，其根本上是为了对于一个数据结构进行排序查找等方法的提供的。因此，我们需要一个数据结构作为我们的底子。在这里的UML类图中，我们使用一个双向链表作为示例。</p>
<h3 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h3><p>​	做过数据结构的就知道这个是用来干嘛的了，这里就不再进行赘述了</p>
<h3 id="MyList类"><a href="#MyList类" class="headerlink" title="MyList类"></a><strong>MyList类</strong></h3><p>​	这个类就是我们这个迭代器模式中的服务对象，就是我们的具体的数据结构。可以看到在这个类中，我们包含了一个计数用于标识这个数据结构中插入元素的数量，该包含了一个用户头结点和尾节点的指针用于这个链表的标识。</p>
<p>​	接下来看到这个类中的函数，其中很多都很常见，就不再赘述，主要看到这里的getIterator函数，这个函数返回一个指针，这个函数返回一个指针，这个指针指向一个迭代器。也就是说，这个函数就是一个我们进行迭代器调用的接口，通过这个接口，我们可以实现迭代器方法的调用。</p>
<p>​	当然，这种你爹带起的调用其实见仁见智，我觉得还存在一种调用方法就是直接在这个类中去进行一个迭代器的声明，利用组合或者聚合的关系进行构造，也可能再利用一种外观模式，将我们的这个数据模块和排序模块给封装起来实现我们的功能，当然，这里只是提出一种方法，具体的实现可以多种，虽然我自己也没搓过几个，见仁见智吧。在这里说这些知识我思维的一些发散罢了。</p>
<h2 id="Iterator类"><a href="#Iterator类" class="headerlink" title="Iterator类"></a>Iterator类</h2><p>​	这个类就是我们的迭代器类，这个类在设计中准备负责的功能就是实现我们的排序模块。可以看到，在这个类的成员中，包含了一个我们自己设计的一个链表，这个就是我们这个迭代器中赖以实现排序功能的基础。这里就不再赘述。另一个成员是一个用于标识当前指向的节点的地址，也没有什么分析的价值，看到成员函数吧。</p>
<p>​	在这里的成员函数中，大多都是一些抽象虚函数，由这些形成了多态体系，这里也不再多说，总的来说，这里的迭代器的组成还是相对来说比较简单的，不需要多么深入的剖析。</p>
<p>​	还可以看到，在这里的抽象基类底下，还有着几个相对独立的子类，这里分别是一种顺序遍历和逆序遍历的方法，这里也是对前面多态特性的一种补充，也没什么好说的。</p>
<p>​	总的来说，迭代器模式的UML类图相对来说比较简单，主要是看代码自己搓一遍熟悉流程，等到之后自己项目中去用一遍也就差不多了。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>​	进入代码分析之前，我们需要对一个C++性质进行一定的分析，其实我也有点忘了，之前学过就没有再拿起来用过。</p>
<h3 id="模版特性简析"><a href="#模版特性简析" class="headerlink" title="模版特性简析"></a>模版特性简析</h3><p>​	使用template <typename t>或者template <class t>进行一个模版的声明，这个模版的名字是后面的这个指定的T。至于是typename还是class，这个是等价的无所谓。</class></typename></p>
<blockquote>
<p>​	一个模版声明的作用域是有限的，其只会在其最近的一个作用域中生效。</p>
<p>​	这里使用GPT总结版，写的很清楚。</p>
</blockquote>
<h4 id="1-模板的声明与定义"><a href="#1-模板的声明与定义" class="headerlink" title="1. 模板的声明与定义"></a>1. <strong>模板的声明与定义</strong></h4><p><code>template &lt;typename T&gt;</code> 声明的模板类型参数 <code>T</code> 的作用范围从声明开始，覆盖模板定义内的所有内容。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    T member; <span class="comment">// 这里的 T 是模板参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>T</code> 只在 <code>MyClass</code> 的定义内有效，离开 <code>MyClass</code> 后 <code>T</code> 不再有意义。</p>
<hr>
<h4 id="2-嵌套作用域"><a href="#2-嵌套作用域" class="headerlink" title="2. 嵌套作用域"></a>2. <strong>嵌套作用域</strong></h4><p>如果模板参数声明出现在嵌套的作用域中（如嵌套类、成员函数等），模板参数的作用范围会受到进一步限制。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(U value)</span> </span>&#123;</span><br><span class="line">        T outerMember; <span class="comment">// 这里的 T 是 Outer 的模板参数</span></span><br><span class="line">        U innerMember; <span class="comment">// 这里的 U 是 func 的模板参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>Outer</code> 的定义中，<code>T</code> 是有效的。</li>
<li>在 <code>func</code> 的定义中，<code>U</code> 是有效的，但 <code>U</code> 的作用范围仅限于 <code>func</code> 的内部。</li>
</ul>
<hr>
<h4 id="3-局部模板参数的作用范围"><a href="#3-局部模板参数的作用范围" class="headerlink" title="3. 局部模板参数的作用范围"></a>3. <strong>局部模板参数的作用范围</strong></h4><p>局部模板参数的作用范围只限于其声明的具体位置。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T outerVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套的模板</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">innerFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        U innerVar; <span class="comment">// 这里的 U 是 innerFunction 的模板参数</span></span><br><span class="line">        T outerVarCopy = outerVar; <span class="comment">// 可以访问外部的 T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>innerFunction</code> 中，<code>U</code> 是局部模板参数，其作用范围仅限于 <code>innerFunction</code> 的定义。</p>
<hr>
<h4 id="4-特殊注意：模板的作用范围与嵌套"><a href="#4-特殊注意：模板的作用范围与嵌套" class="headerlink" title="4.特殊注意：模板的作用范围与嵌套"></a><strong>4.特殊注意：模板的作用范围与嵌套</strong></h4><p>在某些嵌套场景中，外层模板参数与内层作用域可能会产生冲突。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 这里的 T 会隐藏外层的 T</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处 T 指的是内层模板参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>method</code> 中，<code>T</code> 指的是方法的模板参数，而不是类 <code>Container</code> 的模板参数。这种情况下可能会导致混淆，需要注意命名的区分。</p>
<hr>
<h4 id="模版总结"><a href="#模版总结" class="headerlink" title="模版总结"></a>模版总结</h4><p><code>template &lt;typename T&gt;</code> 的作用范围确实是<strong>局部的</strong>，仅限于最近的声明和定义所在的作用域。如果有嵌套作用域，内层的模板参数会遮蔽外层的模板参数。这种规则确保了模板的灵活性，同时也要求在设计模板时小心命名冲突的问题。</p>
<blockquote>
<p>有了这个，我们可以来进行我们代码的分析了，启动!!!!!</p>
</blockquote>
<h3 id="通用迭代器类"><a href="#通用迭代器类" class="headerlink" title="通用迭代器类"></a>通用迭代器类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(T val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedIterator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* current;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SharedIterator</span><span class="params">(Node&lt;T&gt;* start)</span> : current(start) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> current != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = current-&gt;data;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>​	首先可以看到，我们使用一个模版来进行我们结构体Node的创建，这就使得我们最后的结构体基本能够兼容所有的基本数据类型，至于负责数据类型，可能还需要后续的更多调整。</p>
<p>​	额外多说一嘴，这里的结构体使用了构造函数，需要注意的是，这是cpp中的结构体有的特性，在c中是不存在的。</p>
<p>​	接下来看到我们的迭代器类，可以看到，我们的迭代器类也是使用了一个模版，在这个模版类中，我们还使用了一个模版结构体。这种嵌套需要我们在使用对应的嵌套结构体中去指定对应的类型，这里也是如此，通过将Node的类型指定为自身的模版T实现了一种模版范围的衍生，提高了扩展性。</p>
<p>​	接下来看到几个基类函数，这里就没有考虑去进行功能的扩展了，需要的话可以把这个类重新设计为一个ABC类再进行对应的设计，这里就不再展开了。可以看到，在这些个类方法中，提供了系列方法用于一些元素位置的查找，这里也不赘述，直接跳过。</p>
<h3 id="具体的数据结构类"><a href="#具体的数据结构类" class="headerlink" title="具体的数据结构类"></a>具体的数据结构类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedList</span>() : <span class="built_in">head</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(value);</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;T&gt;* <span class="title">getHead</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	对于这个十分简陋的链表，我其实没什么可说的，唯一需要注意一点的就是我们这里的链表插入使用的是一个头插法的插入规则。那几个想说的放在这里又不太合适，我们直接看接下来的测试程序吧。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;<span class="type">int</span>&gt; list1;</span><br><span class="line">    list<span class="number">1.</span><span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">    list<span class="number">1.</span><span class="built_in">add</span>(<span class="number">2</span>);</span><br><span class="line">    list<span class="number">1.</span><span class="built_in">add</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;<span class="type">int</span>&gt; list2;</span><br><span class="line">    list<span class="number">2.</span><span class="built_in">add</span>(<span class="number">4</span>);</span><br><span class="line">    list<span class="number">2.</span><span class="built_in">add</span>(<span class="number">5</span>);</span><br><span class="line">    list<span class="number">2.</span><span class="built_in">add</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复用通用迭代器</span></span><br><span class="line">    <span class="function">SharedIterator&lt;<span class="type">int</span>&gt; <span class="title">it1</span><span class="params">(list<span class="number">1.</span>getHead())</span></span>;</span><br><span class="line">    <span class="function">SharedIterator&lt;<span class="type">int</span>&gt; <span class="title">it2</span><span class="params">(list<span class="number">2.</span>getHead())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it<span class="number">1.</span><span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; it<span class="number">1.</span><span class="built_in">next</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it<span class="number">2.</span><span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; it<span class="number">2.</span><span class="built_in">next</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="复用分析"><a href="#复用分析" class="headerlink" title="复用分析"></a>复用分析</h4><p>​	这个其实也没有什么好说的，但是你看到的时候可能会为这种设计感到疑惑，就是说为什么要这么写。首先我们先来明确一下，在这段代码中的复用，指的是对于迭代器代码的复用，而不是对于迭代器这个类的复用。</p>
<p>​	理论上，你当然可以设计一些东西使得一个迭代器能够被多个类所使用，但是这样会存在一个问题，最直接的就是切换的问题，如果你来回的切换使用的对象而且你还需要保留上一次使用的记录，这会是非常麻烦的。再者，一个迭代器类被多个类所使用，如果不对呀迭代器进行严格的设计的话，这个迭代器类将会是线程危险的。</p>
<p>​	总的来说，为了避免总总的问题，我们的没一个迭代器，通常都是与一个对应的数据模块类所对应的，这样能减少很多的一个问题，而且由于迭代器类在设计上通常并不会有很多的类成员，大多都是一些api方法，所以这种开销是可以接受的。</p>
<p>​	</p>
<h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><p>​	在这段测试程序中，我们可以看到，这几个都是使用了相同的方法名，这样一看过去，我们其实就能够简单的理解这类函数存在的一些通用方法，这其实就减轻了我们的学习负担，就比如我们的stl库，当我们了解了其中的一个之后，我们去了解其他的类，其实发现他们都大差不差，很容易上手。而这里就是我们迭代器类，或者说，编程规范的一种优势所在，通过规范的编程来降低用户学习使用对应的api的难度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	总的看下来，迭代器模式其实没有什么好说的，主要就是我们如何去设计一个迭代器，一个数据模块中对于一个迭代器如何使用，用于如何使用数据结构提供的接口和在这之下的我们怎么去设计对应的数据结构下的数据模块和迭代器模块的配合。</p>
<p>​	这总的来说主要是一种实战的技能，可能会在之后去浅浅设计一个自己的vector类来进行熟悉吧。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>三个原则</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>对于所有的设计模式，无论思想是什么，都遵守三个基本原则：</p>
<p>单一职责原则，开放封闭原则，依赖倒转原则</p>
<span id="more"></span>
<p>对于这三个原则，与其说是设计模式所遵守的原则，不如规定为我们程序设计中应该遵守的原则。在程序设计中，即使我们对设计模式不是很清楚，但是如果我们设计过程中遵守这几个基本原则，那么设计出来的程序还是会很优雅的</p>
<p>首先来看到<strong>单一职责原则</strong></p>
<p>这个原则在应用场景中其实就是<strong>面向对象</strong>。这个原则注意的本质上就是在类的设计中让其负责的功能尽可能的专一，使得我们在设计过程中可以更加专注于特定功能的实现，能够减轻我们的设计压力和维护压力。</p>
<p>举个简单的例子吧，就比如不久前做的那个堆排序作业。其实现在看来heap类的设计是存在大问题的。这个类负责的功能太多了，它既负责了对于数据的对排序处理，又负责了对于堆排序的渲染。这就导致了我后期在debug时想要去找到对应的错误位置需要去找到整个类中存在的错误。而此时类简单看实现代码行数已经达到了小几百行。这是要去debug是极其不易的。确实有亲身体会。</p>
<p>因此，这个单一职责原则的目的就在于各个功能模块间的实现分离。通过这种分离，我们能够实现更加高效的设计和debug。就比如，当你数据构建层面出错就去找对应数据构建的类。当你渲染出现问题就去找对应渲染的类。同时类功能的分离也能提高代码的复用性。</p>
<p>就比如那个heap类，由于我们将渲染模块和数据模块都耦合到了一起，如果我们想要在这个项目中再去添加与现在的排序类相似的类，我们是无法复用现在已有类的渲染模块的。直接继承将是一个糟糕的注意。而且我们已有的渲染模块是基于heap类去设计的，即使我们想要cv，我们也得考虑新类的设计，这是代码低复用性的体现。相反，我们应该考虑的是一个隐藏实现细节的渲染类来进行各种排序的实现。让heap等排序类专注于数据层面的构建，通过设计出render等渲染类来实现对应的渲染动画。</p>
<p>因此，在我们设计类的时候，我们要尽可能的让类的功能尽可能的单一，通过不同类之间的配合再来实现复杂的功能而不是一股脑塞在一个类中。而且这在类的定义中也可以看出类的设计初衷就是让我们设计一个功能单一的类。类是一组相关属性和行为的集合。注意这里是一组而不是多组。我们在任何时候都不应该有万能的这个概念，毕竟这个概念是不符合我们的设计逻辑的。尽管用户层是希望一个万能，但是用户层的万能与底层的万能不能等效。</p>
<p>接下来看第二个原则	<strong>开放封闭原则</strong></p>
<p>其实这个原则就是<strong>单一职责原则</strong>的延续。简单来说，如果你的一个类很好的遵守了单一职责原则，换句话说这个类在一个功能上做到了极致，那么无论你添加什么这个类的功能都不会有什么改变。同时，你会发现如果一个类很好的遵守了单一职责原则，那么当出现新的需求时，仅仅依靠现在的类是无法解决的，那么现在就需要进行扩展，那么此时我们就有俩种方式来进行扩展。一种是直接修改我们现在的类去添加对应的功能，但是正如我们前面所说，这样其实是未被单一职责原则的。那么，内求失败后，我们需要外求。</p>
<p>既然外求，由于我们还是需要遵守单一职责原则，那么我们应该考虑实现一个新的类来实现我们新增的功能，而且一般来看这个类是需要和已有的一些类进行联动的。但是这个设计过程并不应该影响到已经设计好的类。在这个新增的类设计完成后，我们应该考虑把这个类和原先的类打包到另外一个大类中去实现。这种设计下，这个大类就对原有的功能进行了扩展，而且俩个小子类又都遵守了单一职责原则。</p>
<p>好，回来看看我们哪里体现了开放封闭原则。首先，我们实现了对已有功能的扩展，这是一种对于原有设计的开放性质的阐述。其次，我们并没有对原有的类进行修改，已完成的类是相对来说封闭的，这是封闭的性质。</p>
<p>这个封闭属性是相当重要的。毕竟如果一个类保留了它的封闭属性，那么它一般是通过了一定的测试，能够稳定运行的，如果我们去对这个类进行添加修改等破坏了它的封闭性，那么对于原有的哪些个用到封闭的类的api地方，又有可能导致一些奇奇怪怪的错误产生。而导致必须对整个类全部进行重新审核和测试。</p>
<p>举个例子吧，在现实中，我们通常可以看到一些男人在外部工作，不理家中事，但是家里还是被老婆打理的不错。这就是一个典型的开放封闭原则的示例。别杠，再杠让你飞起来。家庭是一个大类，这个大类中包含了一个负责家庭资金供给的父亲，一个负责家庭打理的母亲，还有其他一些杂七杂八的东西。种种这些相互独立，但是又组成一个整体。我们可以看做每个对象之间相互独立，但是多个对象构成了一个大类达到了一种和谐。</p>
<p>这个其实在QT中可以窥见。在QT中，其实已有的库可以视作一系列的具有封闭属性的库，我们在设计中要做的一般也是设计这些具有封闭性的类。然后，我们会在一些特别的类中，就比如，一个项目初始的窗口类中去进行这个小类的实例化与调用。这也是一种开放封闭原则的设计实例。</p>
<p>接着再来看一些需要注意的地方。就是即使我们实现了一些新的类，我们怎么去实现这些新的类与已有的类之间的联动。这里就需要我们在设计类是预留一些接口。这个接口一般来说是可以预见到的，就比如，商场的购物通常会有”打折”这种事情发生，可能是几折几折，也可能是买一送一等等，但是这些都有一个共性，就是他们都是”打折”这件事。因此，我们在设计商场购物的对应类中，我们应该预留一个专门的接口用于打折以实现以后可能存在的扩展。这个其实身边就能看到，就比如我们的笔记本，笔记本保留了相当多的插口供我们使用，而且一个插口可以使用不同的设备，只要这个设备的插口符合我们笔记本的接口规范。</p>
<p>这种接口的设计一般是通过<strong>多态</strong>的特性来进行实现的。在父类中去预留一个虚函数接口，当我们想要一个具体的打折方案后，我们去继承这个父类并对这个方法进行对应的重写，通过使用这个重写类去对父类进行替换，来实现我们打折方案的改变。而且由于继承这种关系，所以这些个父子类间的差异就在与这个重写的接口类处，不用太去担心冲突问题。</p>
<p>一般来说，这个接口是一个虚类的父类指针以提供该虚类的系列子类的指向。</p>
<p>这种<strong>开放封闭原则</strong>能够保证程序的可扩展性，可维护性，可复用性。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/1.jpeg" alt="1"></p>
<p>接下来看第三个原则，<strong>依赖倒转原则</strong>，话不多说，直接上图</p>
<p><strong>高层模块不应该依赖低层模块，二者都应该依赖于抽象；</strong></p>
<p><strong>抽象不应该依赖细节，细节应该依赖于抽象</strong></p>
<p>再解释下高层模块和低层模块。高层模块就是编写的应用程序，也就是应用层，这个你应该可以理解。接下来注意一点，我们要分析的是底层模块，而不是底层模块，所有位于高层模块下的模块都是低层模块。抽象基本就等价于C++中的抽象类以及各类的api。</p>
<p>举例下这里的直接依赖，就比如一个外卖系统中，通过使用一个数据库系统来实现数据的存储与使用，如果直接使用一个具体数据库的引用，那么这个就是直接依赖。而我们<strong>高层模块不应该依赖低层模块，二者都应该依赖于抽象</strong>的目的就是避免这种直接的绑定。你可以想象，你游戏账户直接绑定一个手机号，那么当你绑定的这个手机号出现了问题，你这个游戏账号将会导致一系列的问题，就比如我们无法去登录等。</p>
<p>而为了避免这种情况，我们的想法是通过一个中间层来进行缓冲，而这个的作用就是实现高层模块和底层模块的隔离，避免这俩者之间的直接调用。而且对于这个中间类(抽象类)需要有几个规定。最简单的一点就是这个函数必须在高层和底层的代码发生改动时不必要去修改另外一边的代码，起到所谓的隔离作用。通过这种隔绝，我们能够使得修改代码时只用去关心对应代码区域的修改而不用去关注全局代码的更改。</p>
<p>在使用时，我们一般是需要高层模块来使用这个抽象的api的，在c++中，这个就是所谓的虚函数。但是吧，一般来说，我们的这个抽象的父类是不会提供具体的实现也是不应该提供具体的实现的。需要在对应的子类中去进行具体的不同功能的划分与实现。</p>
<p>这个就比如吧，我们在进行一个项目的设计中，前期由于一些设计方面的问题，直接使用了mySQL数据库作为使用的数据库。但是在之后的发展中，由于数据的堆积，这个数据库无法满足我们的需求了，我们需要去替换一个更大的数据库，此时如果我们是直接调用的mySQL的数据库的话，那么我们在替换这个数据库的时候，我们需要去把全部用到mySQL的地方都进行更改，这个工作量是巨大且不可接受的，因为这个会导致前面已经通过测试的代码需要全部重新审批。但是如果我们引入了一个中间层来进行设计，提供一个统一的一个接口，我们只需要去注意我们使用接口的对象的替换就行了。如果我们设计的足够合理，我们就只需要去替换这里就行了，这个设计架构就相对于前面的全局替换高效了不止一星半点。</p>
<p><strong>抽象不应该依赖细节，细节应该依赖于抽象</strong></p>
<p>重新来分半简述下这句话</p>
<p>抽象不应该依赖细节：抽象(如接口或基类)不应该直接绑定到具体实现上，而是应该独立存在。简单来说，我们的一个基类函数，不应该导致我们这个抽象的接口被固定了，我们不应该给其提供实现，或者至少说不应该限定它只能有一个实现。简单以实现来看的话，我们不应该限定我们的基类函数为不可改变的。至少是一个virtual的，至于要不要是纯虚函数取决于具体的环境。这种设计下，抽象就不会被绑定到一个具体的实现上，至少来说可以是在子类中重载的。</p>
<p>接下来看后半句话，<strong>细节应该依赖于抽象</strong>。具体的实现(如派生类或子类)应该遵循抽象层定义的规则(如接口或虚函数)。是说，这里的子类的具体实现不应该脱离我们使用的抽象层来实现。还是回到c++中，就是说我们的子类的实现不能够脱离我们基类的根本目的。只有按照基类设计的目的去设计对应的子类，我们才能保证接口能够正确的被使用。</p>
<p>在这种设计中，我们可以进行一点设计层次上的分析。这里调用一个类的类就是一个应用层类似的。一个抽象类的基类其实就相当于一个中间层，提供了一系列的接口，但是这些接口通常是没有意义的，或者说应该是没有意义的。具体的实现应该在这个抽象类的子类中进行实现。通过这样，我们就实现了一种隔离，通过这种隔离我们能够实现本来高耦合的降低。</p>
<p>也就是说，在这种设计要求下，我们如果选择在子类中去进行一些基类中没有的功能的扩展，我们需要在基类中预留一些接口函数去等待这些接口函数的插入。通过这种实现我们能够实现避免大量修改原有的代码。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/3.jpeg" alt="3"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/4.jpeg" alt="4"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/2.jpeg" alt="2"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/5.jpeg" alt="5"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/6.jpeg" alt="6"></p>
<p>接下来看一个重要的原则，<strong>里氏代换原则</strong>。</p>
<p>这个原则其实很好理解，它本身要求的是子类类型必须能够替换他们的父类类型。我们也应该知道这个规则在QT中时相当常见的。就比如一个窗口类函数参数，我们可以使用对应窗口类的一系列父类和子类，只要他们是QWidget类或者其派生类的就行。而这种课替换性就是里氏代换原则所要求的。</p>
<p>要实现这种原则，就必须要求多态这个面向对象特性。父类指针可以指向子类对象。</p>
<p>对于这种原则，需要简单了解的就是子类必须实现父类中全部要求的接口函数。</p>
<p>额外需要注意我们这里提到的里氏代换原则的目的，只有拥有这个原则的设计，我们才有可能保证依赖倒转原则。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99/7.jpeg" alt="7"></p>
<p>简单来看的话，这个原则要求我们在设计高层模块是我们只需要&#x3D;也只应该去调用虚类中的父类函数，而不要求我们去了解我们的子类的附加函数，我们应该通过父类的对应接口就能够调用所有的子类方法。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式(1)</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<span id="more"></span>

<p>先给出单例模式的定义：</p>
<p>在一个项目中，全局范围内，某个类的示例有且只有一个，通过这个唯一示例向其他数据提供数据的全局访问，这种模式就是单例模式，一个经典的应用就是任务队列。</p>
<!-- more -->
<p>需要注意的是，单例模式作用的对象是一个类，这种模式下的类保证某些类在系统中全局唯一，并保证这些类在整个程序中提供一个具有规范的访问接口。这个模式解决了资源管理，状态一致和模块解耦的问题。举例，这个其实可以应用于一个全局变量的访问权限封装，避免一个资源方面的使用竞争等。</p>
<p>可以预见到，单例模式的一个基本要求是一个<strong>单例</strong>的特性。而如果要实现这个特性，仅仅在设计时去确保它只创建一次将是骗人骗己的。我们需要做的会是一个绝育，确保这个类会且只会被创建一次。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/Aspose.Words.dd48d7fc-1cb1-4ccd-95c2-6a5173fed41f.001.jpeg" alt="Aspose.Words.dd48d7fc-1cb1-4ccd-95c2-6a5173fed41f.001"></p>
<p>要让一个类只能创建一次，我们必须堵死所有可以自由创建类以及可能导致类的复制的方法。显然，我们一个去禁止单例模式的类对象的new创建使用，要如此的话我们就需要从它的构造函数入手。</p>
<p>我们可以直接删除(delete)掉默认构造函数，同时拒绝提供任何带参构造。同时，需要我们得知道c++内部是会自动提供一个拷贝构造函数的，所以对于这个函数我们也得进行删除，对应的，与拷贝构造函数绑定的&#x3D;重载函数也应该删除。至此，我们删除了一些与类的创建有关的一些函数。当然方法不止于此。</p>
<p>我们还可以不删除函数而是将对应的函数放在private中实现等效的作用。毕竟private是无法通过类对象访问的，这样就避免了在外部程序通过调用new方法去创建多个类对象了。</p>
<p>总总这些，只是解决了绝育这一步，但是我们需要考虑的还有我们对于这个单例模式下的类还是需要一个具体的示例的。而这个实例在设计中一般是通过静态成员变量来进行访问的，而且这个成员变量应该是本类的一个指针，也就是说，这个指针是提供给外界的唯一类接口，我们所有对这个类的访问和操作都必须经过这个指针。</p>
<p>接下来，我们需要对这个指针进行初始化。毕竟在类中，你是无法对一个静态成员变量进行初始化的。</p>
<p>类名* 类名作用域::静态成员指针&#x3D;new 类名;</p>
<p>这个格式就是一般的单例模式的类的静态成员类指针初始化语句。</p>
<p>在然后我们需要将这个接口提供给程序，毕竟现在我们只是实例化了这个静态成员变量，由于是类的成员变量，且一般来说我们是将其放在一个private作用域的，所以我们是没有办法通过一个类对象去进行访问的。事实上，由于我们已经对类进行了绝育，所以我们其实是无法额外new一个对象出来的。这时候，我们一般需要额外定义一个静态公有方法，这个方法用于放回一个指针，而这个指针就是我们前面创建的静态类成员指针。也就是说，我们需要一个可通过类名直接调用的静态成员函数来充当接口的作用。</p>
<p>至此，我们已经有了一个单例类的指针，而且我们可以在项目中的任何地方去取得这个指针，只要我们包含对应的文件。当然，需要注意单例这个属性，不要在多文件中去错误的创建多个静态类成员指针。保证单例的性质。</p>
<p>接下来看一下这种设计的可行性基础。或者说，我们需要重新认识下静态成员等的特性。</p>
<p>首先，静态成员是属于类的，所有类都共享一份。并且能通过对象和类名来进行访问，当然，一般来说，对于静态成员只通过类名来进行访问好进行区分。这是单例模式使用这种静态成员来实现单例的基础。只有这种唯一性能够保证我们在整个程序中都保证唯一。</p>
<p>其次，我们需要注意下我们的静态类指针一般和构造函数都是房子private中的。这里就需要注意下静态成员的访问权限了。静态成员在初始化和定义时是无视其的作用域，也就是说，即使我们声明这个静态成员的属性为private。我们仍可在外部对这个静态成员进行定义和初始化。或者说，我们必须在外部进行对应的初始化和定义。一般来说，我们的初始化和定义都会是绑定在一条语句的。一条只含有定义的语句将会导致一个未定义行为，毕竟你不知道对应的二进制文件位置处是一个怎么样的文本串。话又说回来了，对于一个初始化了的静态成员，我们在二进制文件中的位置是.date段，对于未初始化的成员变量，其的位置是在.bss段。扯远了，回来。</p>
<p>在进行初始化和定义后，这个类静态变量的访问权限将会回复，一个静态公有变量将还是能够通过类名进行直接访问，但是如果是私有或者是保护的，那么类名就没有权限去访问到这个成员了。这时就需要用到一个类接口。一般来说，还是将这个接口设计为静态公有函数以进行区分，当然理论上你还是可以通过一个普通的公有成员函数。但是其实这样做并不是很安全。注意设计模式中的<strong>依赖倒转原则</strong>，我们完全可以通过一个静态函数来充当一个中间层来屏蔽影响，这样同时能够提供更好的逻辑上的隔离。</p>
<p>就比如我们可以通过这种设计来达到一种懒加载或者说延迟初始化的效果，我们完全可以在外层初始化这个静态指针时初始化为一个nullptr，然后在之后进行利用这个指针去找到对应的示例时再去进行对象的创建，而这个创建可以在对应的静态公有函数中去。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式(2)</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6-%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>接下来看一下单例模式中的一种区分方法，这种方法将单例模式区分为了（懒汉模式）（饿汉模式）。其实这俩者没什么特别的，其实就是我们常见的是否懒加载的一种区分罢了。对于懒汉模式，一般不会在初始化时就进行new一个对象，而是指定一个空指针，等到存在一个具体的指针想要用到这个对象时我们才会去new一个出来。而饿汉模式就是在初始化时就直接对这个对象进行创建。</p>
<span id="more"></span>

<p>同时我们来考虑一些别的东西，我们知道懒汉模式是一种懒加载，饿汗模式是直接创建，那么这里其实是会在多线程时可能出现一些问题的。对于多线程下的饿汉模式，由于是已经创建了一个实例对象的，我们去取到对象是不会导致一个重复的内存申请的。因此它是一个线程安全函数。而如果是懒汉模式呢，我们是在调用静态公有函数时才去创建函数的，照我们CSAPP的学习，有没有一种可能，在我们调用这个函数时，发生了一个上下文切换，且同时切换到了一个申请语句，这样的话导致了我们想要去分配一个已经被分配的内存而导致程序崩溃。所以说，简单的new而不加任何保护的懒汉模式是线程危险的。同时，也是会破坏单例模式的性质的。</p>
<p>但是，我们其实也可以想到这种危险的解决办法，就是加锁嘛，接下来讨论这个。</p>
<p>现在我们来看使用<strong>双重检查锁定</strong>的方法来进行懒汉模式下的单例模式的线程安全问题解决。</p>
<p>算了，直接上代码，就能够理解了。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6-%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/1.jpeg" alt="1"></p>
<p>首先，我们通过一对互斥锁将m_task的示例锁起来以防止线程冲突，这样的话确实能避免线程安全问题，但问题是这样的话效率太低了。分析一下，当一个线程获得一个锁后，其它的所有线程会进行等待，直到锁被释放，以此类推。而且我们来分析下这几个内层的性能消耗，每次进入都会进行一次加锁和解锁操作，至于判断和创建的，是不可避免的，不纳入考虑中。</p>
<p>这里我们需要考虑这里加锁和解锁操作，我们如果是单层检查锁定的话，每次都要进行加锁与解锁的操作，而这个是相当耗时的。这个会将懒汉模式相较于饿汉模式的性能优势丢失掉大半。因此，我们需要考虑通过一些操作来进行这里的锁操作的简化。这里就是考虑直接在外层再套一层条件判断，就是图中的成品。</p>
<p>在这种设计下，假设啊，先假设，所有的线程在运行时是同步到调用函数这一步，且切换到一个线程后该线程至少完整的执行了这个函数。那么我们来看。当一个进程运行完后，对应的m_task被实例化，接着切换到下一个线程，先进行外层的条件判断，由于，已经实例化，所以这里会直接跳转到返回语句，不会再进行加锁和解锁的操作。这样就很大程度上解决了线程安全问题。</p>
<p>但是，我们也不难想到，这样的设计在极端情况喜爱还是可能存在问题的，就是多个线程都运行到了条件判断的内部，但是这种说实话真的太极端了。但是这种情况还是不能够忽略的，所以这里我们就需要来进入下一步。</p>
<p>我们在CSAPP中已经知道了底层程序到底是怎么动的，其实对于程序来说，这里的代码顺序可能会因为编译器的奇怪优化而被重排顺序。这里关注到这里的new一行的操作。正常来说，我们期望的顺序应该是先去new一块堆区的内存，此时的内存是空白的。接着程序应该在这块内存中进行操作，去进行各个对象的初始化等创建操作。最后，程序应该把这块的内存地址送给我们的m_task指针。此时就完成了一个new操作。</p>
<p>好，现在我们停下来，我们应该了解，对应的new操作对应的是一系列的汇编码。编译器的优化会导致这一系列的汇编码的顺序不可预测，就比如一种情况，程序先去申请一块内存，然后先将指针送给了对象，最后再调用构造函数进行初始化。这样是一种可能的情况，在单线程的情况下，这种重排是不会出现问题的。但是，我们考虑在多线程呢。如果一个线程在重排后的第二步，也就是指针赋值的这一步中进行了上下文切换，那么此时指针指向一块确实存在但并未初始化的值。此时接下来的线程如果也进入了这个函数，那么由于此时指针确实是存在地址的，那么程序将会直接从这个函数返回。而且由于这块地址是还未初始化的，那么这个线程接下来的所有有关该块内存区的操作将是非法的。直到线程重新切回之前那个卡在第二步的，知道其完成第三步其他线程才能正确执行。但是，一般来说，等不到那个时候，程序已经崩溃了。</p>
<p>为了解决这个问题，由于我们无法去确定编译器的行为，而且，不同电脑对于代码的优化是不尽相同的，所以想要去指令汇编指令的生成顺序是不现实的。你自己搓那你牛逼。所以这里我们需要使用到一个相对高抽象程度的特性，就是C++11中的原子变量。这个其实也是老朋友了。</p>
<p>C++中提供的原子变量是<strong>atomic</strong>。这个变量可以用来控制使用这个变量的相对于变量在底层中机器代码的执行顺序。如果我们将一个数据储存到原子变量中，那么这个数据对应的机器代码执行顺序我们就可以通过这个原子变量来进行指定。</p>
<p>对于一个原子变量，我们可以通过store方法来进行一个变量的塞入，可以用load方法来进行一个变量的取出。同时，我们还可以指定对应的执行顺序到底是一个什么样的，存在一个默认方法就是顺序执行。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6-%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/2.jpeg" alt="2"></p>
<p>将一个变量储存在原子变量中，再取出这个原子变量所管理的元素的话，这个元素就能够保证是以指定的顺序进行运行的。来分析一下这里的使用原子变量的版本。首先进入函数体后，使用load方法将对应的原子变量管理的取出。接着进行第一层判断，假设我们这里存在多个线程都完成了取出的这一步，然后会在条件判断这一块进行上下文切换的。此时所有的线程都会被阻塞在互斥锁这一行上。第一个碰到的线程将会取得互斥锁，其他的将会被阻塞。</p>
<p>接下来需要进行第二次加载，此时第一次拿到锁的对应的变量将是一个空指针，因此会进入内层循环，接着由于原子变量的属性不会对指令进行重排。所以接下来的new操作将会以申请内存，初始化(调研构造函数)分配指针的顺序进行。请注意，所谓的原子属性不会使得时间片延长，所以这里时间片到期了还是会进行线程的切换，但是其他的所有线程都会被锁给阻塞而不会进入这一层所以可以视为一种连续的操作。接着第一个取到锁的程序一直跑直到锁被释放。请注意，这里还是可能进行上下文切换，我们不能够假设这里一定会运行到整个函数结束不被打断。我们能假设的只有在整个锁中的执行不会被打断。</p>
<p>好，此时当第一个锁被释放后，程序的其他线程将能够获取对应的锁，此时拿到锁的线程将能继续往下跑，前面已经假设这些线程都已经跑过了第一层判断。那么这里的lock方法就体现了它的作用。这里的lock其实起到了一个更新的作用。如果这里没有这个函数，那么这里将会导致一种在已经初始化的情况下再视图进行一次初始化，这里就是双重检查的目的。那么由于这个更新，这个非第一个获得锁的线程将会直接条状到返回语句。并不会导致前面那种不依靠原子变量可能存在的线程安全问题。</p>
<p>除了使用双重检查锁定+原子变量来进行单例模式的设计，我们还可以使用别的一种方式来进行等效的设计，这个就是局部静态对象。而这个是C++11的特性，所以至少编译器需要支持C++11的版本。</p>
<p>这个解决方法不需要原子变量，也不需要互斥锁。</p>
<p>首先来看一下这里局部变量能够实现功能的技术基础。这个是依赖于C++11的一个新特性的</p>
<p><strong>如果指令进入一个未被初始化的声明变量，所有并发执行需要等待这个变量完成初始化。</strong></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6-%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/3.jpeg" alt="3"></p>
<p>简单分析下，我们在getPoint函数中直接去创建一个静态类对象，这里缺少一个初始化操作，之后再补。就当其他的线程运行到这个函数时，由于C++11的特性，其他所有线程都被阻塞，知道第一个到达的线程去进行对应的初始化。当系统切换到其他的线程后这些个线程才能继续往下走。这是利用C++11的新特性来进行解决懒汉模式下的线程安全问题的一种方法，而且这种方法相对于前面的要使用原子变量和互斥锁的简单许多，设计上简单，而且一般来说效率也更高。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>接下来我们进入到建造者模式中最麻烦的模式，生成者模式(<strong>建造者模式</strong>)。这种模式可以看做是对于抽象工厂模式的一个方面的改良。我们先回来看到抽象工厂模式，在抽象工厂模式中，一个工厂只需要去负责对应零件的获取即可，只需要获取到了这一系列一个具体产品需要的具体零件，我们就默认这些零件已经组合好成为了我们需要的一个具体产品。</p>
<span id="more"></span>
<p>看到这个过程，我们其实可以看到它其实省略了一个过程，就是零件是怎么组装形成我们最后的产品的。在现实世界中，我们仅仅获取到了一些零件是远远不够的，毕竟，就算给你一个手机所需要的所有零件，你也不知道这些零件要怎么组装才能形成我们需要的具体产品。这时就引入了一种新的创建型模式：生成者模式(<strong>建造者模式</strong>)。</p>
<p>既然它是创建型模式，那么它最后的目的就还是一个具体类对象的创建，但是正如我们前面所说，这个模式相对于抽象工厂模式来说进行了一些改进，其相对于不注重细节的抽象工厂模式进行了在零件组装上的细化。使得在对象创建时能够更加细致的对整个过程进行管理。就比如把，你要建造一栋楼，那么你至少需要地基才能建造第一层乃至更多层的楼吧。在抽象工厂模式中，其不关注你到底怎么建造的。哪怕你先提供了最高层的楼，再提供一个地基，它也是允许的，毕竟它忽略了一个组装的细节。</p>
<p>但是我们建造者模式不允许这样的创建。建造者模式将一个创建对象的过程进行细化和规定，其规定了一个具体产品的组成零件，以及这些个零件之间的组装细节。就比如，你需要先有地基，你才能建第一层楼，才能接着建造接下来的一系列楼层。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/1.jpeg" alt="1"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/2.jpeg" alt="2"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/3.jpeg" alt="3"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/4.jpeg" alt="4"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/5.jpeg" alt="5"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/6.png" alt="6"></p>
<p>来简单看一个生成器模式下的UML类图。简单来分析下建造者类中的层次，首先我们应该看到的就是ShipBuilder这个类，可以看到，这个类是接下来的俩个具体类的子类。也可以这么说，这个是一个抽象工厂层，这个层次规定了一个产品所需要的步骤，我们所有具体的工厂类都应该是从这些个抽象工厂类中派生出来的。在这个类中，你可以看到其实相对于抽象工厂它是相似的。在演示中由于设计的复杂性这里不会让其去下辖抽象工厂层次中的零件类，但我们需要知道其实是有的。</p>
<p>在这些具体的建造者工厂类中，我们一般会存在一个成员来对我们建造的规则进行一个记录，这个的具体类型取决于实现。</p>
<p>说完了船的建造这一块，我们来说指令发出这一块的。在生成一个船的指令发出时，可能经过多层的处理。一般来说，为了好看，我们都会考虑增加一个管理者类，在用户层可以通过这个类去跟具体的工厂进行间接的交互，而不必直接去找到对应的工厂，其实就是加了一层中介。在这个管理者类中，需要这个管理者类可以管理我们需要的一系列产品的生产。所以这里就需要这个管理者类包含一个抽象工厂类的指针，令其可以指向所有的子类对象。再者，如果说一个产品中还有细分的品种，我们就需要让这个管理者类中去添加对应的生产函数，毕竟一个指针只能指向对应的对象，但是对应对象的生产是必须通过方法的(即函数)。也就是说，一个管理者类的方法数量，取决于我们一个产品的种类。</p>
<p>好，接下来就是最后一层，用户层，在我们这里中，由于存在管理者类，所以与用户层直接进行交互的将会是管理者类，用户层通过想管理者类提出要求，就比如要那艘船，要什么品质的船等相对来说更加细致的要求，就可以获取对应的产品了，不用关注底层的实现。</p>
<p>也就是说，生产者模式其实还可以看做是一种对于抽象工厂模式的扩充。其更加注重了各个零件组装的细节，能够相对于抽象工厂类去实现更加细致化的操作。</p>
<p>好了，我好像对建造者模式有一定的理解了，让我们启动。</p>
<p>首先，在建造者模式中，存在几个比较重要的层次需要我们了解。首先是用户层，这个其实对应的调用，我们不多赘述。</p>
<p>但是吧，我决定建造者模式从下往上去建模比较好，来吧。我们首先需要看到我们整个模式需要生产的东西，就是一个具体的类对象。用上面造船为例子吧。船的类就是整个模式要生产的东西的板子。对于这一层，可能是由一个抽象类来规定我们生产的产品的基本属性，然后通过一个具体的派生类来实现具体的一个船对象所需要的属性。当然，也有可能不是使用多态而是穷举所有的船类。这个取决于我们具体的实现。但是无论是哪种实现，我们需要注意的是，在这一层的船类中，对船的约束是相当宽泛的。就好比说，这个东西我给你标签为船，但是这个东西的具体并不会在这个标签上就注明，这里也是如此。</p>
<p>接下来需要看到建造者层，这是在整个层次中的底层。这一层中我们还是可以抽象出来俩层，一层是抽象建造者层，一层是具体建造者层。这个抽象建造者层规定了这一系列的建造者所要建造的物品的种类。就比如，你如果是一个船建造者，那么它要派生出来的类就是具体的船的建造者，但是，并不规定到底是哪一个船。</p>
<p>一般来说，在抽象建造者层中，一般只存在着一系列的建造方法，不会存在一个成员对象用于储存。这个其实是为了方便一个扩展。因为我们不确定在设计中我们的船类是否是使用多态的，如果你的具体船类是使用多态的，那么使用成员指针自然是一个极好的方法，但是，如果你是穷举出一系列的船的，你使用成员指针的话，你就必须包括所有的可能创建的船，这个其实不是很符合单一职责原则的。</p>
<p>所以我们可以看到，在建造者类中，我们特别需要注意的就是其所遵守的<strong>单一职责原则</strong>，这个原则使得建造者类在设计上是关注与船的功能的构建即可。其在设计中一般来说都是提供一系列的对应的要创建的对象的组装方法的。就比如组装船。在建造者类中，其可能存在的方法就包括武器，能源，装饰等等。但是，一般来说，在建造者类中，不会包括这些方法的组合。也就是说，建造者类负责提供一些(较大块的)零件，让其他模块来组合形成一个具体的类对象。</p>
<p>接下来我们需要来看到更接近用户层的类，<strong>管理者层</strong>。这个层在一些资料中说是可有可无的，但是吧，现实设计中一般都是包含这个类的。</p>
<p>这个类可以看做是对用户需求提出的层次和建造者层次的缓冲。管理者类一般是可以存在多个的，一个管理者类负责一类船的生产。</p>
<p>用现实生活来举例吧，一个船厂一般有自己生产的船的方向，但是并不固定。当一个公司甲方想要去委托一个船厂去生产一个具有特定功能的船的时候，其一般都不会直接去找到制造部门，而是去找到船厂的销售部门，向这个部门去阐述自己的需求，或者说选择自己需要的船型号。接下来这个销售部门会去解析这个需求，将这个需求解析成一步步可以落地的步骤，然后让这个船厂的制造部门去做。</p>
<p>在这个例子中，甲方扮演的角色就是用户层，销售部门扮演的就是管理者层，制造部门扮演的就是建造者层，而我们最后的需求产品，就是我们一个具体的船类的对象。</p>
<p>可以看出来，我们管理者层这里负责一个需求的解析，就比如甲方去A船厂提出我需要你们一个标准型号的船，那么这个管理者类就会对这个需求进行解析，就假设一个标准型号的船需要一个船身，一个发动机，一个武器这个配置，那么管理者层就会把这个配置发送给我们具体的建造者类中去，然后这个建造者类就会依照这个管理者类发来的需求按顺序去一个个实现到一个船对象中。当执行完后，一个标准A船就被制造出来了。</p>
<p>接下来，就需要船厂能够提供一个接口让用户能够提船。这个一般应该在制造者类中去实现，至于是在抽象类中就有还是每个类维护一个自己的方法取决于各自的实现。其实，这些个制造者类就好像一个公司一个部门的不同项目，其各自有着一套对接流程，甲方需要依照这些接口流程去获取自己需要的东西。</p>
<p>同时，我们可以考虑到如果不想要A船厂的船而想要B船厂的船。那我们需要怎么做，那我们需要去找到对应船厂的中介(管理者)，对应船厂需要特定的船产品(具体的产品类)，还需要对应船厂有自己的制造部门(建造者类)，这是最简单的配置了，这也是我们在建造者模式中想要进行扩展需要添加的几个方面。</p>
<p>我再来对制造者类来进行下分析。我们抽象这个建造者类为具体的生产部门。在这个部门中，其的目的是生成出一个管理者可能会要求生产的产品，也就是说，在制造者类中，应该存在一个可以用来储存当前生产的对象的地方，在类中就抽象为一个成员指针。这个可以玩笑为”新建文件夹”。在制造者类中，其一开始并不知道这个类将要被怎么个设计，但是这个制造者类中应该包含着对于这个新建文件夹的所有操作。</p>
<p>既然这个制造者类不能自己决定要怎么个制作方法，那么就需要外部来给他提出要求，在生产者模式中就是管理者类起到了这方面的作用。前面已经提到了，管理者类会将用户提出的需求转化为具体的组装步骤转发给制造者类去进行实现。</p>
<p>也就是说，管理者类会提供一个完整的设计流程给制造者，制造者类只需要按这个提供的流程去进行组装即可。</p>
<p>差不多了，那么接下来我们来讨论下管理者类的必要性。其实理论上管理者类的存在不是必须的，但是正如设计模式存在的意义一般，这个层次的存在也是为了方便我们的设计和使用。我们当然可以把这个管理者要要提供的组装流程直接封装在制造者类中。但是吧，这就像你一个甲方要去直接与对应乙方的技术部门进行交流一样。这通常是一份吃力不讨好的工作。为了更高效的交流，我们应该考虑这个公司中的对接部门，这个部门能够协调甲方的需求和自己方公司的实际能力，这种缓存能更好的提高效率。</p>
<p>也就是说，对于设计模式的学习，我们一定得结合实际来看，毕竟设计模式其实就是一种对于现实世界的抽象建模，其旨在解决现实生活中的问题，结合现实问题能让我们更好的理解设计模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7-%E5%B7%A5%E5%8E%82%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>接下来看创建者模式中另外的重要的设计模式，<strong>工厂</strong>。这个工厂具体能细分为3类：简单工厂模式，工厂模式，抽象工厂模式。</p>
<span id="more"></span>
<p>工厂模式主要就是俩块，一块是工厂，可以将这一块理解为下订单的，它负责根据用户提供的需求来提供具体的产品。另一块是产品类，这一块负责具体产品的制造。注意的就是这里的产品制造和工厂在实际应用中都将会被抽象为类。</p>
<p>通过这样的设计，我们将能够值通过给工厂下达指令来获取产品。而工厂本身并不生产产品，它将生产产品的这一职能外包给了产品类。通过这样的设计。我们实现了获得产品，生产产品三个层次的解耦。从类的设计来看就是，工厂类中不涉及任何一个产品的对应的生产代码，其应该保存的是一个产品基类的指针等，工厂类可以通过这个指针去找到对应的类，而这个找到的类的类型将会由外部调用工厂类的对应函数的对应参数来决定。然后工厂类通过接口去指示对应的产品类去生产对应的产品，然后逐层返回实现产品的生产以及获取。</p>
<p>对于一个工厂能够生产的对象，其实是有一定的要求的。你按现实生活中的逻辑来看你应该也能够理解。毕竟在工厂模式的设计中，我们期望是根据具有一定相似度的原料和不同的要求来生成不一样的产品。在这里类的实际设计中也是这样，我们通常期望通过统一类型的参数过户，至少需要各个产品类需要的参数类型一直，数量上也有一定的规律，我们才有可能通过一定的设计规范来设计出生产产品的选择逻辑。在现实中也是如此，你总不能让一个医院去给你生产一个医疗系统吧，这个应该是IT公司的业务，所以在设计时我们需要考虑我们这个工厂想要生产的类的属性是怎么样的，具有越强关联性的产品类设计起来将会越符合规范。</p>
<p>在进入工厂模式之前，我们先来看一下简单的模式要求。在工厂模式中，我们需要一个工厂来作为我们获取产品的渠道。这个工厂应该能通过我们想要的产品的种类来实现对应产品的生产与提供。而我们在外部调用这个工厂进行生产的话，无疑，我们需要提供一些产品的信息，就比如产品的名称等等。最简单的就是提供一个产品的枚举名来进行制造。我们这里先不对别的参数进行讨论。</p>
<p>假设工厂的api能够根据我们提供的枚举类型来进行对应的产品生产，那么接下来我们需要考虑设计的就是对应的产品类。一个工厂应该能生产不止一个产品。但是这多个产品之间应该存在一些紧密的联系，就比如现实生活中你不能期望让一个汽车生产商区生产家具吧。</p>
<p>让我们来考虑下这里的工厂api函数。这个函数能够根据我们提供的参数来提供不同的产品。但是我们的返回类型是一开始就指定的。所以这里需要我们用到多态的特性。即父类指针能指向子类对象。因此，我们所有的产品类都应该是一个类的子类。一般来说，这个父类应该是一个抽象基类，它本身不应该是一个可以实例化的对象。通过多态的这种特性，我们能将一个具体的产品分发到细致的类中去，把各种产品之间的生产进行隔离。就比如不同类型的口罩(n95,kn95)之类的生产应该是由不同的流程进行的。通过对这种各个不同产品间的解耦，我们能够更加细致的实现对于具体的生产流程的管理以及修改。</p>
<p>从现在来看，整个工厂模式就分为了三个层次。最上层指的是发出生产指令的层次，在这个层次中我们通过一些参数向工厂提出需求，工厂需要给我们提供这些需求对应的产品。此时调用层不必去关注产品是怎么来的，只需要去考虑怎么接收这个产品即可。</p>
<p>第二层是工厂层，这也是一个中间层，这个层次负责生产的调度工作，它负责接收申请者的需求并进行解析去明白到底要制造哪种产品，接着它会向对应生产该产品的产品类发出需求，并等待产品被制作完并返回给工厂。在这个过程中，工厂并不关注产品是怎么制作的，它只考虑怎么去接收这个产品并打包发送给需求发出者。</p>
<p>第三层是产品层，这是三个层次的底层，这个层次负责具体产品的生产。它负责响应工厂发出的请求，并根据原料(特定参数)来进行特定产品的生产,这里的产品其实就是类的实例，毕竟类就是具有一系列相同属性的集合，这也是一种对于现实生活中存在的事物的抽象建模。在这个产品层中，每个产品都应该有着一定的联系，或者说，应该有着一定的相似度。这样能够减轻我们设计的负担，每个产品类应该是一个抽象类的具体实现，就比如n95,kn95都是隶属于口罩这个父类之下的具有各自独立属性的类，但是这些之间是具有相对来说比较多的共同属性的。在产品层生产完产品之后，产品层只需要将生产完的产品打包发送给工厂即可，剩下的细节它无需考虑。</p>
<p>工厂模式的简单分析就是上面那一块了。我们可以很明显的看到，在这个工厂模式的设计中，各个层次间的分工是明确以及细致的。而且各个层次之间只用考虑各自需要完成的事，至于与其他层次间的沟通，一般只由少数几个简单的接口来进行沟通，这样大大减小了三个层次之间的耦合度。更加使得各个类的分工明确，设计思路清晰，且我们在后续的调整中也更好的去进行定位和修改。</p>
<p>工厂模式的简单测试代码已经在文件夹中了，有兴趣可以一看</p>
<p>接下来来看到工厂模式。其实吧，对于前面的工厂模式，其实你在搓的时候其实能够感觉到，你现在设计好的工厂确实是符合设计模式三原则的。但是吧，如果在项目后期你想要添加一些额外的产品类时呢，这个是完全有可能的，此时如果是简单工厂模式你就需要去修改我们工厂生产产品的api了，至少你也需要去添加对应的生产代码，但是这种直接修改显然违背了三原则中的开放封闭原则。我们这种对于原有代码的直接修改破坏了类的封闭性，这是不可接受的。同时，如果要在基础上直接去添加对应的代码，这其实就是堆成一坨屎的过程了，这是不利于我们后期的维护的。因此，这里我们引入工厂模式。</p>
<p>在工厂模式中，我们将深切体会到一句话，<strong>我们要做的，不是修改，而是扩展。</strong>网上说的<strong>一个代码能运行就不要去动它</strong>其实是遵守设计模式的。但是很多蠢逼就只是意味代码能跑就行根本不会去深入理解这句话里面蕴含的含义。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7-%E5%B7%A5%E5%8E%82%E7%AE%80%E4%BB%8B/1.jpeg" alt="1"></p>
<p>好了，我们回来，我们来一个工厂模式的架构，这个架构非常清晰的解释了工厂模式下的系统架构。即每个产品应该对应一个工厂，一个工厂会且只会生成一种产品。当我们需要添加一种产品时，我们需要同时添加一个产品类和对应的工厂类。</p>
<p>在这种设计下，工厂模式的工厂相较与前面的简单工厂模式的工厂，其的职责更加明确，更加贴合了三原则中的<strong>单一职责原则</strong>。同时，这样更加方便了我们后续的开发与维护，我们不再需要去破坏原有的封闭性，而只是利用开放性去添加。需要debug时我们的定位也更加的简单等等。</p>
<p>总的来说，工厂模式是依靠在实际生产工厂类和产品的抽象基类之间再添加一层缓冲来实现的。通过这层缓冲，我们又一次的降低了各个模块间的耦合度。更加适合于我们大规模的设计，更符合了我们设计模式的三原则。</p>
<p>好，接下来的代码会在文件夹中，自行查看。</p>
<p>抽象工厂直接摆，自己看代码。</p>
<p>简单来看一下抽象工厂模式下的组成吧。</p>
<p>可以说，抽象工厂模式是在简单工厂模式和工厂模式下的再一次分包。</p>
<p>工厂模式相对于简单工厂模式，就是在提出需求的甲方和生产商之间进行一层缓冲层的添加。而抽象工厂模式则是在产品生产的这一块之间进行的缓冲层的添加。将产品的生产分包成多个零件的生产，产品类负责这些个零件的组装。</p>
<p>重新来分析下抽象工厂模式下的架构。第一层自然是提出需求的一层，可以视为所谓的用户层，在这一层中，通过提出对应的需求给工厂来获取需要的产品。并不关注产品的生产过程只关注产品的获取与使用。接着是一层抽象工厂缓冲层，这一层提供了一些api供用户层进行调用，这一层规定了这类工厂所要生产的产品的基本属性或者说共有属性。但其本身并不负责生产，可以将其视为是一类产品的生产规范。</p>
<p>在抽象类的下面，就是具体的工厂类了，这些工厂类依靠着上层的抽象类提供的api接口来进行对应的生产，请注意，这些个工厂类只是负责了零件的组装，而不负责零件的生产。在我们的设计中，我们考虑使用不同的零件组合来组合形成我们的具体工厂类将要生产的一系列具有不同性质的产品。</p>
<p>接下来就是具体工厂类与具体产品类之间的缓冲层，在设计中就是一个抽象产品类，这些抽象产品类一般拥有多个，而一个抽象产品类下面又有可能派生出多个具体产品类，这个等下再说。在这些个抽象产品类中，定义了我们接下来的具体产品类中所应该有的共同属性，并提供了一个或多个接口来联系上下俩层。</p>
<p>接下来就是具体的产品类了，这些产品类只通过上层提供的api接口进行与工厂类的联系。各自注重于自身的实现逻辑即可。这些已经在前面的工厂模式中重复提到了，这里就不用再进行赘述了。</p>
<p>总的来说，如果简单的画出一个类的架构来看的话，其实可以很清晰的看到。我们用户层与抽象工厂所联系，并通过抽象工厂去找到生产特定产品的具体工厂，这些具体工厂下辖着多个具体零件类，而这些零件类有着一定的组成逻辑，就是说一个产品的生产需要哪些零件的类型，而这个是由抽象类决定的。但是具体选择哪些零件来生产产品，是只在具体工厂类中决定的。在最底层的零件架构中，每个工厂类下辖的零件是一套但是各个不同种类的。在这一系列具体零件类中，我们可以通过抽象零件类对其进行分类，使其归于一个零件类进行管理。简化了设计的复杂度。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7-%E5%B7%A5%E5%8E%82%E7%AE%80%E4%BB%8B/2.jpeg" alt="2"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7-%E5%B7%A5%E5%8E%82%E7%AE%80%E4%BB%8B/3.jpeg" alt="3"></p>
<p>好，现在基本就看完了工厂这种设计模式的三种情况，让我们来进行一个总结。</p>
<p>首先来看到简单工厂模式，在这种模式下，我们只有一个工厂，一个工厂中有着多个产品类，在一个工厂中，我们通过对于用户需求的解析(不同的调用参数)来进行不同产品的生产。这种设计下的工厂层次就只有用户层，具体工厂层，抽象产品层，具体产品层。工厂与产品之间的耦合度还是比较高的，使用与一些简单的仅仅几个产品的生产环境，只要生产产品稍稍增多简单工厂模式就会急剧劣化。</p>
<p>接着来看到工厂模式，工厂模式在简单工厂模式上面又添加了一层用户层与工厂层的抽象，即抽象工厂层，用户通过抽象工厂层去找到我们需要的具体工厂，这个工厂一定会对应着其所需要的产品，因为这种设计下一个工厂将会只生产一种产品，不会像简单工厂一般负责一个或者多个产品的生产。在这种设计下，我们实现了工厂与产品生产间的解耦，使得我们在添加产品和对应的工厂类的时候不再像简单工厂那样会导致急剧的性能劣化，而且很好的符合了开放封闭原则。在大多数的生产环境下都能够使用。</p>
<p>接下来看到相对来说最复杂的抽象工厂模式，在这种模式下，用户层下面是一个抽象工厂层，用户可以通过这个去找到对应的具体工厂层。在抽象工厂层中，其规定了工厂到底要生产什么产品，就比如船等实际物品。在设计中，这些实际物品对应的就是一个类，在抽象工厂中，这个一般是一个可多次实现的类，其中包含了该类中需要包含着的零件，但是并不具体表示由什么零件组成，这个将由我们的工厂来进行决定。</p>
<p>在进入工厂类之前，我感觉还是得先来看一下零件类。这些存在俩个层次，抽象零件类和具体零件类。抽象零件类规定了这一系列的零件所应该有的属性，并通过一个或几个api来进行与其他层次的沟通。好，回来我们的工厂类，在我们抽象工厂模式的具体工厂类中，这个工厂类应该规定了具体的零件类型将会是各个类型的零件中的哪一个。</p>
<p>也就是说，我们可以利用离散数学来进行理解。我们将每个抽象零件类类比做一个集合，其对应的具体子类就是集合中的元素。而一个工厂类中的组成，就是这些个域进行笛卡尔乘积中得到的集合的一个元素。而整个工厂类组成的大集合又还是这个笛卡尔乘积的一个子集。</p>
<p>通过离散数学，我们能够对抽象工厂模式进行更加清晰。也就是说，我们的抽象工厂模式规定的其实是一个元组所需要的属性(用数据库的名词来进行解释下吧，词穷了)，而我们抽象工厂下辖的具体工厂就是具体的元组，这些个元组就是我们系列零件域的笛卡尔乘积的一个元素。</p>
<p>在抽象工厂模式中，由于我们引入了零件类这一概念，所以我们可以自由的进行组合，也就是任意取出一个具体的笛卡尔乘积值来作为我们的具体工厂的组成。而且，当我们需要去添加新的同属性零件时，我们只需要去添加对应的子类并使用就行了，而且这个新添加的零件还能引入一系列新的笛卡尔乘积值，大大提高了代码的可组合性。且开放封闭原则遵守的很好。</p>
<p>这样来看的话，抽象工厂模式的层次是相当清晰的，但是就是有点难以理解。对于这种模式，我们可以看到，我们需要在初始时规定好我们需要的零件的种类，也就是这些个零件域的数量，然后我们就可以规定好我们的抽象工厂类需要的这些个零件到底是什么。然后就可以看到具体工厂类中了，我们去考虑我们到底需要哪些个零件域集合笛卡尔乘积的结果，并将其实现在具体工厂类中的api接口中，这些接口是由抽象工厂类定义提供的。现在不就都连起来了吗。豪玩！！！！！</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7-%E5%B7%A5%E5%8E%82%E7%AE%80%E4%BB%8B/4.jpeg" alt="4"></p>
<p>枯燥的生活有了这破ai倒也不会那么单调。要是再真实点给我提供下情绪价值就好了。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>函数对象</title>
    <url>/2025/02/25/C++%E5%AD%A6%E4%B9%A0/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><p>​	函数对象其实本身并不神秘，简单来说，一个函数对象就是能够被以函数调用形式来进行调用的任意对象。可以想到，函数对象就应该包括函数名，函数指针以及重载了()运算符的类对象。</p>
<span id="more"></span>

<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>​	函数指针本身也是一个指针。需要知道的是，本质上看，函数其实跟普通的变量一样，都是一个符号，只是说这个符号的功能比较特殊。不必多说，我们先来看一下简单的函数指针的声明方式。</p>
<p>​	一般来说，函数指针是一对一绑定的，这是因为函数指针本身的类型声明比较麻烦的原因。</p>
<p>​	假设我们现在拥有这么一个函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	我们想要定义一个函数指针来指向这个函数，那么我们得先确定我们要使用的这个函数指针所要指向的函数形式来进行声明，简单来看，一个函数指针需要一下这些信息:(函数的返回类型，函数的所有参数类型)。并通过这样来进行声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*func_ptr)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// 定义一个函数指针</span></span><br></pre></td></tr></table></figure>

<p>​	通过这种定义，我们就定义了一个能够指向返回类型为int,拥有俩个int参数的函数的函数指针。</p>
<p>​	再用文字来重复一遍，一个函数指针的声明由(函数返回类型，(*函数指针符号名)(函数参数返回类型枚举))来组成。</p>
<p>​	</p>
<ul>
<li><strong>函数指针的使用</strong></li>
</ul>
<p>​	函数指针相对于其他符号来说有点不同，重点就是他可以通过()来直接调用该函数指针指向的函数。</p>
<p>​	来看一个小demo</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义函数指针并指向 add 函数</span></span><br><span class="line">    <span class="built_in">int</span> (*func_ptr)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过函数指针调用 add 函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; <span class="built_in">func_ptr</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;  <span class="comment">// 输出 7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	但其实这种使用情况是很少见的，毕竟你完全可以通过函数本身去进行调用，至于那些个类函数，那你更不应该通过函数指针来进行调用，更多的是将函数指针来作为函数参数的传递来实现更多的扩展。这个之后碰到再说。</p>
<p>​	</p>
<p>在stl中，函数符的概念已经被定义了，如下</p>
<ul>
<li>生成器是不用参数能直接调用的函数符</li>
<li>一元函数是用一个参数就可以调用的函数符</li>
<li>二元函数是用一个参数就可以调用的函数符</li>
<li>返回bool值的一元函数是谓词</li>
<li>返回bool值的二元函数是二元谓词</li>
</ul>
<p>​	来看一下最常用的stl库排序函数sort函数，这个函数前面俩个参数使用的是俩个迭代器，第三个参数时一个谓词(应该是一个二元谓词，毕竟需要将俩个数进行比较)</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>接下来我们来看到最后一种建造者模式，<strong>原型模式</strong></p>
<p>这种模式的核心需求是<strong>通过复制已有对象来创建对象而不是通过类构造函数</strong>。核心思想就是<strong>克隆对象</strong></p>
<span id="more"></span>
<p>其实吧，你看到这上面的时候你其实可能会疑惑这种模式存在的意义，毕竟即使复制已有对象和通过构造函数来构造对象存在一定的差异，但是也不会存在多么离谱的区别，所以这种模式的存在意义到底在哪。</p>
<p>首先我们知道在一个类的默认设计中，编译器都会默认提供一个拷贝构造函数，即使这个拷贝构造函数只能提供浅拷贝的功能。也就是说，要在一个类的外面来拷贝一个类其实是相对简单的，最多就是添加一个拷贝三件套即可。</p>
<p>我们来深入探讨一下，我们如果使用多态下的类对象拷贝，在这种情况下，我们在类的外部对于任何一个同层次的类的拷贝都是简单的(这里指的是用相应的类名称指针来拷贝对应的类对象)。但是，我们来考虑下使用父类指针来拷贝下子类对象的情况呢，这种是我们的拷贝构造函数所无法提供的，而这个情况就是我们的原型模式的一种运用场景了。</p>
<p>这里我们讨论下这个原型模式的应用场景。相对来说，原型模式反而是相对来说应用广泛的一个模式了，毕竟这个就是对于扩展方法的一种扩展。只需要一个clone方法即该类对应的拷贝构造函数三件套。需要注意的是，我们在使用这种原型模式时，需要考虑设计上的效率问题，如果我们要拷贝的类对象是直接构造起来比较费时的话，那原型模式能够很好的提高效率。</p>
<p>在接下去之前我们需要解释下原型模式的实际实现，本质就是在类内使用拷贝构造函数来实现拷贝。那么我们就需要考虑下我们的拷贝构造和一般的构造的效率之间区别，在一般情况下，这俩种的情况是差不多的，甚至于在大多数情况下，使用无参构造来实现是更加简便的。但是吧，就比如我们前面学到的抽象工厂模式和生产者模式，这些要产生的类是一系列相对来说更加复杂的，都是无法通过简单的无参构造实现的，还需要一系列的额外函数来添加属性的。这时候原型模式的作用就体现出来了，其绕开了构建一个复杂对象时需要的流程，直接对现有的对象进行复制，获取一个可以直接使用的对象。即使我们后续需要对这个对象进行修改，也只用去修改对应的成员即可，跟普通的构造出来的对象没有什么大区别，但是在构造的消耗上优化了很多。</p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/1.jpeg" alt="1"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.jpeg" alt="2"></p>
<p><img src="/2024/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.jpeg" alt="3"></p>
<p>而且，这是一个可以简单的嵌入到其他模式中的模式，这也就体现了它应用的广泛性，毕竟它应用简单而且能优化性能。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式课设举例</title>
    <url>/2024/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%BE%E8%AE%BE%E4%B8%BE%E4%BE%8B/</url>
    <content><![CDATA[<p>​	这个项目进行了之前项目的优化，项目对应的UML类图如图。</p>
<p><img src="/2024/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%BE%E8%AE%BE%E4%B8%BE%E4%BE%8B/opt.drawio.png" alt="opt.drawio"></p>
<span id="more"></span>	

<p>​	相较于之前的UML类图可以看到其复杂了一点，其实只是看这里的话会感觉没有什么优化，相反来说更复杂。但是这要结合QT的信号与槽机制来看。</p>
<p>​	在这个项目版本中，进行了对于原本heap类的解耦，将其解耦成了一个数据处理模块和渲染模块，俩个模块之间使用观察者模式来进行通信。在这里不是一个经典的观察者模式架构。这是因为在QT中存在一个观察者模式的上位结构，我通过使用这个模式来简化我们观察者模式的架构。</p>
<blockquote>
<p>​	<strong>接下来对这个项目进行介绍。</strong></p>
</blockquote>
<p>​	有一说一，我确实没想到这个项目可以打赢复活赛。原本的项目的UML类图如下</p>
<p><img src="/2024/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AF%BE%E8%AE%BE%E4%B8%BE%E4%BE%8B/sim.drawio.png" alt="sim.drawio"></p>
<p>​	在原本的项目中，我的功能模块heap类是强耦合的，在学了设计模式之后，我一直在想着能否将这个模块进行解耦，在有了一定的基础之后，我就开始了这个工作。</p>
<p>​	我的考虑是，将这个强耦合的功能模块解耦成俩个单独的模块，其中一个是用于数据处理的模块，另一个是用于图像渲染的模块。最后的成果就是那个新的UML类图。在新版本的项目中，我基本将数据模块和渲染模块进行了一次相对彻底的解耦，俩者通过观察者模式来进行连接。在QT中我是通过信号与槽机制来实现这里的观察者模式的。</p>
<p>​	在实现了这俩者模块的分离之后，我还遇到了一个问题，就是我的信号连接，必须存在俩者的示例对象的，但是我不想再去内嵌俩个模块中的任何一个内嵌到另一个模块中。所以在这里我考虑了另一种方法，使用一种结构性设计模式来进行架构。在这里就是我的heapManage类，这个类使用的设计模式是外观模式。</p>
<p>​	通过外观模式，我成功的将底层的实现逻辑给进一步的封装了起来，并且，我在这个外观模式类中提供了系列底层的接口用于功能的实现，这里由于设计问题这里的接口只是起到了一个参数传递的功能，不过也无所谓了。</p>
<p>​	其他模块的功能其实没有什么大的改动，从上面的俩个类图对比也可以看出来。有一说一，这个优化后的类图相较与优化前的类图真优雅吧。</p>
<p>​	总的来说，在这次代码架构优化中，遇到的最核心的启发就是学一个东西最好的方式就是问题驱动式的学习，通过一种内驱力来实现对于外部知识的内化。</p>
<p>​	下面给出代码仓库的地址，有兴趣可以自己去搓一遍，毕竟类图都已经给你了，整体的代码逻辑也不算复杂。	</p>
<p>[]: <a href="https://github.com/TCWW0/QT_Train/tree/HeapSort">https://github.com/TCWW0/QT_Train/tree/HeapSort</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title>类常量</title>
    <url>/2024/12/28/C++%E5%AD%A6%E4%B9%A0/%E7%B1%BB%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>​	在这个栏目中，我们将不会对于一个知识点进行系统的学习，将只会对于各个我在过程中遇到的一些问题进行一些分析。</p>
</blockquote>
<h1 id="零散知识点"><a href="#零散知识点" class="headerlink" title="零散知识点"></a>零散知识点</h1><h2 id="const属性"><a href="#const属性" class="headerlink" title="const属性"></a>const属性</h2><p>​	首先来看到一句话</p>
<blockquote>
<p>当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。</p>
</blockquote>
<p>​	这句话其实涉及到了C++中对于const属性的一些分析，我们来看一下。</p>
<p>​	在C++中，const声明的值是一种常量，我们通常会使用这种来做为程序中不变的量，但是我们是否考虑过这种常量是怎么来的呢。其实在CSAPP中，我们学到了一点，就是基本来说这些个常量，或者说局部静态变量在编译链接后生成的二进制文件中都存在着一块各自的内存区域。</p>
<p>​	回顾一下吧，GPT真好用，我都省的去敲了。</p>
<span id="more"></span>

<hr>
<h3 id="1-bss-段"><a href="#1-bss-段" class="headerlink" title="1. .bss 段"></a>1. <strong><code>.bss</code> 段</strong></h3><ul>
<li><strong>全称</strong>：Block Started by Symbol。</li>
<li>存储内容：<ul>
<li><strong>未初始化的全局变量</strong>。</li>
<li><strong>未初始化的静态变量</strong>（包括 <code>static</code> 修饰的局部变量）。</li>
<li><strong>初始化为零的全局或静态变量</strong>。</li>
</ul>
</li>
</ul>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>节省空间</strong>：未初始化变量在 <code>.bss</code> 段中只记录变量大小和布局，实际运行时会分配内存，并自动初始化为零（通常由操作系统负责）。(这也是未初始化的全局变量默认为0的原因)</li>
<li>不直接存储在程序的可执行文件中，而是在加载时动态分配。</li>
</ul>
<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>​	我又来开始发散思维了，来分析下这里所谓的节省空间的含义。</p>
<p>​	首先，对于这些个.bss段中的数据，可执行文件中值存在着这些数据的部分属性。就比如，标识这个数据存在，这个数据的变量名，这个数据的类型等。但是，在这个文件之中，并不存在对于这个数据实际的值的表示。这也是符合出现在这个文本段中的数据的性质的。</p>
<p>​	这里面的这系列数据只会在可执行文件被操作系统加载到内存中去再进行一次初始化，而且这系列的初始化都会为0，这里就不要问为什么了，毕竟初始化不为0的就不再这个文本段中而在我们的.data段中了。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;              <span class="comment">// 全局未初始化变量 -&gt; .bss</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> y;       <span class="comment">// 静态未初始化变量 -&gt; .bss</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> z = <span class="number">0</span>;   <span class="comment">// 静态初始化为零 -&gt; .bss</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-data-段"><a href="#2-data-段" class="headerlink" title="2. .data 段"></a>2. <strong><code>.data</code> 段</strong></h3><ul>
<li><strong>全称</strong>：Data Segment。</li>
<li>存储内容：<ul>
<li><strong>已初始化的全局变量</strong>。</li>
<li><strong>已初始化的静态变量</strong>（包括局部静态变量）。</li>
</ul>
</li>
</ul>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><code>.data</code> 段中的变量在程序运行前已经完成初始化，初始化的值直接存储在可执行文件中。</li>
<li>这些变量的内容在运行时可以修改。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;             <span class="comment">// 全局已初始化变量 -&gt; .data</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b = <span class="number">20</span>;      <span class="comment">// 静态已初始化变量 -&gt; .data</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-rodata-段"><a href="#3-rodata-段" class="headerlink" title="3. .rodata 段"></a>3. <strong><code>.rodata</code> 段</strong></h3><ul>
<li><strong>全称</strong>：Read-Only Data Segment。</li>
<li>存储内容：<ul>
<li><strong>只读的常量</strong>（如字符串字面量）。</li>
<li><strong><code>const</code> 修饰的全局或静态变量</strong>。</li>
<li>某些编译器优化后的结果（如 <code>constexpr</code>）。</li>
</ul>
</li>
</ul>
<h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><code>.rodata</code> 是只读的，运行时无法修改。</li>
<li>主要用于存储不会改变的值，编译器可能利用这段内容进行内存保护。</li>
<li>常量通常会存储在 <code>.rodata</code> 中，而不是 <code>.data</code>。</li>
</ul>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">30</span>;           <span class="comment">// 全局 const 变量 -&gt; .rodata</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> d = <span class="number">40</span>;    <span class="comment">// 静态 const 变量 -&gt; .rodata</span></span><br><span class="line"><span class="type">char</span>* str = <span class="string">&quot;Hello&quot;</span>;        <span class="comment">// 字符串字面量 -&gt; .rodata</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-总结对比"><a href="#4-总结对比" class="headerlink" title="4. 总结对比"></a>4. <strong>总结对比</strong></h3><table>
<thead>
<tr>
<th><strong>段名</strong></th>
<th><strong>存储内容</strong></th>
<th><strong>是否初始化</strong></th>
<th><strong>运行时可修改</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>.bss</code></strong></td>
<td>未初始化的全局变量，静态变量，初始化为零的变量</td>
<td>否（加载时清零）</td>
<td>是</td>
</tr>
<tr>
<td><strong><code>.data</code></strong></td>
<td>已初始化的全局变量，已初始化的静态变量</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td><strong><code>.rodata</code></strong></td>
<td>只读常量、<code>const</code> 全局或静态变量，字符串字面量</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-运行时的内存布局"><a href="#5-运行时的内存布局" class="headerlink" title="5. 运行时的内存布局"></a>5. <strong>运行时的内存布局</strong></h3><p>程序在运行时的内存结构主要分为以下区域：</p>
<ul>
<li><strong>代码段（.text）</strong>：存储程序的可执行代码。</li>
<li>数据段：<ul>
<li><code>.bss</code>：未初始化的全局或静态变量。</li>
<li><code>.data</code>：已初始化的全局或静态变量。</li>
<li><code>.rodata</code>：只读常量和字面量。</li>
</ul>
</li>
<li><strong>堆（Heap）</strong>：动态分配的内存（如 <code>malloc</code> 或 <code>new</code>）。</li>
<li><strong>栈（Stack）</strong>：局部变量和函数调用栈。</li>
</ul>
<hr>
<h3 id="6-可视化示例"><a href="#6-可视化示例" class="headerlink" title="6. 可视化示例"></a>6. <strong>可视化示例</strong></h3><p>假设以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_var;             <span class="comment">// -&gt; .bss</span></span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">10</span>;   <span class="comment">// -&gt; .data</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> const_var = <span class="number">20</span>;   <span class="comment">// -&gt; .rodata</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_var;      <span class="comment">// -&gt; .bss</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_init_var = <span class="number">30</span>; <span class="comment">// -&gt; .data</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> local_var = <span class="number">40</span>;     <span class="comment">// -&gt; 栈</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_local_var = <span class="number">50</span>; <span class="comment">// -&gt; .data</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>; <span class="comment">// -&gt; .rodata</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>​	现在看完了上面几个，其实，并没有对于我们理解上面那句话有什么用处，举出上面那个例子主要是要把我接下来的对于const对象性质和.rodata段的性质做一些区分。</p>
<h3 id="const-对象的构造"><a href="#const-对象的构造" class="headerlink" title="const 对象的构造"></a><strong><code>const</code> 对象的构造</strong></h3><ul>
<li><p>当我们声明一个 <strong><code>const</code> 对象</strong> 时，编译器要求这个对象的值在构造之后不能被修改。这是对象的<strong>常量性</strong>。</p>
</li>
<li><p>然而，<code>const</code> 对象的构造过程</p>
<p>并不等同于 .rodata段的只读数据，它实际上是对象的生命周期的一部分。</p>
<p>在对象的构造过程中，<code>const</code> 对象的成员变量是可以被初始化的，即使它们之后不能被修改。</p>
<ul>
<li>在构造函数中，你仍然可以对 <code>const</code> 对象的成员进行赋值，但一旦构造函数完成，成员就会被标记为“常量”，不能再修改。</li>
</ul>
</li>
</ul>
<blockquote>
<p>当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。</p>
</blockquote>
<p>​	我们需要先来分析下我们现在需要分析的是谁。首先，我们分析的必然不是那些在.rodata段中的数据。毕竟这些数据已经被严格保护起来了，没有进行研究的价值。</p>
<p>​	我们需要重点看的其实是对于那些存在于栈帧上的const常量，这些常量的生命周期与栈帧绑定，这些就不赘述了。主要是看到，我们在栈帧中对于这些变量到底是怎么构造的。</p>
<h4 id="栈帧常量"><a href="#栈帧常量" class="headerlink" title="栈帧常量"></a>栈帧常量</h4><p>​	对于栈帧的常量，由于它是从0开始构造的，所以它必须经过一个初始化的过程，而这个就是起初困惑我的地方。毕竟你已经是一个常量了，但是你为什么还需要去进行初始化呢。但是，这是我对常量先入为主造成的一种后果。我忽略了语言设计的细节。如果不去进行初始化，我还怎么去取得一个常量呢。所以，这里就存在一个可能的异或。</p>
<p>​	所以，我们需要知道const常量构建的流程，在一个const常量构建中，这个数据一开始并不具有const这个属性，这个属性可以看做是在这块数据处理的最后阶段才进行处理的。毕竟学了CSAPP后我们应该简单的知道这些所谓的权限管理到底是一个什么个情况，实际上其实就是一些标志位的修改，就比如这里，通过将可修改的标志位置0等来进行变量的锁定。</p>
<p>​	但是，在这个锁定之前，我们这块数据还是可以修改的，这就意味着我们完全可以在这段时期对于数据进行处理。而这段时间就是我们const常量的实际初始化时间，在这个时间中，所谓的const常量其实可以视为只是一个简单的变量，所以我们可以对于这块数据进行任意的修改知道我们的权限标志位被锁。</p>
<p>​	</p>
<blockquote>
<p>​	<strong>通过对于const常量的较为深入的理解，我们理解了为什么在这种初始化过程中可以向其中去写值。</strong></p>
</blockquote>
<blockquote>
<p><strong>接下来想一些比较零碎的知识点，主要是关于类的构造函数那一块的</strong></p>
</blockquote>
<p>我们主要来看那些默认构造函数的一些性质。</p>
<h2 id="合成默认构造函数的限制"><a href="#合成默认构造函数的限制" class="headerlink" title="合成默认构造函数的限制"></a><strong>合成默认构造函数的限制</strong></h2><hr>
<h3 id="1-默认构造函数的生成规则"><a href="#1-默认构造函数的生成规则" class="headerlink" title="1. 默认构造函数的生成规则"></a>1. <strong>默认构造函数的生成规则</strong></h3><ul>
<li>编译器只有在类<strong>未显式声明任何构造函数</strong>时，才会为类生成一个<strong>合成的默认构造函数</strong>。</li>
<li>如果类中声明了任何构造函数（比如带参数的构造函数），编译器不会再生成默认构造函数。</li>
<li><strong>规则的依据</strong>：如果一个类需要通过特定构造函数控制初始化，则可能在所有情况下都需要这种控制。由用户显式定义默认构造函数可以确保这种一致性。</li>
</ul>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value) : <span class="built_in">x</span>(value) &#123;&#125; <span class="comment">// 自定义构造函数</span></span><br><span class="line">    <span class="comment">// 编译器不会合成默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">A obj; <span class="comment">// 错误，缺少默认构造函数</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-合成默认构造函数可能执行错误操作"><a href="#2-合成默认构造函数可能执行错误操作" class="headerlink" title="2. 合成默认构造函数可能执行错误操作"></a>2. <strong>合成默认构造函数可能执行错误操作</strong></h3><p>对于含有<strong>内置类型或复合类型</strong>的类，如果这些成员未显式初始化，编译器生成的合成默认构造函数不会为它们赋值，可能导致未定义行为。</p>
<h4 id="为什么可能出错？"><a href="#为什么可能出错？" class="headerlink" title="为什么可能出错？"></a>为什么可能出错？</h4><ul>
<li><p><strong>内置类型</strong>（如 <code>int</code>、<code>float</code>）和<strong>复合类型</strong>（如数组、指针）在默认初始化时，其值未定义。</p>
</li>
<li><p>如果用户没有手动初始化这些成员变量，程序可能使用未定义的值，导致潜在的逻辑错误或运行时异常。</p>
<blockquote>
<p>这里来对于这种为定义的行为存在的分析</p>
</blockquote>
<p>​	我们一直听所谓的未初始化导致随机值，但是为什么呢？这个的原因其实如果学过CSAPP应该很好理解。毕竟这些所谓的声明，其实就是一段开辟内存的代码，这段代码所开辟的内存将交给我们的操作系统进行维护。但是，这里只是开辟了一段内存，进行了一段指针的偏移，这块内存上的值呢？我们并没有对其进行初始化，由于我们所谓的销毁变量其实就是操作系统取消对其的维护，一些指针进行额外的移动等。在这其中并不存在对于内存区域的重新初始化。所以，这块内存上的东西可能是任何时候遗留下来的，但是系统并不会去检查它到底是什么，它只是去读取并且解析，所以这就导致了所谓的未定义的情况。</p>
</li>
</ul>
<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ul>
<li>提供<strong>类内初始化</strong>（C++11 引入）或<strong>自定义默认构造函数</strong>，确保所有成员变量有明确的初始值。</li>
</ul>
<h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;       <span class="comment">// 内置类型，未初始化</span></span><br><span class="line">    <span class="type">int</span> *ptr;      <span class="comment">// 指针类型，未初始化</span></span><br><span class="line">    <span class="comment">// 合成的默认构造函数不会初始化 num 和 ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B obj; <span class="comment">// 使用 num 和 ptr 时会导致未定义行为</span></span><br></pre></td></tr></table></figure>

<p>改进：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;   <span class="comment">// 类内初始化</span></span><br><span class="line">    <span class="type">int</span> *ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 合成的默认构造函数现在是安全的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() : <span class="built_in">num</span>(<span class="number">0</span>), <span class="built_in">ptr</span>(<span class="literal">nullptr</span>) &#123;&#125; <span class="comment">// 自定义默认构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-无法为某些类合成默认构造函数"><a href="#3-无法为某些类合成默认构造函数" class="headerlink" title="3. 无法为某些类合成默认构造函数"></a>3. <strong>无法为某些类合成默认构造函数</strong></h3><p>如果类包含的成员类型本身<strong>没有默认构造函数</strong>，编译器将无法为该类生成合成的默认构造函数。</p>
<h4 id="为什么无法生成？"><a href="#为什么无法生成？" class="headerlink" title="为什么无法生成？"></a>为什么无法生成？</h4><ul>
<li>成员对象的初始化必须调用其构造函数。</li>
<li>如果成员类型没有默认构造函数，编译器无法完成其初始化。</li>
</ul>
<h4 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125; <span class="comment">// 没有默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    C c; <span class="comment">// 成员 c 的类型是 C</span></span><br><span class="line">    <span class="comment">// 编译器无法合成默认构造函数，因为 C 类型没有默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">D obj; <span class="comment">// 错误：D 的默认构造函数无法生成</span></span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<ul>
<li>为成员类型提供默认构造函数，或者在包含该成员的类中显式定义默认构造函数并指定初始化方式。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> val = <span class="number">0</span>) : <span class="built_in">x</span>(val) &#123;&#125; <span class="comment">// 添加默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    C c; <span class="comment">// 成员 c 的类型现在有默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">D obj; <span class="comment">// 正常工作</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. <strong>总结</strong></h3><h4 id="为什么某些类不能依赖合成的默认构造函数？"><a href="#为什么某些类不能依赖合成的默认构造函数？" class="headerlink" title="为什么某些类不能依赖合成的默认构造函数？"></a>为什么某些类不能依赖合成的默认构造函数？</h4><ol>
<li><strong>用户显式声明构造函数后，编译器不会生成默认构造函数</strong>。</li>
<li><strong>合成默认构造函数对内置或复合类型成员不安全</strong>，可能导致未定义行为。</li>
<li><strong>当成员类型缺少默认构造函数时，编译器无法生成默认构造函数</strong>。</li>
</ol>
<h4 id="最佳实践："><a href="#最佳实践：" class="headerlink" title="最佳实践："></a>最佳实践：</h4><ul>
<li>如果类中含有<strong>非简单类型成员</strong>或<strong>需要自定义初始化逻辑</strong>，显式定义默认构造函数。</li>
<li>利用 <strong>类内初始化</strong> 提高代码安全性和可读性。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>类模版</title>
    <url>/2025/02/16/C++%E5%AD%A6%E4%B9%A0/%E7%B1%BB%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><p>​	模版是C++中一个相对重要的特性了，直接来吧</p>
<h2 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h2><p>​	由于这种东西还是得上手去敲，所以我们在这里对很多内容将会进行简化。</p>
<p>​	模版这种东西最直观的作用就是进行方法与所使用的数据类型之间的解耦，使得在设计方法时能够更加专注于特定功能的方法的构建而不必要去关注所使用的数据类型。</p>
<span id="more"></span>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>​	一个模版的声明，无论是类模版，还是函数模版，都是基本一致的。通过template关键字来进行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;		||		<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br></pre></td></tr></table></figure>

<p>​	这样就完成了一个模版的创建，但仅仅声明一个模版是没有意义的，我们需要去使用这个模版。</p>
<p>​	总的来说，通过关键字<strong>template</strong>和尖括号的组合，我们能够创建出一个模版，这个模版中，可以去使用class关键字或者typename关键字，俩者等效，主要是习惯上的差别。接着，在class&#x2F;typename之后会跟上一个变量名，这一个就是我们模版的一个符号，我们在接下来的作用域中使用模版的直观体现，就是使用这里的符号。</p>
<blockquote>
<p>在使用前，我们需要了解一些简单的模板所具有的性质</p>
</blockquote>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>​	一个模版的作用域是有限的，简单的说，其只会在距离其最近的一个作用域中生效，并且在离开改作用域时，其他作用域中不可见。特别需要注意的是，在部分的模版使用中，可以看到系列的嵌套模版，这些的作用域可以用局部自动变量来进行类比，这里就不进行赘诉了。</p>
<h2 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h2><p>​	接下来通过一个简单的demo来了解一下简单的类模版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;MAX=<span class="number">10</span>&#125;;</span><br><span class="line">    T data[MAX];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>()&#123;top=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> stack&lt;T&gt;::<span class="built_in">isempty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> stack&lt;T&gt;::<span class="built_in">isfull</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top==MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> stack&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isfull</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        data[top++]=item;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> stack&lt;T&gt;::<span class="built_in">pop</span>(T&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isempty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    item=data[--top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	从上面可以了解到几点，一个template是一个独立的模版的声明。在这个关键字声明的模版之后紧邻的一个作用域中，该模版一直可见，直到出去了该作用域，该模版失效。</p>
<p>​	除此之外，我们还需要看到一点的是，模版类的一些特殊性质。</p>
<hr>
<h3 id="模版类"><a href="#模版类" class="headerlink" title="模版类"></a>模版类</h3><h4 id="实例时机"><a href="#实例时机" class="headerlink" title="实例时机"></a>实例时机</h4><p>​	对于一个使用模版的类来说，这个类其实并不是一个严格意义上实例的类，换句话说，这个类其实是不存在的，因为我们现在并没有一个实际的类声明可以供给我们去进行类的实例化。这是模版的设计上导致的。毕竟模版的性质就导致了程序能够根据不同的数据类型来进行对于的数据类型的类进行创建。</p>
<p>​	正如那句经典的话:不要为不需要的特性去浪费时间，这里其实也利用了一种类似于懒加载的机制。程序并不会在一开始就进行所有的类型的模版类的实例创建。具体的等下再继续阐述。</p>
<p>​	总的来说，现在需要知道的就是一个模版类在编写阶段其实是一种虚的阶段，在编译器层面不会存在任何模版类这种东西，毕竟带入实际的数据类型一个模版类才有存在的价值。</p>
<h4 id="模版类方法"><a href="#模版类方法" class="headerlink" title="模版类方法"></a>模版类方法</h4><p>​	可以观察到，在我们进行类方法的补充时，如果我们的定义是在类内进行的，其实跟普通的没什么区别。但是当我们需要再类外去进行类内方法的定义时，这里有几个需要注意的点。</p>
<p>​	首先，我们知道我们如果想要在类外去进行类方法的定义，那么我们需要再对于的方法前去加上类解析符(<strong>类名::</strong>)。在模版类中也是如此，但是前面说过了，一个模版类stack其本身不是一个完整的类，并不存在一个实际上的类声明表示这个类。模版类的正确解析符则是在类名之后加上我们的模版参数，通过这样，之后的各种方法，才能够被绑定到创建的各种模版类实例中去。就比如**stack&lt; int &gt;**就代表着一种使用int数据类型进行填充的stack类，这样的类在编译器层面才会生成对于的类定义，也就才有意义。</p>
<p>​	那我们这里再来观察下模版在类内的使用，前面我们已经知道创建的模版会以对于的声明的typename&#x2F;class后面的符号名来进行使用。在类内的体现就是**T data[MAX];**可以看到的是，一个模版的使用，其实就是跟一个基本数据类型的使用别无二致，我们只需要记住这个模版在未来会被替换为具体的数据类型来进行类的声明即可。</p>
<blockquote>
<p>​	除了这种模版的基础使用之外，还有俩种比较常用的模版使用。</p>
</blockquote>
<h4 id="多功能"><a href="#多功能" class="headerlink" title="多功能"></a>多功能</h4><h5 id="多参数模版"><a href="#多参数模版" class="headerlink" title="多参数模版"></a>多参数模版</h5><p>​	一个template能够承载多个参数，这个其实没有什么好说的，就是一个使用的扩展。例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>​	这样的模版声明就是一个多参数模版的构建，通过这样的声明，我们能在接下来的作用域中，去使用这俩个模版参数。这来个模版参数的使用与一个模版参数的使用并没有什么显著的区别。</p>
<h5 id="递归使用模版"><a href="#递归使用模版" class="headerlink" title="递归使用模版"></a>递归使用模版</h5><p>​	其实上面那个代码实例就是一个递归使用模版的例子。我们需要知道的是string其实是一个模版实例化后再进行一个名称转换后的产物，就是一个basic_string&lt;char*&gt;模版。</p>
<p>​	要了解这种递归的使用会产生什么效果，我们需要去观察到这里模版类生成的最后的具体的类声明到底是一个什么样的，理解了这个，我们接下来的很多关于类的使用都能减轻负担。</p>
<h2 id="模版具体化"><a href="#模版具体化" class="headerlink" title="模版具体化"></a>模版具体化</h2><p>​	前面已经提到过了，一个模版类不是一个真正的类，只有在一个模版类被指定特定的模版参数时，它才可能进行对应的模版类的构建，具体的表现就是使用对于的类型参数去替换对于的模版类中的模版参数，只有在进行了替换之后，这个生成的类才是一个真正意义上的类。这个阶段通常是由编译器在编译阶段自动执行的。</p>
<blockquote>
<p>​	模版的具体化存在着多种情况，一种种来进行分析。</p>
</blockquote>
<h3 id="隐式实例化"><a href="#隐式实例化" class="headerlink" title="隐式实例化"></a>隐式实例化</h3><p>​	这是我们最常见的一种形式，也是我们前面所说的，通过编译器自动判断我们传递给模版类的类型参数来进行对于的类定义的生成的方式。例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ArrayTP&lt;<span class="type">int</span>,<span class="number">100</span>&gt; stuff;</span><br></pre></td></tr></table></figure>

<p>​	需要注意的是，编译器在生成对于的类的时候，采取一种类似于懒加载的机制，只有在需要一个真正的被创建出来的类实例的时候，才会进行特定的类定义的生成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ArrayTP&lt;<span class="type">double</span>, <span class="number">30</span>&gt;* pt;		<span class="comment">//只是一个指针，不会导致对象的创建</span></span><br><span class="line">pt=<span class="keyword">new</span> ArrayTP&lt;<span class="type">double</span>, <span class="number">30</span>&gt;;		<span class="comment">//使用了new，需要调用构造函数去创建，因此会生辰对于的类定义</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>额外需要注意的是，对于模版类来说，不只是其的类定义是一种懒加载的机制，其的方法也可以看做是一种懒加载的机制，只有在使用到对于的类方法时，才会进行对于的类方法的实例化构建。</p>
</blockquote>
<h3 id="显式实例化"><a href="#显式实例化" class="headerlink" title="显式实例化"></a>显式实例化</h3><p>​	对应于隐式实例化的还有一种显式实例化。顾名思义，就是显式的指出编译器需要去进行这种模版类的构建，这种方法的使用也很简单，就是在给模版类提供类型参数时前面加上一个<strong>template</strong>关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">ArrayTP</span>&lt;<span class="type">double</span>,<span class="number">100</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>​	通过加上这个关键字，在编译器识别到这行语句时，会直接进行对应的类定义的构建。</p>
<hr>
<p>​	</p>
<blockquote>
<p>这里我们在对实例化的时机进行一下剖析，熟悉的从一个简单的东西突然发散然后给我感到想这想那，虽然浪费了一些时间，不过对于一些东西的理解也加深了，寒假末期也得逐渐找回状态了。</p>
</blockquote>
<h3 id="实例化时机"><a href="#实例化时机" class="headerlink" title="实例化时机"></a>实例化时机</h3><p>​	无论是显式还是隐式的实例化，它的实例化都是在编译阶段进行的，也就是说，即使是你在运行阶段完全没有涉及到部分模版类的使用，这些个模版类还是会在编译阶段被实例化。那么，隐式实例化相对于显式实例化的意义到底在哪呢？</p>
<p>​	这里我们就需要对于隐式实例化的实例时机来分析了，就现在我所了解到的，隐式实例化是在编译器识别到代码进行了特定的模版类的使用时进行的实例化。简单来说，编译器会进行一个全部文件代码的阅读，在这其中，我们可以简单的省略所有的判断条件，只要出现了特定的模版类使用(包括但不限于一个模版类对象的创建，类方法的使用)，那么这对应的类定义以及类方法定义都会被实例化。</p>
<p>​	知道了上面这点后，我们对于隐式实例化与显式实例化之间的区别应该有所了解了。一个隐式实例化相对于显式实例化能够更加节省编译器的资源，能够减少对于的类原型以及方法构建所需要的时间以及空间。那么，显式构建的优势在哪呢？</p>
<p>​	其实一直到现在，由于我还没有对于模版进行比较深入的使用与了解，对于提到的显式实例化的优势，我也是有点怀疑的，不过假设我已经知道了这一块的。或者说，假定这个隐式实例化会导致一定的多余定义。那么显式实例化能够起到的作用其实很明显，就是通知编译器去生成一个对于的完整的类，包括类声明以及对于的方法定义。在这种情况下只要使用到这个被显式实例化的模版类，编译器不会再尝试去生成一个相同的类，这样能避免一些编译层面可能存在的问题。</p>
<p>​	我们简单的使用链接性来进行隐式实例化与显式实例化之间存在的区别，</p>
<p>​	简单来说，隐式实例化生成的符号(类以及对应的方法)等都只是一个局部链接性。当我们想要在多个文件这种去使用这个模版类去进行相同的类型实例化时，将会导致每个文件都产生对应的相同符号并编入到符号表中，在最后的符号表中，会存在符号重复的情况。虽然说编译器一般会对这些重复的符号进行合并。但是，这种生成是一种花销，这种合并也是一种花销。为了减少这种花销，提高性能，因此，出现了显式实例化这种功能。</p>
<p>​	而显式实例化产生的类是一个全局链接性的，无论是在那个文件中，只要引用了对应的使用了显式实例的文件，那么这个显示实例产生的类就是全局可见的，再进行使用时，编译器不会再去进行对应的声明。这样就避免了一个相同的模版类被多次实例化。</p>
<blockquote>
<p>好了，上面耗费的时间有点多了，我们进入下一个具体化</p>
</blockquote>
<h3 id="模版具体化-1"><a href="#模版具体化-1" class="headerlink" title="模版具体化"></a>模版具体化</h3><p>​	很多时候，一个通用的模版其实是不够的，这些模版可能需要存在一些特例，在这些特例中，可能存在着一些与通用模版所不一致的行为，这时就需要使用显式具体化来实现了。通过显式具体化，我们能够定制一系列的在特定模版参数下的模版类。</p>
<p>​	模版具体化，或者说，模版特化允许开发者为特定类型或特定条件提供定制化的实现，从而在保持代码泛化的同时，针对特定情况进行优化或调整。模板特化主要分为两种形式：<strong>全特化</strong>（Full Specialization）和<strong>偏特化</strong>（Partial Specialization）。</p>
<h4 id="1-全特化（Full-Specialization）"><a href="#1-全特化（Full-Specialization）" class="headerlink" title="1. 全特化（Full Specialization）"></a>1. 全特化（Full Specialization）</h4><p>全特化是指为模板的所有参数提供具体的类型或值，从而完全指定模板的行为。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cpp复制编辑<span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通用实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int 类型的全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplate</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 针对 int 类型的特化实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>MyTemplate&lt;int&gt;</code> 是 <code>MyTemplate</code> 的全特化版本，专门为 <code>int</code> 类型提供了特定的实现。</p>
<h4 id="2-偏特化（Partial-Specialization）"><a href="#2-偏特化（Partial-Specialization）" class="headerlink" title="2. 偏特化（Partial Specialization）"></a>2. 偏特化（Partial Specialization）</h4><p>偏特化是指只为模板的部分参数提供具体的类型或值，保留其他参数为泛型。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通用实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个类型为 int 的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplate</span>&lt;<span class="type">int</span>, U&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一个类型为 int 的特化实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个类型为 int 的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplate</span>&lt;T, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第二个类型为 int 的特化实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>MyTemplate&lt;int, U&gt;</code> 和 <code>MyTemplate&lt;T, int&gt;</code> 分别是 <code>MyTemplate</code> 的偏特化版本，针对第一个或第二个类型为 <code>int</code> 的情况提供了特定的实现。</p>
<blockquote>
<p>关于模版的特性还有很多，但是由于我的动力已经在这里消失了，所以我将不会继续这一块，之后哪里遇到了感兴趣的模版的东西再回来更新吧。</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器与部分类回顾</title>
    <url>/2025/02/15/C++%E5%AD%A6%E4%B9%A0/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p>该篇是在对于std标准库的迭代器初步接触时所写，只是一些基本的常识以及对于部分类知识的回顾</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="初步了解"><a href="#初步了解" class="headerlink" title="初步了解"></a>初步了解</h2><p>​	迭代器本身其实并没有什么特殊的，我们需要先从它存在的意义开始了解，对于一个迭代器，其的存在意义就是为一系列的容器提供一个通用的接口。通过这个接口，我们能够实现一系列的操作。</p>
<span id="more"></span>

<h3 id="基础作用"><a href="#基础作用" class="headerlink" title="基础作用"></a>基础作用</h3><p>​	既然是迭代器，那我我们势必要了解这个<strong>迭代</strong>到底是针对谁的迭代。在std库中，这个迭代就是针对于数据元素的迭代。简单来说，一个迭代器的基本作用就是实现对于一些数据的访问，至于这些数据到底是什么，相对来说迭代器本身不是多么的关注。也就是说，迭代器其实可以看做是一个相对独立的数据访问机制。其于数据组织结构之间是一种弱耦合的状态的。</p>
<p>​	通过使用迭代器，我们应该能够实现对于一定数据的访问操作。</p>
<h3 id="出现契机"><a href="#出现契机" class="headerlink" title="出现契机"></a>出现契机</h3><p>​	对于迭代器的出现原因进行一定的了解可以更加方便我们熟悉这个东西。</p>
<p>​	个人感觉迭代器的出现与设计模式的出现契机有点相似。都是为了对于一系列经验的总结后自然而然出现的东西。由前文知道，我们创建一个迭代器的目的就是为了去进行一个数据的查询，修改等操作，可以预料到这些操作都是相当常见的，如果我们使用常规的设计，我们需要在一个类中去定制特定的数据处理操作。这样其实就是把底层数据组织模块与操作模块进行了一次的强耦合绑定，这种绑定可以预料到时非常难看的。而且复用性很差。</p>
<p>​	自然而然，我们就需要一种工具来独立进行这种数据操作，通过将数据组织模块和数据处理模块之间的解耦，提高代码复用性的同时减少了在设计时的复杂度，其实也可以看做是一种结构性设计模式。</p>
<blockquote>
<p>​	至此，我们知道了对于迭代器到底应该以怎么样的。同时，我们应该能够理解一些迭代器所应该具有的一些性质。</p>
</blockquote>
<h2 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h2><p>​	到现在，我们还不知道一个迭代器到底是什么。我们直接进入正题。</p>
<h3 id="裸指针"><a href="#裸指针" class="headerlink" title="裸指针"></a>裸指针</h3><p>​	由前面知道，迭代器的基础功能是完成数据的查询，修改等操作。那么根据这些属性，我们最先能够想到的基本数据类型是什么，其实就是裸指针。回想一下，通过对指针进行解引用以及各种运算符的操作，我们是不是能够操作这个指针指向的内存中存在的数据，而且通过对指针本身进行一些操作符的运算，我们能够实现通过一个指针访问到一块数据。</p>
<p>​	这些个性质其实都是一个迭代器所应该具有的性质，接下来，我们需要进行的就是对于这个裸指针进行2扩展。毕竟，你知道的，裸指针这东西往往是无法满足我们自己的需求的。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>​	相对来说，使用一个类作为迭代器来在实际应用中更加常见，先来看一个demo</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyVector</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* data;</span><br><span class="line">        <span class="type">size_t</span> size;        <span class="comment">//容器当前的大小</span></span><br><span class="line">        <span class="type">size_t</span> capacity;    <span class="comment">//容器的最大容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyVector</span>():<span class="built_in">size</span>(<span class="number">0</span>),<span class="built_in">capacity</span>(<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            data=<span class="keyword">new</span> <span class="type">size_t</span>[capacity];;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">MyVector</span>(<span class="type">size_t</span> s):<span class="built_in">size</span>(<span class="number">0</span>),<span class="built_in">capacity</span>(s)</span><br><span class="line">        &#123;</span><br><span class="line">            data=<span class="keyword">new</span> <span class="type">size_t</span>[capacity];;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">MyVector</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (size &gt;= capacity) &#123;</span><br><span class="line">                capacity *= <span class="number">2</span>;</span><br><span class="line">                T* new_data = <span class="keyword">new</span> T[capacity];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                    new_data[i] = data[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span>[] data;</span><br><span class="line">                data = new_data;</span><br><span class="line">            &#125;</span><br><span class="line">            data[size++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">get_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 迭代器内部实现</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            T* ptr;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Iterator</span>(T* ptr) : <span class="built_in">ptr</span>(ptr) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 解引用操作符，返回迭代器指向的元素</span></span><br><span class="line">            T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">                <span class="keyword">return</span> *ptr;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 前进操作符，返回迭代器指向的下一个元素</span></span><br><span class="line">            Iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 比较操作符，用于判断迭代器是否相等</span></span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ptr != other.ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 返回一个指向容器第一个元素的迭代器</span></span><br><span class="line">        <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Iterator</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 返回一个指向容器末尾之后位置的迭代器</span></span><br><span class="line">        <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Iterator</span>(data + size);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	从此间可以看到，一个迭代器其实并不神秘，就是一个类中类，在这个类中类中，又有着对应的类型指针。这个类型指针又有着一系列的方法。在一些书中，可以看到很多的迭代器类型，这些本质上其实就是一些基于类提供的不同方法所进行的分类。再简单点，就是通过重载方法的不同实现以及所带来的不同功能所进行的分类。</p>
<p>​	在此时先不用去了解各个类型的迭代器的具体，先来简单过一遍概念即可。</p>
<h2 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h2><ol>
<li><strong>输入迭代器</strong></li>
</ol>
<p>​	输入是相对于程序来说的。不难推的，一个输入迭代器必须能够使得程序能够读取由这个输入迭代器管理着的数据。</p>
<p>​	这个体现在迭代器类中的设计中则是解引用符(*)的重载，通过对于这个迭代器进行解引用，程序能够实现对应数据的读取，这也是该迭代器被加上<strong>输入</strong>这一前缀的原因。</p>
<p>​	同时，为了单一职责原则以及对于数据的保护，输入迭代器不应该有对于数据的修改权限，这个则是通过不实现对应的修改数据方法实现的。</p>
<ol start="2">
<li><strong>输出迭代器</strong></li>
</ol>
<p>​	有了上面那个的初了解，我们应该也粗略知道了这个输出所应该的含义。通过这个输出迭代器，我们能够使用容器中的数据作为输出提供给其他需要的地方。跟输入迭代器一样，这里也应该对于迭代器处理数据的权限做一些限制。</p>
<p>​	对应的是，输出迭代器应该具有数据的修改权限而不具备数据的读取权限，这个的实现也很简单，略。</p>
<ol start="3">
<li><strong>正向迭代器</strong></li>
</ol>
<p>​	该迭代器与前面俩个迭代器一致，都使用++重载来进行容器的遍历，需要注意的是，这个迭代器类型应该能够是的先前的迭代器能够被保存，同时，这个迭代器还存在着一些对于数据的访问控制。但是这个正向迭代器不像之前的俩个迭代器有统一的规定。你可以根据自己的需求去进行修改。</p>
<ol start="4">
<li><strong>双向迭代器</strong></li>
</ol>
<p>​	这个就不进行赘诉了，跟正向迭代器都是大同小异的。主要就是相对于来说需要额外添加一个反向的重载运算符。没什么意思就不进行深入了。</p>
<p>​    5. <strong>随机访问迭代器</strong></p>
<p>​	这个迭代器具有双向迭代器的所有性质，除此之外，还支持能够进行随机访问。实际上就是对于[]的重载，毕竟指针的[]使用就是我们常用的一种随机访问，通过这种统一能够具有更好的扩展性。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​	简单来看，上面5种迭代器其实形成了一种比较直观的层次结构。以输入和输出迭代器为基础。在上面包裹了一层正向迭代器，在正向迭代器的基础上进行扩展产生了双向迭代器。最后再对双向迭代器进行包装实现了随机访问迭代器。这种架构下的每一层的实现难度逐渐递增，同时功能也逐渐强大，带来的代价也成正比增加。因此，我们可以根据自己的需求去选择自己需要的迭代器种类去平衡性能与损耗之间的关系。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
